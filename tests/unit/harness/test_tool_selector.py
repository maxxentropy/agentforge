# Generated by AgentForge
# Spec: tool_selector
# Phase: red
# Date: 2025-12-31 05:25:17 UTC

"""Tests for tool selector."""

import pytest
import tempfile
import json
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

from tools.harness.tool_selector import ToolSelector
from tools.harness.tool_registry import ToolRegistry
from tools.harness.tool_domain import ToolDefinition, ToolProfile, DomainTools


class TestToolSelector:
    """Test ToolSelector class."""

    def test_init_with_registry_creates_selector(self):
        """Test that ToolSelector initializes with registry."""
        registry = Mock(spec=ToolRegistry)

        selector = ToolSelector(registry)

        assert selector.registry == registry
        assert selector.project_domain is None

    def test_init_with_project_domain_sets_domain(self):
        """Test that ToolSelector initializes with project domain."""
        registry = Mock(spec=ToolRegistry)

        selector = ToolSelector(registry, project_domain="python")

        assert selector.registry == registry
        assert selector.project_domain == "python"

    def test_get_tools_returns_combined_tool_list(self):
        """Test that get_tools returns combined tools from multiple sources."""
        registry = Mock(spec=ToolRegistry)
        base_tool = ToolDefinition(name="base_tool", description="Base", parameters={}, category="base")
        phase_tool = ToolDefinition(name="phase_tool", description="Phase", parameters={}, category="phase")
        domain_tool = ToolDefinition(name="domain_tool", description="Domain", parameters={}, category="domain")

        # Mock registry responses
        registry.get_base_tools.return_value = [base_tool]
        registry.get_profile.return_value = ToolProfile(
            workflow="test_workflow",
            phase="test_phase",
            tools=["phase_tool"]
        )
        registry.get_tool.side_effect = lambda name: {
            "base_tool": base_tool,
            "phase_tool": phase_tool,
            "domain_tool": domain_tool
        }.get(name)
        registry.get_domain_tools.return_value = DomainTools(
            domain="python",
            tools=["domain_tool"],
            detection_patterns=[]
        )

        selector = ToolSelector(registry)
        result = selector.get_tools("test_workflow", "test_phase", "python")

        # Should contain tools from all sources
        tool_names = [tool.name for tool in result]
        assert "base_tool" in tool_names
        assert "phase_tool" in tool_names
        assert "domain_tool" in tool_names

    def test_get_tools_without_domain_excludes_domain_tools(self):
        """Test that get_tools works without domain specification."""
        registry = Mock(spec=ToolRegistry)
        base_tool = ToolDefinition(name="base_tool", description="Base", parameters={}, category="base")
        phase_tool = ToolDefinition(name="phase_tool", description="Phase", parameters={}, category="phase")

        registry.get_base_tools.return_value = [base_tool]
        registry.get_profile.return_value = ToolProfile(
            workflow="test_workflow",
            phase="test_phase",
            tools=["phase_tool"]
        )
        registry.get_tool.side_effect = lambda name: {
            "base_tool": base_tool,
            "phase_tool": phase_tool
        }.get(name)

        selector = ToolSelector(registry)
        result = selector.get_tools("test_workflow", "test_phase")

        tool_names = [tool.name for tool in result]
        assert "base_tool" in tool_names
        assert "phase_tool" in tool_names

    def test_get_tools_deduplicates_by_name_phase_overrides_base(self):
        """Test that get_tools deduplicates tools with phase tools overriding base."""
        registry = Mock(spec=ToolRegistry)
        base_tool = ToolDefinition(name="shared_tool", description="Base version", parameters={}, category="base")
        phase_tool = ToolDefinition(name="shared_tool", description="Phase version", parameters={}, category="phase")

        registry.get_base_tools.return_value = [base_tool]
        registry.get_profile.return_value = ToolProfile(
            workflow="test_workflow",
            phase="test_phase",
            tools=["shared_tool"]
        )
        registry.get_tool.return_value = phase_tool

        selector = ToolSelector(registry)
        result = selector.get_tools("test_workflow", "test_phase")

        assert len(result) == 1
        assert result[0].description == "Phase version"  # Phase overrides base

    def test_detect_domain_identifies_python_project(self):
        """Test that detect_domain identifies Python projects."""
        registry = Mock(spec=ToolRegistry)
        selector = ToolSelector(registry)

        with tempfile.TemporaryDirectory() as temp_dir:
            project_path = Path(temp_dir)
            # Create pyproject.toml to indicate Python project
            (project_path / "pyproject.toml").write_text("[project]\nname = 'test'")

            result = selector.detect_domain(project_path)

        assert result == "python"

    def test_detect_domain_identifies_dotnet_project(self):
        """Test that detect_domain identifies .NET projects."""
        registry = Mock(spec=ToolRegistry)
        selector = ToolSelector(registry)

        with tempfile.TemporaryDirectory() as temp_dir:
            project_path = Path(temp_dir)
            # Create .csproj file to indicate .NET project
            (project_path / "test.csproj").write_text("<Project></Project>")

            result = selector.detect_domain(project_path)

        assert result == "dotnet"

    def test_detect_domain_identifies_typescript_project(self):
        """Test that detect_domain identifies TypeScript projects."""
        registry = Mock(spec=ToolRegistry)
        selector = ToolSelector(registry)

        with tempfile.TemporaryDirectory() as temp_dir:
            project_path = Path(temp_dir)
            # Create package.json with typescript dependency
            package_json = {"dependencies": {"typescript": "^4.0.0"}}
            (project_path / "package.json").write_text(json.dumps(package_json))

            result = selector.detect_domain(project_path)

        assert result == "typescript"

    def test_detect_domain_returns_none_for_unknown_project(self):
        """Test that detect_domain returns None for unknown project types."""
        registry = Mock(spec=ToolRegistry)
        selector = ToolSelector(registry)

        with tempfile.TemporaryDirectory() as temp_dir:
            project_path = Path(temp_dir)
            # Don't create any recognizable files

            result = selector.detect_domain(project_path)

        assert result is None

    def test_get_tool_names_returns_tool_names_only(self):
        """Test that get_tool_names returns just tool names."""
        registry = Mock(spec=ToolRegistry)
        tool1 = ToolDefinition(name="tool1", description="Tool 1", parameters={}, category="base")
        tool2 = ToolDefinition(name="tool2", description="Tool 2", parameters={}, category="base")

        registry.get_base_tools.return_value = [tool1, tool2]
        registry.get_profile.return_value = None

        selector = ToolSelector(registry)
        result = selector.get_tool_names("test_workflow", "test_phase")

        assert result == ["tool1", "tool2"]

    def test_validate_tool_access_returns_true_for_allowed_tool(self):
        """Test that validate_tool_access returns True for allowed tools."""
        registry = Mock(spec=ToolRegistry)
        tool = ToolDefinition(name="allowed_tool", description="Allowed", parameters={}, category="base")

        registry.get_base_tools.return_value = [tool]
        registry.get_profile.return_value = None

        selector = ToolSelector(registry)
        result = selector.validate_tool_access("allowed_tool", "test_workflow", "test_phase")

        assert result is True

    def test_validate_tool_access_returns_false_for_disallowed_tool(self):
        """Test that validate_tool_access returns False for disallowed tools."""
        registry = Mock(spec=ToolRegistry)
        tool = ToolDefinition(name="allowed_tool", description="Allowed", parameters={}, category="base")

        registry.get_base_tools.return_value = [tool]
        registry.get_profile.return_value = None

        selector = ToolSelector(registry)
        result = selector.validate_tool_access("forbidden_tool", "test_workflow", "test_phase")

        assert result is False

    def test_get_tools_handles_missing_profile_gracefully(self):
        """Test that get_tools handles missing workflow/phase profile gracefully."""
        registry = Mock(spec=ToolRegistry)
        registry.get_base_tools.return_value = []
        registry.get_profile.return_value = None  # Profile not found

        selector = ToolSelector(registry)
        result = selector.get_tools("unknown_workflow", "unknown_phase")

        assert result == []  # Should return empty list, not crash

    def test_get_tools_with_project_domain_uses_domain_tools(self):
        """Test that get_tools uses project domain when set."""
        registry = Mock(spec=ToolRegistry)
        domain_tool = ToolDefinition(name="domain_tool", description="Domain", parameters={}, category="domain")

        registry.get_base_tools.return_value = []
        registry.get_profile.return_value = None
        registry.get_domain_tools.return_value = DomainTools(
            domain="python",
            tools=["domain_tool"],
            detection_patterns=[]
        )
        registry.get_tool.return_value = domain_tool

        selector = ToolSelector(registry, project_domain="python")
        # Pass domain explicitly to trigger domain tool lookup
        result = selector.get_tools("test_workflow", "test_phase", domain="python")

        registry.get_domain_tools.assert_called_with("python")
        tool_names = [t.name for t in result]
        assert "domain_tool" in tool_names
