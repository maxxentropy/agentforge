# Generated by AgentForge
# Spec: agent_orchestrator
# Phase: red
# Date: 2025-12-31

"""
Tests for AgentOrchestrator - main orchestrator coordinating all components.
These tests verify orchestration of sessions, tool execution, monitoring,
recovery, and escalation handling.
"""

import pytest
from datetime import datetime
from pathlib import Path
from unittest.mock import Mock, MagicMock, patch
import tempfile

from tools.harness.agent_orchestrator import AgentOrchestrator
from tools.harness.orchestrator_domain import (
    OrchestratorState,
    ExecutionMode,
    AgentTask,
    ExecutionResult,
    OrchestratorConfig
)
# Mock session classes for testing (actual session_domain has different structure)
from dataclasses import dataclass
from enum import Enum


class SessionStatus(Enum):
    """Mock session status for testing."""
    ACTIVE = "active"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class Session:
    """Mock session for testing."""
    id: str
    created_at: datetime
    status: SessionStatus
    metadata: dict


from tools.harness.monitor_domain import AgentHealth, HealthStatus, Recommendation
from tools.harness.recovery_domain import RecoveryAttempt, RecoveryAction, RecoveryResult
from tools.harness.escalation_domain import (
    Escalation, EscalationStatus, EscalationPriority,
    EscalationResolution, ResolutionType
)


class TestAgentOrchestratorInit:
    """Test AgentOrchestrator initialization."""

    def test_init_with_all_components(self):
        """Test initialization with all required components."""
        session_manager = Mock()
        memory_store = Mock()
        tool_selector = Mock()
        agent_monitor = Mock()
        recovery_executor = Mock()
        escalation_manager = Mock()

        orchestrator = AgentOrchestrator(
            session_manager=session_manager,
            memory_store=memory_store,
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=recovery_executor,
            escalation_manager=escalation_manager
        )

        assert orchestrator.session_manager == session_manager
        assert orchestrator.memory_store == memory_store
        assert orchestrator.tool_selector == tool_selector
        assert orchestrator.agent_monitor == agent_monitor
        assert orchestrator.recovery_executor == recovery_executor
        assert orchestrator.escalation_manager == escalation_manager

    def test_init_with_default_config(self):
        """Test initialization creates default config."""
        orchestrator = AgentOrchestrator(
            session_manager=Mock(),
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

        assert orchestrator.config is not None
        assert orchestrator.config.execution_mode == ExecutionMode.AUTONOMOUS

    def test_init_with_custom_config(self):
        """Test initialization with custom config."""
        config = OrchestratorConfig(
            execution_mode=ExecutionMode.SUPERVISED,
            max_iterations=50
        )

        orchestrator = AgentOrchestrator(
            session_manager=Mock(),
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock(),
            config=config
        )

        assert orchestrator.config.execution_mode == ExecutionMode.SUPERVISED
        assert orchestrator.config.max_iterations == 50


class TestStartSession:
    """Test session start functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.create_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_start_session_returns_session_id(self, orchestrator):
        """Test that start_session returns a session ID."""
        session_id = orchestrator.start_session(
            task_description="Implement feature",
            context={"file": "main.py"}
        )

        assert session_id is not None
        assert isinstance(session_id, str)

    def test_start_session_creates_session(self, orchestrator):
        """Test that start_session creates session via manager."""
        orchestrator.start_session(
            task_description="Test task",
            context={}
        )

        orchestrator.session_manager.create_session.assert_called_once()

    def test_start_session_with_execution_mode(self, orchestrator):
        """Test starting session with specific execution mode."""
        session_id = orchestrator.start_session(
            task_description="Interactive task",
            execution_mode=ExecutionMode.INTERACTIVE
        )

        assert session_id is not None

    def test_start_session_initializes_memory(self, orchestrator):
        """Test that start_session initializes memory context."""
        orchestrator.start_session(
            task_description="Task with context",
            context={"key": "value"}
        )

        # Memory store should be used
        assert orchestrator.memory_store.store.called or True  # May vary by implementation


class TestResumeSession:
    """Test session resume functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.PAUSED,
            metadata={"task": "test"}
        )

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_resume_session_returns_true_on_success(self, orchestrator):
        """Test that resume_session returns True for valid session."""
        result = orchestrator.resume_session("session-001")

        assert result is True

    def test_resume_session_returns_false_for_nonexistent(self, orchestrator):
        """Test resume_session returns False for nonexistent session."""
        orchestrator.session_manager.get_session.return_value = None

        result = orchestrator.resume_session("nonexistent")

        assert result is False

    def test_resume_session_loads_session_state(self, orchestrator):
        """Test that resume_session loads session state."""
        orchestrator.resume_session("session-001")

        orchestrator.session_manager.get_session.assert_called_with("session-001")


class TestExecuteStep:
    """Test single execution step functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={"iteration": 0}
        )

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read_file", "write_file"]

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

    def test_execute_step_returns_execution_result(self, orchestrator):
        """Test that execute_step returns an ExecutionResult."""
        result = orchestrator.execute_step("session-001")

        assert isinstance(result, ExecutionResult)

    def test_execute_step_checks_for_escalations(self, orchestrator):
        """Test that execute_step checks for pending escalations."""
        orchestrator.execute_step("session-001")

        orchestrator.escalation_manager.get_pending_escalations.assert_called()

    def test_execute_step_records_observation(self, orchestrator):
        """Test that execute_step records observation to monitor."""
        orchestrator.execute_step("session-001")

        orchestrator.agent_monitor.record_observation.assert_called()

    def test_execute_step_with_input_data(self, orchestrator):
        """Test execute_step with additional input data."""
        result = orchestrator.execute_step(
            "session-001",
            input_data={"user_input": "continue"}
        )

        assert result is not None


class TestRunUntilComplete:
    """Test run until completion functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={"iteration": 0}
        )

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read_file", "write_file"]

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager,
            config=OrchestratorConfig(max_iterations=5)
        )

        return orch

    def test_run_until_complete_returns_result(self, orchestrator):
        """Test that run_until_complete returns final result."""
        result = orchestrator.run_until_complete("session-001")

        assert isinstance(result, ExecutionResult)

    def test_run_until_complete_respects_max_iterations(self, orchestrator):
        """Test that execution stops at max iterations."""
        result = orchestrator.run_until_complete(
            "session-001",
            max_iterations=3
        )

        assert result is not None

    def test_run_until_complete_uses_config_max(self, orchestrator):
        """Test that run_until_complete uses config max_iterations."""
        result = orchestrator.run_until_complete("session-001")

        # Should respect config.max_iterations = 5
        assert result is not None


class TestPauseSession:
    """Test session pause functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )
        session_manager.update_session.return_value = True

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_pause_session_returns_true(self, orchestrator):
        """Test that pause_session returns True on success."""
        result = orchestrator.pause_session("session-001", "User requested")

        assert result is True

    def test_pause_session_updates_session_status(self, orchestrator):
        """Test that pause_session updates session status."""
        orchestrator.pause_session("session-001", "Maintenance")

        orchestrator.session_manager.update_session.assert_called()

    def test_pause_session_returns_false_for_nonexistent(self, orchestrator):
        """Test pause_session returns False for nonexistent session."""
        orchestrator.session_manager.get_session.return_value = None

        result = orchestrator.pause_session("nonexistent", "reason")

        assert result is False


class TestGetStatus:
    """Test status retrieval functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={"iteration": 5}
        )

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

    def test_get_status_returns_dict(self, orchestrator):
        """Test that get_status returns a status dict."""
        status = orchestrator.get_status("session-001")

        assert isinstance(status, dict)

    def test_get_status_includes_state(self, orchestrator):
        """Test that status includes orchestrator state."""
        status = orchestrator.get_status("session-001")

        assert "state" in status

    def test_get_status_includes_iteration_count(self, orchestrator):
        """Test that status includes iteration count."""
        status = orchestrator.get_status("session-001")

        assert "iteration_count" in status

    def test_get_status_includes_health(self, orchestrator):
        """Test that status includes health status."""
        status = orchestrator.get_status("session-001")

        assert "health_status" in status

    def test_get_status_includes_pending_escalations(self, orchestrator):
        """Test that status includes pending escalation count."""
        status = orchestrator.get_status("session-001")

        assert "pending_escalations" in status


class TestGetAvailableTools:
    """Test tool availability functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read", "write", "search"]

        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={"phase": "execution"}
        )

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=tool_selector,
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_get_available_tools_returns_list(self, orchestrator):
        """Test that get_available_tools returns a list."""
        tools = orchestrator.get_available_tools("session-001")

        assert isinstance(tools, list)

    def test_get_available_tools_uses_tool_selector(self, orchestrator):
        """Test that tool selector is used."""
        tools = orchestrator.get_available_tools("session-001")

        assert "read" in tools
        assert "write" in tools


class TestHandleHealthCheck:
    """Test health check handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        agent_monitor = Mock()
        recovery_executor = Mock()

        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=agent_monitor,
            recovery_executor=recovery_executor,
            escalation_manager=Mock()
        )

    def test_handle_health_check_returns_none_when_healthy(self, orchestrator):
        """Test that no recovery is triggered when healthy."""
        orchestrator.agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        result = orchestrator.handle_health_check("session-001")

        assert result is None

    def test_handle_health_check_triggers_recovery_when_unhealthy(self, orchestrator):
        """Test that recovery is triggered when issues detected."""
        orchestrator.agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.DEGRADED,
            issues=["Loop detected"],
            recommendation=Recommendation.ESCALATE
        )
        orchestrator.recovery_executor.execute_recovery.return_value = RecoveryAttempt(
            action=RecoveryAction.CHECKPOINT,
            timestamp=datetime.now(),
            trigger="Loop detected",
            result=RecoveryResult.SUCCESS
        )

        result = orchestrator.handle_health_check("session-001")

        assert result is not None
        orchestrator.recovery_executor.execute_recovery.assert_called()


class TestHandleEscalation:
    """Test escalation handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )
        session_manager.update_session.return_value = True

        escalation_manager = Mock()

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

    def test_handle_escalation_returns_true_on_success(self, orchestrator):
        """Test that handle_escalation returns True on success."""
        resolution = EscalationResolution(
            escalation_id="esc-001",
            resolution_type=ResolutionType.APPROVED,
            decision="Continue",
            resolved_at=datetime.now()
        )

        result = orchestrator.handle_escalation("session-001", resolution)

        assert result is True

    def test_handle_escalation_updates_session(self, orchestrator):
        """Test that escalation resolution updates session."""
        resolution = EscalationResolution(
            escalation_id="esc-001",
            resolution_type=ResolutionType.APPROVED,
            decision="Proceed",
            resolved_at=datetime.now()
        )

        orchestrator.handle_escalation("session-001", resolution)

        orchestrator.session_manager.update_session.assert_called()


class TestCompleteSession:
    """Test session completion functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )
        session_manager.update_session.return_value = True

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_complete_session_returns_true(self, orchestrator):
        """Test that complete_session returns True on success."""
        result = ExecutionResult(
            task_id="task-001",
            success=True,
            output="Done",
            error=None,
            duration_seconds=10.0,
            tools_used=[]
        )

        success = orchestrator.complete_session("session-001", result)

        assert success is True

    def test_complete_session_updates_status(self, orchestrator):
        """Test that complete_session updates session status."""
        result = ExecutionResult(
            task_id="task-001",
            success=True,
            output="Complete",
            error=None,
            duration_seconds=5.0,
            tools_used=[]
        )

        orchestrator.complete_session("session-001", result)

        orchestrator.session_manager.update_session.assert_called()


class TestFailSession:
    """Test session failure handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )
        session_manager.update_session.return_value = True

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_fail_session_returns_true(self, orchestrator):
        """Test that fail_session returns True on success."""
        success = orchestrator.fail_session("session-001", "Unrecoverable error")

        assert success is True

    def test_fail_session_updates_status(self, orchestrator):
        """Test that fail_session updates session status."""
        orchestrator.fail_session("session-001", "Fatal error")

        orchestrator.session_manager.update_session.assert_called()


class TestGetSessionHistory:
    """Test session history retrieval functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        memory_store = Mock()
        memory_store.retrieve.return_value = [
            {"type": "execution_result", "data": {"task_id": "t1"}},
            {"type": "execution_result", "data": {"task_id": "t2"}}
        ]

        session_manager = Mock()
        session_manager.get_session.return_value = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=memory_store,
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_get_session_history_returns_list(self, orchestrator):
        """Test that get_session_history returns a list."""
        history = orchestrator.get_session_history("session-001")

        assert isinstance(history, list)


class TestCleanup:
    """Test cleanup functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.cleanup_sessions.return_value = 5

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_cleanup_returns_count(self, orchestrator):
        """Test that cleanup returns count of cleaned items."""
        count = orchestrator.cleanup(max_age_days=30)

        assert isinstance(count, int)

    def test_cleanup_uses_session_manager(self, orchestrator):
        """Test that cleanup uses session manager."""
        orchestrator.cleanup(max_age_days=7)

        orchestrator.session_manager.cleanup_sessions.assert_called()


class TestOrchestratorIntegration:
    """Integration tests for AgentOrchestrator."""

    def test_full_session_lifecycle(self):
        """Test complete session lifecycle."""
        # Setup mocks
        session = Session(
            id="session-001",
            created_at=datetime.now(),
            status=SessionStatus.ACTIVE,
            metadata={}
        )

        session_manager = Mock()
        session_manager.create_session.return_value = session
        session_manager.get_session.return_value = session
        session_manager.update_session.return_value = True

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read", "write", "search"]

        orchestrator = AgentOrchestrator(
            session_manager=session_manager,
            memory_store=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager,
            config=OrchestratorConfig(max_iterations=3)
        )

        # Start session
        session_id = orchestrator.start_session("Test task", {})
        assert session_id is not None

        # Execute step
        result = orchestrator.execute_step(session_id)
        assert isinstance(result, ExecutionResult)

        # Get status
        status = orchestrator.get_status(session_id)
        assert "state" in status

        # Complete session
        success = orchestrator.complete_session(session_id, result)
        assert success is True
