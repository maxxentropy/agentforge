# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: tools-harness-escalation_manager
# @impl_path: tools/harness/escalation_manager.py

# Generated by AgentForge
# Spec: human_escalation
# Phase: red
# Date: 2025-12-31

"""
Tests for EscalationManager - manages escalation lifecycle.
These tests verify escalation creation, acknowledgment, resolution, and timeout handling.
"""

import tempfile
from datetime import datetime
from pathlib import Path

import pytest

from agentforge.core.harness.escalation_domain import (
    Escalation,
    EscalationChannel,
    EscalationPriority,
    EscalationResolution,
    EscalationStatus,
    ResolutionType,
)
from agentforge.core.harness.escalation_manager import EscalationManager


class TestEscalationManagerInit:
    """Test EscalationManager initialization."""

    def test_init_with_storage_path_creates_manager(self):
        """Test that EscalationManager can be initialized with storage path."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = EscalationManager(storage_path=storage_path)

            assert manager is not None, "Expected manager is not None"
            assert manager.storage_path == storage_path, "Expected manager.storage_path to equal storage_path"
            assert manager.default_timeout == 3600, "Expected manager.default_timeout to equal 3600"# default

    def test_init_with_custom_timeout_sets_default(self):
        """Test that EscalationManager respects custom default_timeout."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = EscalationManager(storage_path=storage_path, default_timeout=7200)

            assert manager.default_timeout == 7200, "Expected manager.default_timeout to equal 7200"

    def test_init_creates_storage_directory_if_not_exists(self):
        """Test that EscalationManager creates storage directory."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir) / "escalations"
            EscalationManager(storage_path=storage_path)

            assert storage_path.exists(), "Expected storage_path.exists() to be truthy"
            assert storage_path.is_dir(), "Expected storage_path.is_dir() to be truthy"

    def test_init_with_channels_sets_active_channels(self):
        """Test that EscalationManager accepts channel configuration."""
        with tempfile.TemporaryDirectory() as temp_dir:
            channels = [EscalationChannel.CLI, EscalationChannel.FILE]
            manager = EscalationManager(
                storage_path=Path(temp_dir),
                channels=channels
            )

            assert manager.channels == channels, "Expected manager.channels to equal channels"


class TestCreateEscalation:
    """Test escalation creation functionality."""

    @pytest.fixture
    def manager(self):
        """Create an EscalationManager for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            yield EscalationManager(storage_path=Path(temp_dir))

    def test_create_escalation_with_minimal_params(self, manager):
        """Test creating escalation with only required parameters."""
        escalation = manager.create_escalation(
            session_id="session-123",
            reason="Test escalation",
            context={"key": "value"}
        )

        assert isinstance(escalation, Escalation), "Expected isinstance() to be truthy"
        assert escalation.session_id == "session-123", "Expected escalation.session_id to equal 'session-123'"
        assert escalation.reason == "Test escalation", "Expected escalation.reason to equal 'Test escalation'"
        assert escalation.context == {"key": "value"}, "Expected escalation.context to equal {'key': 'value'}"
        assert escalation.priority == EscalationPriority.MEDIUM, "Expected escalation.priority to equal EscalationPriority.MEDIUM"# default
        assert escalation.status == EscalationStatus.PENDING, "Expected escalation.status to equal EscalationStatus.PENDING"
        assert escalation.id is not None, "Expected escalation.id is not None"

    def test_create_escalation_with_all_params(self, manager):
        """Test creating escalation with all parameters."""
        escalation = manager.create_escalation(
            session_id="session-456",
            reason="Critical error",
            context={"error": "details"},
            priority=EscalationPriority.CRITICAL,
            recommended_actions=["Action 1", "Action 2"],
            timeout_seconds=7200
        )

        assert escalation.priority == EscalationPriority.CRITICAL, "Expected escalation.priority to equal EscalationPriority.CRITICAL"
        assert escalation.recommended_actions == ["Action 1", "Action 2"], "Expected escalation.recommended_actions to equal ['Action 1', 'Action 2']"
        assert escalation.timeout_seconds == 7200, "Expected escalation.timeout_seconds to equal 7200"

    def test_create_escalation_generates_unique_ids(self, manager):
        """Test that each escalation gets a unique ID."""
        esc1 = manager.create_escalation("session", "reason", {})
        esc2 = manager.create_escalation("session", "reason", {})

        assert esc1.id != esc2.id, "Expected esc1.id to not equal esc2.id"

    def test_create_escalation_persists_to_storage(self, manager):
        """Test that escalation is saved to storage."""
        escalation = manager.create_escalation(
            session_id="session-persist",
            reason="Persist test",
            context={}
        )

        # Should be retrievable
        retrieved = manager.get_escalation(escalation.id)
        assert retrieved is not None, "Expected retrieved is not None"
        assert retrieved.id == escalation.id, "Expected retrieved.id to equal escalation.id"

    def test_create_escalation_sets_created_at_timestamp(self, manager):
        """Test that creation timestamp is set correctly."""
        before = datetime.now()
        escalation = manager.create_escalation("session", "reason", {})
        after = datetime.now()

        assert before <= escalation.created_at <= after, "Assertion failed"


class TestAcknowledgeEscalation:
    """Test escalation acknowledgment functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_acknowledge_escalation_returns_true(self, manager_with_escalation):
        """Test acknowledging an existing escalation succeeds."""
        manager, escalation = manager_with_escalation

        result = manager.acknowledge_escalation(escalation.id)

        assert result is True, "Expected result is True"

    def test_acknowledge_escalation_updates_status(self, manager_with_escalation):
        """Test that acknowledgment updates escalation status."""
        manager, escalation = manager_with_escalation

        manager.acknowledge_escalation(escalation.id)

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.ACKNOWLEDGED, "Expected updated.status to equal EscalationStatus.ACKNOWLEDGED"
        assert updated.acknowledged_at is not None, "Expected updated.acknowledged_at is not None"

    def test_acknowledge_escalation_with_acknowledged_by(self, manager_with_escalation):
        """Test acknowledgment with user identifier."""
        manager, escalation = manager_with_escalation

        manager.acknowledge_escalation(escalation.id, acknowledged_by="user@example.com")

        # Acknowledgment recorded (implementation may vary)
        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.ACKNOWLEDGED, "Expected updated.status to equal EscalationStatus.ACKNOWLEDGED"

    def test_acknowledge_nonexistent_escalation_returns_false(self, manager_with_escalation):
        """Test acknowledging nonexistent escalation fails."""
        manager, _ = manager_with_escalation

        result = manager.acknowledge_escalation("nonexistent-id")

        assert result is False, "Expected result is False"


class TestResolveEscalation:
    """Test escalation resolution functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_resolve_escalation_returns_resolution(self, manager_with_escalation):
        """Test resolving an escalation returns resolution object."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="Proceed with operation"
        )

        assert isinstance(resolution, EscalationResolution), "Expected isinstance() to be truthy"
        assert resolution.escalation_id == escalation.id, "Expected resolution.escalation_id to equal escalation.id"
        assert resolution.resolution_type == ResolutionType.APPROVED, "Expected resolution.resolution_type to equal ResolutionType.APPROVED"
        assert resolution.decision == "Proceed with operation", "Expected resolution.decision to equal 'Proceed with operation'"

    def test_resolve_escalation_updates_status(self, manager_with_escalation):
        """Test that resolution updates escalation status."""
        manager, escalation = manager_with_escalation

        manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="OK"
        )

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.RESOLVED, "Expected updated.status to equal EscalationStatus.RESOLVED"
        assert updated.resolved_at is not None, "Expected updated.resolved_at is not None"

    def test_resolve_escalation_with_notes(self, manager_with_escalation):
        """Test resolution with additional notes."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.MODIFIED,
            decision="Changed approach",
            notes="Detailed explanation here"
        )

        assert resolution.notes == "Detailed explanation here", "Expected resolution.notes to equal 'Detailed explanation here'"

    def test_resolve_escalation_with_resolved_by(self, manager_with_escalation):
        """Test resolution with resolver identifier."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="OK",
            resolved_by="admin@example.com"
        )

        assert resolution.resolved_by == "admin@example.com", "Expected resolution.resolved_by to equal 'admin@example.com'"

    def test_resolve_escalation_supports_all_resolution_types(self, manager_with_escalation):
        """Test that all resolution types are supported."""
        manager, _ = manager_with_escalation

        for res_type in ResolutionType:
            esc = manager.create_escalation("session", f"Test {res_type.name}", {})
            resolution = manager.resolve_escalation(
                escalation_id=esc.id,
                resolution_type=res_type,
                decision="Test"
            )
            assert resolution.resolution_type == res_type, "Expected resolution.resolution_type to equal res_type"


class TestGetEscalation:
    """Test escalation retrieval functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={"key": "value"}
            )
            yield manager, escalation

    def test_get_escalation_returns_escalation(self, manager_with_escalation):
        """Test retrieving an existing escalation."""
        manager, escalation = manager_with_escalation

        retrieved = manager.get_escalation(escalation.id)

        assert retrieved is not None, "Expected retrieved is not None"
        assert retrieved.id == escalation.id, "Expected retrieved.id to equal escalation.id"
        assert retrieved.reason == escalation.reason, "Expected retrieved.reason to equal escalation.reason"

    def test_get_escalation_nonexistent_returns_none(self, manager_with_escalation):
        """Test retrieving nonexistent escalation returns None."""
        manager, _ = manager_with_escalation

        retrieved = manager.get_escalation("nonexistent-id")

        assert retrieved is None, "Expected retrieved is None"


class TestListEscalations:
    """Test escalation listing functionality."""

    @pytest.fixture
    def manager_with_multiple_escalations(self):
        """Create manager with multiple escalations."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc1 = manager.create_escalation(
                session_id="session-1",
                reason="Low priority",
                context={},
                priority=EscalationPriority.LOW
            )
            esc2 = manager.create_escalation(
                session_id="session-1",
                reason="High priority",
                context={},
                priority=EscalationPriority.HIGH
            )
            esc3 = manager.create_escalation(
                session_id="session-2",
                reason="Medium priority",
                context={},
                priority=EscalationPriority.MEDIUM
            )

            yield manager, [esc1, esc2, esc3]

    def test_list_escalations_returns_all(self, manager_with_multiple_escalations):
        """Test listing all escalations."""
        manager, created = manager_with_multiple_escalations

        escalations = manager.list_escalations()

        assert len(escalations) == 3, "Expected len(escalations) to equal 3"

    def test_list_escalations_filter_by_session(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by session."""
        manager, _ = manager_with_multiple_escalations

        escalations = manager.list_escalations(session_id="session-1")

        assert len(escalations) == 2, "Expected len(escalations) to equal 2"
        for esc in escalations:
            assert esc.session_id == "session-1", "Expected esc.session_id to equal 'session-1'"

    def test_list_escalations_filter_by_status(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by status."""
        manager, created = manager_with_multiple_escalations

        # Resolve one
        manager.resolve_escalation(created[0].id, ResolutionType.APPROVED, "OK")

        pending = manager.list_escalations(status=EscalationStatus.PENDING)
        resolved = manager.list_escalations(status=EscalationStatus.RESOLVED)

        assert len(pending) == 2, "Expected len(pending) to equal 2"
        assert len(resolved) == 1, "Expected len(resolved) to equal 1"

    def test_list_escalations_filter_by_priority(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by priority."""
        manager, _ = manager_with_multiple_escalations

        high = manager.list_escalations(priority=EscalationPriority.HIGH)

        assert len(high) == 1, "Expected len(high) to equal 1"
        assert high[0].priority == EscalationPriority.HIGH, "Expected high[0].priority to equal EscalationPriority.HIGH"


class TestGetPendingEscalations:
    """Test getting pending escalations."""

    @pytest.fixture
    def manager_with_mixed_escalations(self):
        """Create manager with pending and resolved escalations."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            pending1 = manager.create_escalation("session-1", "Pending 1", {})
            pending2 = manager.create_escalation("session-2", "Pending 2", {})
            resolved = manager.create_escalation("session-1", "Resolved", {})
            manager.resolve_escalation(resolved.id, ResolutionType.APPROVED, "OK")

            yield manager, [pending1, pending2, resolved]

    def test_get_pending_escalations_returns_only_pending(self, manager_with_mixed_escalations):
        """Test that only pending escalations are returned."""
        manager, _ = manager_with_mixed_escalations

        pending = manager.get_pending_escalations()

        assert len(pending) == 2, "Expected len(pending) to equal 2"
        for esc in pending:
            assert esc.status == EscalationStatus.PENDING, "Expected esc.status to equal EscalationStatus.PENDING"

    def test_get_pending_escalations_filter_by_session(self, manager_with_mixed_escalations):
        """Test filtering pending escalations by session."""
        manager, _ = manager_with_mixed_escalations

        pending = manager.get_pending_escalations(session_id="session-1")

        assert len(pending) == 1, "Expected len(pending) to equal 1"
        assert pending[0].session_id == "session-1", "Expected pending[0].session_id to equal 'session-1'"


class TestCheckTimeouts:
    """Test timeout checking functionality."""

    def test_check_timeouts_expires_old_escalations(self):
        """Test that old escalations are marked as expired."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            # Create escalation with very short timeout
            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0  # Immediate timeout
            )

            # Check timeouts
            expired = manager.check_timeouts()

            assert len(expired) >= 1, "Expected len(expired) >= 1"
            updated = manager.get_escalation(esc.id)
            assert updated.status == EscalationStatus.EXPIRED, "Expected updated.status to equal EscalationStatus.EXPIRED"

    def test_check_timeouts_returns_expired_list(self):
        """Test that expired escalations are returned."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0
            )

            expired = manager.check_timeouts()

            expired_ids = [e.id for e in expired]
            assert esc.id in expired_ids, "Expected esc.id in expired_ids"

    def test_check_timeouts_ignores_non_pending(self):
        """Test that resolved escalations aren't expired."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0
            )
            manager.resolve_escalation(esc.id, ResolutionType.APPROVED, "OK")

            expired = manager.check_timeouts()

            expired_ids = [e.id for e in expired]
            assert esc.id not in expired_ids, "Expected esc.id not in expired_ids"


class TestCancelEscalation:
    """Test escalation cancellation functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_cancel_escalation_returns_true(self, manager_with_escalation):
        """Test cancelling an existing escalation succeeds."""
        manager, escalation = manager_with_escalation

        result = manager.cancel_escalation(escalation.id, "No longer needed")

        assert result is True, "Expected result is True"

    def test_cancel_escalation_updates_status(self, manager_with_escalation):
        """Test that cancellation updates status."""
        manager, escalation = manager_with_escalation

        manager.cancel_escalation(escalation.id, "Cancelled")

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.CANCELLED, "Expected updated.status to equal EscalationStatus.CANCELLED"

    def test_cancel_nonexistent_escalation_returns_false(self, manager_with_escalation):
        """Test cancelling nonexistent escalation fails."""
        manager, _ = manager_with_escalation

        result = manager.cancel_escalation("nonexistent-id", "reason")

        assert result is False, "Expected result is False"

    def test_cancel_resolved_escalation_returns_false(self, manager_with_escalation):
        """Test cancelling already resolved escalation fails."""
        manager, escalation = manager_with_escalation

        manager.resolve_escalation(escalation.id, ResolutionType.APPROVED, "OK")
        result = manager.cancel_escalation(escalation.id, "reason")

        assert result is False, "Expected result is False"


class TestEscalationManagerIntegration:
    """Integration tests for EscalationManager."""

    def test_full_escalation_lifecycle(self):
        """Test complete escalation lifecycle."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            # Create
            esc = manager.create_escalation(
                session_id="session",
                reason="Integration test",
                context={"test": True}
            )
            assert esc.status == EscalationStatus.PENDING, "Expected esc.status to equal EscalationStatus.PENDING"

            # Acknowledge
            manager.acknowledge_escalation(esc.id)
            esc = manager.get_escalation(esc.id)
            assert esc.status == EscalationStatus.ACKNOWLEDGED, "Expected esc.status to equal EscalationStatus.ACKNOWLEDGED"

            # Resolve
            resolution = manager.resolve_escalation(
                esc.id,
                ResolutionType.APPROVED,
                "Test passed"
            )
            assert resolution.resolution_type == ResolutionType.APPROVED, "Expected resolution.resolution_type to equal ResolutionType.APPROVED"

            esc = manager.get_escalation(esc.id)
            assert esc.status == EscalationStatus.RESOLVED, "Expected esc.status to equal EscalationStatus.RESOLVED"

    def test_multiple_sessions_isolation(self):
        """Test that escalations are properly isolated by session."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            for i in range(3):
                for j in range(2):
                    manager.create_escalation(f"session-{i}", f"Esc {j}", {})

            for i in range(3):
                session_escs = manager.list_escalations(session_id=f"session-{i}")
                assert len(session_escs) == 2, "Expected len(session_escs) to equal 2"
