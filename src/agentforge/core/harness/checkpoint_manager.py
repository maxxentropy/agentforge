# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: core-harness-checkpoint_manager
# @test_path: tests/unit/harness/test_checkpoint_manager.py

# Generated by AgentForge
# Spec: recovery_strategies
# Phase: green
# Date: 2025-12-31 06:48:07 UTC

"""Checkpoint manager for state snapshots and rollback capability."""

import json
import shutil
import uuid
from datetime import datetime
from pathlib import Path

from .recovery_domain import Checkpoint


class CheckpointManager:
    """Manages state checkpoints for rollback capability."""

    def __init__(self, storage_path: Path, max_checkpoints: int = 10):
        """Initialize checkpoint manager.

        Args:
            storage_path: Directory for checkpoint storage
            max_checkpoints: Maximum number of checkpoints to keep per session
        """
        self.storage_path = Path(storage_path)
        self.max_checkpoints = max_checkpoints
        self.storage_path.mkdir(parents=True, exist_ok=True)

    def create_checkpoint(
        self,
        session_id: str,
        phase: str,
        state: dict,
        files_to_backup: list[Path] | None = None,
        description: str | None = None
    ) -> Checkpoint:
        """Create a new checkpoint.

        Args:
            session_id: Session identifier
            phase: Workflow phase at checkpoint
            state: Serialized state data
            files_to_backup: Optional files to backup
            description: Optional checkpoint description

        Returns:
            Created checkpoint
        """
        checkpoint_id = str(uuid.uuid4())
        timestamp = datetime.now()

        # Create checkpoint directory
        checkpoint_dir = self.storage_path / session_id / checkpoint_id
        checkpoint_dir.mkdir(parents=True, exist_ok=True)

        # Backup files if specified
        file_backups = []
        if files_to_backup:
            backup_dir = checkpoint_dir / "files"
            backup_dir.mkdir(exist_ok=True)

            for file_path in files_to_backup:
                if file_path.exists():
                    backup_path = backup_dir / file_path.name
                    shutil.copy2(file_path, backup_path)
                    file_backups.append(str(backup_path))

        # Save state data
        state_file = checkpoint_dir / "state.json"
        with open(state_file, 'w') as f:
            json.dump(state, f, indent=2, default=str)

        # Create checkpoint object
        checkpoint = Checkpoint(
            id=checkpoint_id,
            timestamp=timestamp,
            session_id=session_id,
            phase=phase,
            state=state,
            file_backups=file_backups,
            description=description
        )

        # Save checkpoint metadata
        metadata_file = checkpoint_dir / "metadata.json"
        with open(metadata_file, 'w') as f:
            json.dump({
                'id': checkpoint.id,
                'timestamp': checkpoint.timestamp.isoformat(),
                'session_id': checkpoint.session_id,
                'phase': checkpoint.phase,
                'file_backups': checkpoint.file_backups,
                'description': checkpoint.description
            }, f, indent=2)

        # Cleanup old checkpoints
        self.cleanup_old_checkpoints(session_id)

        return checkpoint

    def restore_checkpoint(self, checkpoint_id: str) -> bool:
        """Restore state from a checkpoint.

        Args:
            checkpoint_id: Checkpoint to restore

        Returns:
            True if restoration succeeded
        """
        checkpoint = self.get_checkpoint(checkpoint_id)
        if not checkpoint:
            return False

        checkpoint_dir = self.storage_path / checkpoint.session_id / checkpoint_id
        if not checkpoint_dir.exists():
            return False

        try:
            # Restore backed-up files
            backup_dir = checkpoint_dir / "files"
            if backup_dir.exists():
                for backup_path in backup_dir.iterdir():
                    if backup_path.is_file():
                        # Restore to original location (simplified - assumes same directory)
                        original_path = Path(backup_path.name)
                        shutil.copy2(backup_path, original_path)

            return True
        except Exception:
            return False

    def list_checkpoints(self, session_id: str | None = None) -> list[Checkpoint]:
        """List available checkpoints.

        Args:
            session_id: Optional session filter

        Returns:
            List of checkpoints
        """
        checkpoints = []

        if session_id:
            session_dirs = [self.storage_path / session_id] if (self.storage_path / session_id).exists() else []
        else:
            session_dirs = [d for d in self.storage_path.iterdir() if d.is_dir()]

        for session_dir in session_dirs:
            for checkpoint_dir in session_dir.iterdir():
                if checkpoint_dir.is_dir():
                    checkpoint = self._load_checkpoint(checkpoint_dir)
                    if checkpoint:
                        checkpoints.append(checkpoint)

        # Sort by timestamp, newest first
        checkpoints.sort(key=lambda c: c.timestamp, reverse=True)
        return checkpoints

    def get_checkpoint(self, checkpoint_id: str) -> Checkpoint | None:
        """Get a specific checkpoint.

        Args:
            checkpoint_id: Checkpoint identifier

        Returns:
            Checkpoint if found, None otherwise
        """
        for session_dir in self.storage_path.iterdir():
            if session_dir.is_dir():
                checkpoint_dir = session_dir / checkpoint_id
                if checkpoint_dir.exists():
                    return self._load_checkpoint(checkpoint_dir)
        return None

    def delete_checkpoint(self, checkpoint_id: str) -> bool:
        """Delete a checkpoint.

        Args:
            checkpoint_id: Checkpoint to delete

        Returns:
            True if deletion succeeded
        """
        for session_dir in self.storage_path.iterdir():
            if session_dir.is_dir():
                checkpoint_dir = session_dir / checkpoint_id
                if checkpoint_dir.exists():
                    try:
                        shutil.rmtree(checkpoint_dir)
                        return True
                    except Exception:
                        return False
        return False

    def cleanup_old_checkpoints(self, session_id: str) -> None:
        """Remove checkpoints beyond max limit.

        Keeps most recent max_checkpoints, deletes rest.

        Args:
            session_id: Session to clean up
        """
        checkpoints = self.list_checkpoints(session_id)
        if len(checkpoints) <= self.max_checkpoints:
            return

        # Delete oldest checkpoints
        checkpoints_to_delete = checkpoints[self.max_checkpoints:]
        for checkpoint in checkpoints_to_delete:
            self.delete_checkpoint(checkpoint.id)

    def _load_checkpoint(self, checkpoint_dir: Path) -> Checkpoint | None:
        """Load checkpoint from directory.

        Args:
            checkpoint_dir: Directory containing checkpoint data

        Returns:
            Loaded checkpoint or None if invalid
        """
        try:
            metadata_file = checkpoint_dir / "metadata.json"
            state_file = checkpoint_dir / "state.json"

            if not metadata_file.exists() or not state_file.exists():
                return None

            with open(metadata_file) as f:
                metadata = json.load(f)

            with open(state_file) as f:
                state = json.load(f)

            return Checkpoint(
                id=metadata['id'],
                timestamp=datetime.fromisoformat(metadata['timestamp']),
                session_id=metadata['session_id'],
                phase=metadata['phase'],
                state=state,
                file_backups=metadata.get('file_backups', []),
                description=metadata.get('description')
            )
        except Exception:
            return None
