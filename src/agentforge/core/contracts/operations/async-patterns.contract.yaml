# Operation Contract: Async Patterns
# Governs concurrency, parallelism, and asynchronous programming.
#
# These rules ensure async code is:
# - Safe from race conditions and deadlocks
# - Properly handling cancellation and timeouts
# - Efficient in resource utilization
# - Predictable and debuggable

id: operation.async-patterns.v1
version: "1.0"
description: |
  Patterns for asynchronous programming, concurrency control,
  and parallel execution across languages and frameworks.

rules:
  # ============================================================
  # Async/Await Patterns
  # ============================================================

  - id: async-all-the-way
    description: Async should propagate through the call stack
    check_type: async_pattern
    details:
      principle: |
        Once you go async, stay async. Don't block on async
        code from synchronous code.
      violations:
        python:
          - "asyncio.get_event_loop().run_until_complete()"
          - "loop.run_until_complete() in async context"
        typescript:
          - ".then() mixed with await"
          - "Blocking on Promise in sync function"
        csharp:
          - ".Result or .Wait() on Task"
          - "Task.Run().Result"
      correct_patterns:
        python: "await coroutine()"
        typescript: "await promise"
        csharp: "await Task"
    severity: error
    rationale: |
      Blocking on async code causes deadlocks, thread pool
      starvation, and defeats the purpose of async.

  - id: no-fire-and-forget
    description: Don't start tasks without awaiting or tracking
    check_type: async_pattern
    details:
      violations:
        - calling_async_without_await
        - creating_task_without_storing
        - ignoring_returned_promise
      exceptions:
        - background_services_with_error_handling
        - event_handlers_with_catch
      correct_patterns:
        track_task: |
          task = asyncio.create_task(operation())
          pending_tasks.add(task)
        await_in_finally: |
          try:
              await operation()
          finally:
              cleanup()
    severity: warning
    rationale: |
      Untracked async operations can fail silently and prevent
      graceful shutdown. Always track or await.

  - id: structured-concurrency
    description: Use structured concurrency patterns
    check_type: async_pattern
    details:
      principle: |
        Child tasks should not outlive their parent scope.
        Use task groups or similar constructs.
      patterns:
        python: |
          async with asyncio.TaskGroup() as tg:
              tg.create_task(operation1())
              tg.create_task(operation2())
          # All tasks complete or cancel here
        typescript: |
          await Promise.all([
              operation1(),
              operation2()
          ]);
        csharp: |
          await Task.WhenAll(
              Operation1Async(),
              Operation2Async()
          );
      benefits:
        - automatic_cancellation_propagation
        - clear_task_lifetime
        - predictable_error_handling
    severity: warning
    rationale: |
      Structured concurrency prevents resource leaks and makes
      concurrent code easier to reason about.

  # ============================================================
  # Cancellation
  # ============================================================

  - id: cancellation-support
    description: Async operations should support cancellation
    check_type: async_pattern
    details:
      require:
        - accept_cancellation_token
        - check_cancellation_periodically
        - propagate_to_child_operations
      languages:
        python:
          mechanism: "asyncio.CancelledError"
          pattern: |
            async def operation():
                try:
                    await long_running()
                except asyncio.CancelledError:
                    cleanup()
                    raise
        csharp:
          mechanism: "CancellationToken"
          pattern: |
            async Task OperationAsync(CancellationToken ct)
            {
                ct.ThrowIfCancellationRequested();
                await LongRunningAsync(ct);
            }
        typescript:
          mechanism: "AbortController"
          pattern: |
            async function operation(signal: AbortSignal) {
                if (signal.aborted) throw new AbortError();
                await fetch(url, { signal });
            }
    severity: warning
    rationale: |
      Operations without cancellation support can't be stopped
      gracefully, leading to resource waste and poor UX.

  - id: cancellation-cleanup
    description: Clean up resources when cancelled
    check_type: async_pattern
    details:
      principle: |
        Cancellation is not an error to swallow. Clean up
        and re-raise to propagate cancellation.
      pattern: |
        try:
            resource = await acquire()
            await use(resource)
        except CancelledError:
            logger.info("Operation cancelled")
            raise  # Re-raise after cleanup
        finally:
            await release(resource)
      anti_patterns:
        - catching_cancelled_without_reraise
        - ignoring_cancellation_in_loops
    severity: warning
    rationale: |
      Swallowing cancellation prevents parent scope from
      knowing the operation was cancelled.

  # ============================================================
  # Timeouts
  # ============================================================

  - id: timeout-all-io
    description: All I/O operations should have timeouts
    check_type: async_pattern
    details:
      require_timeout_for:
        - network_requests
        - database_queries
        - file_operations
        - external_service_calls
      patterns:
        python: |
          async with asyncio.timeout(30):
              result = await http_client.get(url)
        typescript: |
          const controller = new AbortController();
          setTimeout(() => controller.abort(), 30000);
          await fetch(url, { signal: controller.signal });
        csharp: |
          using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
          await client.GetAsync(url, cts.Token);
      default_timeouts:
        http_request: "30s"
        database_query: "60s"
        file_read: "10s"
    severity: error
    rationale: |
      Without timeouts, operations can hang forever, consuming
      resources and blocking progress.

  - id: timeout-configuration
    description: Timeouts should be configurable
    check_type: async_pattern
    details:
      principle: |
        Don't hardcode timeouts. Make them configurable
        for different environments.
      pattern: |
        config = Config(
            http_timeout=int(os.getenv("HTTP_TIMEOUT", "30")),
            db_timeout=int(os.getenv("DB_TIMEOUT", "60")),
        )
      layers:
        default: "Sensible code defaults"
        config: "Configuration file overrides"
        environment: "Environment variables for deployment"
    severity: warning
    rationale: |
      Different environments have different latency characteristics.
      Configurable timeouts allow tuning.

  # ============================================================
  # Concurrency Control
  # ============================================================

  - id: limit-concurrency
    description: Limit concurrent operations to prevent overload
    check_type: async_pattern
    details:
      mechanisms:
        semaphore: |
          semaphore = asyncio.Semaphore(10)
          async with semaphore:
              await operation()
        connection_pool: |
          pool = ConnectionPool(max_size=10)
          async with pool.acquire() as conn:
              await conn.execute(query)
        rate_limiter: |
          limiter = RateLimiter(rate=100, per=1.0)
          async with limiter:
              await api_call()
      guidelines:
        http_connections: "10-100 per host"
        database_connections: "pool size = cpu_count * 2"
        parallel_file_ops: "limit based on disk IOPS"
    severity: warning
    rationale: |
      Unbounded concurrency can overwhelm resources, cause
      timeouts, and degrade overall performance.

  - id: avoid-locks-prefer-queues
    description: Prefer message queues over shared state locks
    check_type: async_pattern
    details:
      principle: |
        Instead of locking shared state, use message passing
        or actor patterns where possible.
      prefer:
        - message_queues
        - actor_model
        - immutable_data
        - single_writer_pattern
      when_locks_needed:
        use: "asyncio.Lock not threading.Lock"
        hold_briefly: "Minimize critical section"
        avoid: "Holding locks across await"
      anti_pattern: |
        # BAD: Lock held across await
        async with lock:
            data = await fetch()  # Other tasks blocked!
            await process(data)
      correct_pattern: |
        # GOOD: Fetch outside lock
        data = await fetch()
        async with lock:
            process_sync(data)  # Brief, no await
    severity: warning
    rationale: |
      Locks held across await points block other tasks and
      defeat the purpose of async.

  # ============================================================
  # Error Handling in Async
  # ============================================================

  - id: async-error-propagation
    description: Errors should propagate correctly in async code
    check_type: async_pattern
    details:
      principle: |
        Async errors must be caught at await point or
        they may be lost.
      patterns:
        single_task: |
          try:
              result = await operation()
          except OperationError as e:
              handle_error(e)
        multiple_tasks: |
          results = await asyncio.gather(
              op1(), op2(),
              return_exceptions=True
          )
          for result in results:
              if isinstance(result, Exception):
                  handle_error(result)
      avoid:
        - exception_in_callback_lost
        - gather_without_return_exceptions
        - fire_and_forget_with_errors
    severity: error
    rationale: |
      Lost exceptions make debugging impossible and allow
      silent failures.

  - id: async-context-preservation
    description: Preserve context across async boundaries
    check_type: async_pattern
    details:
      context_to_preserve:
        - request_id
        - trace_id
        - user_identity
        - correlation_id
      mechanisms:
        python: "contextvars.ContextVar"
        typescript: "AsyncLocalStorage"
        csharp: "AsyncLocal<T>"
      pattern: |
        request_id = ContextVar('request_id')

        async def middleware(request, handler):
            token = request_id.set(request.id)
            try:
                return await handler(request)
            finally:
                request_id.reset(token)
    severity: warning
    rationale: |
      Context loss across async calls breaks tracing,
      logging, and request correlation.

  # ============================================================
  # Parallel Execution
  # ============================================================

  - id: parallel-independent-operations
    description: Run independent operations in parallel
    check_type: async_pattern
    details:
      recognize:
        - no_data_dependency
        - no_ordering_requirement
        - independent_resources
      patterns:
        python: |
          # Sequential (slow)
          a = await fetch_a()
          b = await fetch_b()

          # Parallel (fast)
          a, b = await asyncio.gather(fetch_a(), fetch_b())
        typescript: |
          // Parallel
          const [a, b] = await Promise.all([fetchA(), fetchB()]);
      anti_patterns:
        - sequential_independent_awaits
        - serial_api_calls
    severity: warning
    rationale: |
      Sequential awaits for independent operations waste time.
      Parallel execution improves throughput.

  - id: batch-operations
    description: Batch multiple operations when possible
    check_type: async_pattern
    details:
      scenarios:
        database: "Use bulk insert instead of loop"
        api: "Use batch endpoints if available"
        io: "Buffer and flush periodically"
      patterns:
        instead_of: |
          for item in items:
              await db.insert(item)  # N round trips
        use: |
          await db.insert_many(items)  # 1 round trip
      batching_strategies:
        - size_based: "Batch every N items"
        - time_based: "Flush every N seconds"
        - hybrid: "Whichever comes first"
    severity: warning
    rationale: |
      Individual operations have per-call overhead. Batching
      amortizes this overhead across multiple items.

  # ============================================================
  # Resource Management
  # ============================================================

  - id: async-context-managers
    description: Use async context managers for resources
    check_type: async_pattern
    details:
      pattern: |
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()
      ensure:
        - resources_released_on_error
        - resources_released_on_cancel
        - no_resource_leaks
      anti_patterns:
        - manual_acquire_release
        - forgetting_to_close
    severity: warning
    rationale: |
      Context managers ensure cleanup even on exceptions
      or cancellation.

  - id: connection-pooling
    description: Use connection pools for reusable connections
    check_type: async_pattern
    details:
      use_pools_for:
        - database_connections
        - http_sessions
        - websocket_connections
        - grpc_channels
      pool_configuration:
        min_size: "Keep warm connections ready"
        max_size: "Prevent resource exhaustion"
        max_idle_time: "Release unused connections"
        health_check: "Validate before reuse"
      pattern: |
        pool = await create_pool(
            min_size=5,
            max_size=20,
            max_idle_time=300
        )
    severity: warning
    rationale: |
      Connection establishment is expensive. Pools amortize
      this cost and manage connection lifecycle.

escalation_triggers:
  - trigger_id: potential-deadlock
    condition: Lock held across await or blocking in async
    severity: blocking
    prompt: |
      Potential deadlock detected:
      - Review lock usage across await points
      - Consider restructuring to avoid locks
      - Use async-safe synchronization primitives
    rationale: |
      Deadlocks in async code are subtle and cause
      complete system hangs.

  - trigger_id: unbounded-concurrency
    condition: No concurrency limits on parallel operations
    severity: advisory
    prompt: |
      Unbounded concurrent operations detected:
      - Add semaphore or connection pool limits
      - Consider rate limiting for external calls
      - Monitor resource utilization
    rationale: |
      Unbounded concurrency can overwhelm resources
      and cause cascading failures.

  - trigger_id: missing-timeout
    condition: I/O operation without timeout
    severity: advisory
    prompt: |
      I/O operation lacks timeout:
      - Add appropriate timeout wrapper
      - Make timeout configurable
      - Handle timeout as expected error
    rationale: |
      Missing timeouts can cause operations to hang
      indefinitely.

quality_gates:
  - gate_id: async-code-review
    checks:
      - No blocking calls in async context
      - Cancellation properly handled
      - Timeouts on all I/O
      - Concurrency limits in place
      - Resources properly cleaned up
    failure_action: escalate

  - gate_id: async-error-handling-review
    checks:
      - Errors propagate correctly
      - Context preserved across boundaries
      - No silent failures
      - Proper logging of async errors
    failure_action: advisory
