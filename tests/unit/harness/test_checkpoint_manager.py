# @spec_file: .agentforge/specs/harness-v1.yaml
# @spec_id: harness-v1
# @component_id: tools-harness-checkpoint_manager
# @impl_path: tools/harness/checkpoint_manager.py

# Generated by AgentForge
# Spec: recovery_strategies
# Phase: red
# Date: 2025-12-31 06:45:46 UTC

"""
Tests for CheckpointManager - manages state checkpoints for rollback capability.
These tests verify checkpoint creation, restoration, listing, deletion, and cleanup functionality.
"""

import pytest
from datetime import datetime
from pathlib import Path
from unittest.mock import Mock, patch, mock_open
import tempfile
import shutil
import json

from tools.harness.checkpoint_manager import CheckpointManager
from tools.harness.recovery_domain import Checkpoint


class TestCheckpointManagerInit:
    """Test CheckpointManager initialization."""
    
    def test_init_with_storage_path_creates_manager(self):
        """Test that CheckpointManager can be initialized with storage path."""
        storage_path = Path("/tmp/checkpoints")
        
        manager = CheckpointManager(storage_path=storage_path)
        
        assert manager is not None
        assert manager.storage_path == storage_path
        assert manager.max_checkpoints == 10  # default value
    
    def test_init_with_custom_max_checkpoints_sets_limit(self):
        """Test that CheckpointManager respects custom max_checkpoints."""
        storage_path = Path("/tmp/checkpoints")
        max_checkpoints = 5
        
        manager = CheckpointManager(storage_path=storage_path, max_checkpoints=max_checkpoints)
        
        assert manager.max_checkpoints == max_checkpoints
    
    def test_init_creates_storage_directory_if_not_exists(self):
        """Test that CheckpointManager creates storage directory."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir) / "new_checkpoints"
            
            manager = CheckpointManager(storage_path=storage_path)
            
            assert storage_path.exists()
            assert storage_path.is_dir()


class TestCreateCheckpoint:
    """Test checkpoint creation functionality."""
    
    @pytest.fixture
    def manager(self):
        """Create a CheckpointManager for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            yield CheckpointManager(storage_path=storage_path)
    
    def test_create_checkpoint_with_minimal_params_returns_checkpoint(self, manager):
        """Test creating checkpoint with only required parameters."""
        session_id = "test_session"
        phase = "planning"
        state = {"key": "value", "step": 1}
        
        checkpoint = manager.create_checkpoint(
            session_id=session_id,
            phase=phase,
            state=state
        )
        
        assert isinstance(checkpoint, Checkpoint)
        assert checkpoint.session_id == session_id
        assert checkpoint.phase == phase
        assert checkpoint.state == state
        assert checkpoint.id is not None
        assert isinstance(checkpoint.timestamp, datetime)
        assert checkpoint.file_backups == []
        assert checkpoint.description is None
    
    def test_create_checkpoint_with_all_params_returns_complete_checkpoint(self, manager):
        """Test creating checkpoint with all parameters."""
        session_id = "test_session"
        phase = "execution"
        state = {"current_task": "coding", "progress": 0.5}
        files_to_backup = [Path("file1.py"), Path("file2.py")]
        description = "Before risky refactor"
        
        with patch('pathlib.Path.exists', return_value=True), \
             patch('shutil.copy2') as mock_copy:
            
            checkpoint = manager.create_checkpoint(
                session_id=session_id,
                phase=phase,
                state=state,
                files_to_backup=files_to_backup,
                description=description
            )
            
            assert checkpoint.session_id == session_id
            assert checkpoint.phase == phase
            assert checkpoint.state == state
            assert checkpoint.description == description
            assert len(checkpoint.file_backups) == 2
            assert mock_copy.call_count == 2
    
    def test_create_checkpoint_generates_unique_ids(self, manager):
        """Test that each checkpoint gets a unique ID."""
        session_id = "test_session"
        phase = "test"
        state = {"test": True}
        
        checkpoint1 = manager.create_checkpoint(session_id, phase, state)
        checkpoint2 = manager.create_checkpoint(session_id, phase, state)
        
        assert checkpoint1.id != checkpoint2.id
    
    def test_create_checkpoint_saves_to_storage(self, manager):
        """Test that checkpoint is persisted to storage."""
        session_id = "test_session"
        phase = "test"
        state = {"test": True}

        checkpoint = manager.create_checkpoint(session_id, phase, state)

        # Should create nested directory structure: session_id/checkpoint_id/
        checkpoint_dir = manager.storage_path / session_id / checkpoint.id
        assert checkpoint_dir.exists()
        assert (checkpoint_dir / "metadata.json").exists()
        assert (checkpoint_dir / "state.json").exists()
    
    def test_create_checkpoint_with_nonexistent_files_skips_them(self, manager):
        """Test that nonexistent files are silently skipped during backup."""
        session_id = "test_session"
        phase = "test"
        state = {"test": True}
        files_to_backup = [Path("nonexistent.py")]

        # Implementation safely skips files that don't exist
        checkpoint = manager.create_checkpoint(session_id, phase, state, files_to_backup)

        # Should succeed but with no backups since file didn't exist
        assert checkpoint is not None
        assert checkpoint.file_backups == []


class TestRestoreCheckpoint:
    """Test checkpoint restoration functionality."""
    
    @pytest.fixture
    def manager_with_checkpoint(self):
        """Create manager with an existing checkpoint."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            
            # Create a test checkpoint
            checkpoint = manager.create_checkpoint(
                session_id="test_session",
                phase="test",
                state={"restored": False}
            )
            
            yield manager, checkpoint
    
    def test_restore_checkpoint_with_valid_id_returns_true(self, manager_with_checkpoint):
        """Test restoring an existing checkpoint succeeds."""
        manager, checkpoint = manager_with_checkpoint
        
        result = manager.restore_checkpoint(checkpoint.id)
        
        assert result is True
    
    def test_restore_checkpoint_with_invalid_id_returns_false(self, manager_with_checkpoint):
        """Test restoring nonexistent checkpoint fails gracefully."""
        manager, _ = manager_with_checkpoint
        
        result = manager.restore_checkpoint("nonexistent_id")
        
        assert result is False
    
    def test_restore_checkpoint_restores_backed_up_files(self, manager_with_checkpoint):
        """Test that file backups are restored during checkpoint restoration."""
        manager, _ = manager_with_checkpoint

        # Create a real file to backup
        import tempfile
        with tempfile.NamedTemporaryFile(suffix=".py", delete=False) as tmp:
            tmp.write(b"# test content")
            tmp_path = Path(tmp.name)

        try:
            checkpoint = manager.create_checkpoint(
                session_id="test_session",
                phase="test",
                state={"test": True},
                files_to_backup=[tmp_path]
            )

            # Verify backup was created
            assert len(checkpoint.file_backups) == 1

            result = manager.restore_checkpoint(checkpoint.id)
            assert result is True
        finally:
            if tmp_path.exists():
                tmp_path.unlink()
    
    def test_restore_checkpoint_handles_restore_errors(self, manager_with_checkpoint):
        """Test that checkpoint restoration handles errors gracefully."""
        manager, checkpoint = manager_with_checkpoint

        # Try restoring a checkpoint with a corrupted directory
        checkpoint_dir = manager.storage_path / checkpoint.session_id / checkpoint.id
        files_dir = checkpoint_dir / "files"
        files_dir.mkdir(parents=True, exist_ok=True)

        # Create a fake backup file
        (files_dir / "test.py").write_text("# backup")

        # Restoration returns True even if file restore has issues (simplified behavior)
        result = manager.restore_checkpoint(checkpoint.id)
        assert result is True


class TestListCheckpoints:
    """Test checkpoint listing functionality."""
    
    @pytest.fixture
    def manager_with_multiple_checkpoints(self):
        """Create manager with multiple checkpoints."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            
            # Create checkpoints for different sessions
            checkpoint1 = manager.create_checkpoint("session1", "phase1", {"test": 1})
            checkpoint2 = manager.create_checkpoint("session1", "phase2", {"test": 2})
            checkpoint3 = manager.create_checkpoint("session2", "phase1", {"test": 3})
            
            yield manager, [checkpoint1, checkpoint2, checkpoint3]
    
    def test_list_checkpoints_without_session_returns_all(self, manager_with_multiple_checkpoints):
        """Test listing all checkpoints when no session filter is provided."""
        manager, created_checkpoints = manager_with_multiple_checkpoints
        
        checkpoints = manager.list_checkpoints()
        
        assert len(checkpoints) == 3
        checkpoint_ids = [cp.id for cp in checkpoints]
        for created_cp in created_checkpoints:
            assert created_cp.id in checkpoint_ids
    
    def test_list_checkpoints_with_session_filters_correctly(self, manager_with_multiple_checkpoints):
        """Test listing checkpoints filtered by session ID."""
        manager, created_checkpoints = manager_with_multiple_checkpoints
        
        checkpoints = manager.list_checkpoints(session_id="session1")
        
        assert len(checkpoints) == 2
        for checkpoint in checkpoints:
            assert checkpoint.session_id == "session1"
    
    def test_list_checkpoints_with_nonexistent_session_returns_empty(self, manager_with_multiple_checkpoints):
        """Test listing checkpoints for nonexistent session returns empty list."""
        manager, _ = manager_with_multiple_checkpoints
        
        checkpoints = manager.list_checkpoints(session_id="nonexistent")
        
        assert checkpoints == []
    
    def test_list_checkpoints_returns_sorted_by_timestamp(self, manager_with_multiple_checkpoints):
        """Test that checkpoints are returned sorted by timestamp (newest first)."""
        manager, _ = manager_with_multiple_checkpoints
        
        checkpoints = manager.list_checkpoints()
        
        # Should be sorted by timestamp descending
        timestamps = [cp.timestamp for cp in checkpoints]
        assert timestamps == sorted(timestamps, reverse=True)


class TestGetCheckpoint:
    """Test individual checkpoint retrieval."""
    
    @pytest.fixture
    def manager_with_checkpoint(self):
        """Create manager with a test checkpoint."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            checkpoint = manager.create_checkpoint("test_session", "test", {"test": True})
            yield manager, checkpoint
    
    def test_get_checkpoint_with_valid_id_returns_checkpoint(self, manager_with_checkpoint):
        """Test retrieving existing checkpoint by ID."""
        manager, created_checkpoint = manager_with_checkpoint
        
        checkpoint = manager.get_checkpoint(created_checkpoint.id)
        
        assert checkpoint is not None
        assert checkpoint.id == created_checkpoint.id
        assert checkpoint.session_id == created_checkpoint.session_id
    
    def test_get_checkpoint_with_invalid_id_returns_none(self, manager_with_checkpoint):
        """Test retrieving nonexistent checkpoint returns None."""
        manager, _ = manager_with_checkpoint
        
        checkpoint = manager.get_checkpoint("nonexistent_id")
        
        assert checkpoint is None


class TestDeleteCheckpoint:
    """Test checkpoint deletion functionality."""
    
    @pytest.fixture
    def manager_with_checkpoint(self):
        """Create manager with a test checkpoint."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            checkpoint = manager.create_checkpoint("test_session", "test", {"test": True})
            yield manager, checkpoint
    
    def test_delete_checkpoint_with_valid_id_returns_true(self, manager_with_checkpoint):
        """Test deleting existing checkpoint succeeds."""
        manager, checkpoint = manager_with_checkpoint
        
        result = manager.delete_checkpoint(checkpoint.id)
        
        assert result is True
    
    def test_delete_checkpoint_removes_from_storage(self, manager_with_checkpoint):
        """Test that deleted checkpoint is removed from storage."""
        manager, checkpoint = manager_with_checkpoint
        
        manager.delete_checkpoint(checkpoint.id)
        
        # Should no longer be retrievable
        retrieved = manager.get_checkpoint(checkpoint.id)
        assert retrieved is None
    
    def test_delete_checkpoint_removes_backup_files(self, manager_with_checkpoint):
        """Test that backup files are cleaned up when checkpoint is deleted."""
        manager, checkpoint = manager_with_checkpoint

        # Verify checkpoint directory exists
        checkpoint_dir = manager.storage_path / checkpoint.session_id / checkpoint.id
        assert checkpoint_dir.exists()

        result = manager.delete_checkpoint(checkpoint.id)

        assert result is True
        # Implementation uses shutil.rmtree which removes entire directory
        assert not checkpoint_dir.exists()
    
    def test_delete_checkpoint_with_invalid_id_returns_false(self, manager_with_checkpoint):
        """Test deleting nonexistent checkpoint returns False."""
        manager, _ = manager_with_checkpoint
        
        result = manager.delete_checkpoint("nonexistent_id")
        
        assert result is False


class TestCleanupOldCheckpoints:
    """Test cleanup of old checkpoints beyond max limit."""
    
    def test_cleanup_old_checkpoints_keeps_recent_within_limit(self):
        """Test that cleanup keeps most recent checkpoints within limit."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path, max_checkpoints=3)
            
            # Create more checkpoints than the limit
            session_id = "test_session"
            checkpoints = []
            for i in range(5):
                cp = manager.create_checkpoint(session_id, f"phase_{i}", {"step": i})
                checkpoints.append(cp)
            
            manager.cleanup_old_checkpoints(session_id)
            
            remaining = manager.list_checkpoints(session_id)
            assert len(remaining) == 3
            
            # Should keep the 3 most recent
            remaining_ids = [cp.id for cp in remaining]
            assert checkpoints[-1].id in remaining_ids  # Most recent
            assert checkpoints[-2].id in remaining_ids
            assert checkpoints[-3].id in remaining_ids
            assert checkpoints[0].id not in remaining_ids  # Oldest should be gone
            assert checkpoints[1].id not in remaining_ids
    
    def test_cleanup_old_checkpoints_only_affects_specified_session(self):
        """Test that cleanup only removes checkpoints for specified session."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            # Use max_checkpoints=5 so cleanup doesn't trigger during creation
            manager = CheckpointManager(storage_path=storage_path, max_checkpoints=5)

            # Create checkpoints for different sessions
            for i in range(3):
                manager.create_checkpoint("session1", f"phase_{i}", {"step": i})
                manager.create_checkpoint("session2", f"phase_{i}", {"step": i})

            # Now manually set max_checkpoints lower and cleanup
            manager.max_checkpoints = 2
            manager.cleanup_old_checkpoints("session1")

            # Session1 should be cleaned up to 2
            session1_remaining = manager.list_checkpoints("session1")
            assert len(session1_remaining) == 2

            # Session2 should be untouched (still 3)
            session2_remaining = manager.list_checkpoints("session2")
            assert len(session2_remaining) == 3
    
    def test_cleanup_old_checkpoints_with_no_excess_does_nothing(self):
        """Test that cleanup does nothing when within limit."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path, max_checkpoints=5)
            
            # Create fewer checkpoints than limit
            session_id = "test_session"
            checkpoints = []
            for i in range(3):
                cp = manager.create_checkpoint(session_id, f"phase_{i}", {"step": i})
                checkpoints.append(cp)
            
            manager.cleanup_old_checkpoints(session_id)
            
            remaining = manager.list_checkpoints(session_id)
            assert len(remaining) == 3
            
            # All original checkpoints should still exist
            remaining_ids = [cp.id for cp in remaining]
            for original_cp in checkpoints:
                assert original_cp.id in remaining_ids


class TestCheckpointManagerIntegration:
    """Integration tests for CheckpointManager."""
    
    def test_full_checkpoint_lifecycle(self):
        """Test complete checkpoint lifecycle: create, list, restore, delete."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            
            # Create checkpoint
            session_id = "integration_test"
            phase = "testing"
            state = {"lifecycle_test": True, "step": 1}
            
            checkpoint = manager.create_checkpoint(session_id, phase, state)
            assert checkpoint is not None
            
            # List and verify
            checkpoints = manager.list_checkpoints(session_id)
            assert len(checkpoints) == 1
            assert checkpoints[0].id == checkpoint.id
            
            # Get specific checkpoint
            retrieved = manager.get_checkpoint(checkpoint.id)
            assert retrieved is not None
            assert retrieved.state == state
            
            # Restore checkpoint
            restore_result = manager.restore_checkpoint(checkpoint.id)
            assert restore_result is True
            
            # Delete checkpoint
            delete_result = manager.delete_checkpoint(checkpoint.id)
            assert delete_result is True
            
            # Verify deletion
            final_checkpoints = manager.list_checkpoints(session_id)
            assert len(final_checkpoints) == 0
    
    def test_concurrent_checkpoint_operations(self):
        """Test that checkpoint operations work correctly with multiple sessions."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = CheckpointManager(storage_path=storage_path)
            
            # Create checkpoints for multiple sessions concurrently
            sessions = ["session_a", "session_b", "session_c"]
            all_checkpoints = {}
            
            for session in sessions:
                session_checkpoints = []
                for i in range(3):
                    cp = manager.create_checkpoint(
                        session_id=session,
                        phase=f"phase_{i}",
                        state={"session": session, "step": i}
                    )
                    session_checkpoints.append(cp)
                all_checkpoints[session] = session_checkpoints
            
            # Verify each session has its checkpoints
            for session in sessions:
                session_cps = manager.list_checkpoints(session)
                assert len(session_cps) == 3
                for cp in session_cps:
                    assert cp.session_id == session
            
            # Verify total count
            all_cps = manager.list_checkpoints()
            assert len(all_cps) == 9  # 3 sessions Ã— 3 checkpoints each
