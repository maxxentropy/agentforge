# Operation Contract: Error Handling
# Governs error handling patterns and exception management.
#
# These rules ensure errors are:
# - Handled consistently across the codebase
# - Informative for debugging
# - Appropriate for the caller's context
# - Not swallowed or hidden

id: operation.error-handling.v1
version: "1.0"
description: |
  Comprehensive error handling patterns covering exceptions,
  Result types, validation, and error propagation strategies.

rules:
  # ============================================================
  # Exception Design
  # ============================================================

  - id: custom-exception-hierarchy
    description: Design meaningful exception hierarchies
    check_type: exception_design
    details:
      structure:
        base_exception:
          name: "{Module}Error"
          inherits: Exception
          purpose: "Base for all module exceptions"
        specific_exceptions:
          pattern: "{Specific}Error"
          inherits: base_exception
          examples:
            - ValidationError
            - NotFoundError
            - AuthorizationError
            - ConfigurationError
      include:
        - error_code
        - message
        - context_dict
        - original_exception
      example: |
        class ServiceError(Exception):
            def __init__(self, message, code=None, context=None, cause=None):
                super().__init__(message)
                self.code = code
                self.context = context or {}
                self.__cause__ = cause
    severity: warning
    rationale: |
      Custom exceptions allow specific handling. Generic exceptions
      force callers to parse messages or catch too broadly.

  - id: exception-information
    description: Exceptions must carry diagnostic information
    check_type: exception_design
    details:
      required:
        - descriptive_message
        - relevant_context
      recommended:
        - error_code
        - documentation_link
        - suggested_action
      avoid:
        - empty_message
        - generic_message
        - exposing_internals
      examples:
        bad: |
          raise ValueError("Error")
        good: |
          raise UserNotFoundError(
              f"User '{user_id}' not found in organization '{org_id}'",
              code="USER_NOT_FOUND",
              context={"user_id": user_id, "org_id": org_id}
          )
    severity: warning
    rationale: |
      Good error messages accelerate debugging. Include what
      happened, what was expected, and relevant identifiers.

  # ============================================================
  # Exception Handling
  # ============================================================

  - id: catch-specific-exceptions
    description: Catch specific exceptions, not generic ones
    check_type: exception_handling
    details:
      avoid:
        - bare_except
        - catch_exception_base
        - catch_all_reraise
      prefer:
        - specific_exception_types
        - exception_hierarchies
      allowed_generic_catch:
        - top_level_handlers
        - thread_boundaries
        - with_logging_and_reraise
      examples:
        bad: |
          try:
              operation()
          except Exception:
              pass
        good: |
          try:
              operation()
          except ValidationError as e:
              handle_validation(e)
          except NotFoundError as e:
              handle_not_found(e)
    severity: error
    rationale: |
      Generic catches hide bugs. Different errors need
      different handling strategies.

  - id: no-swallowed-exceptions
    description: Never silently swallow exceptions
    check_type: exception_handling
    details:
      violations:
        - empty_except_block
        - except_pass
        - catch_without_action
      acceptable:
        - log_and_continue
        - return_default
        - raise_different
      require:
        - logging_in_catch
        - or_reraise
        - or_convert_to_result
      examples:
        bad: |
          try:
              risky_operation()
          except Exception:
              pass  # Silent failure!
        good: |
          try:
              risky_operation()
          except OperationError as e:
              logger.warning(f"Operation failed, using default: {e}")
              return default_value
    severity: error
    rationale: |
      Swallowed exceptions hide bugs and make debugging
      extremely difficult. Always handle or propagate.

  - id: exception-translation
    description: Translate exceptions at layer boundaries
    check_type: exception_handling
    details:
      pattern:
        infrastructure_to_domain:
          catch: [SqlException, HttpException, IOError]
          raise: [RepositoryError, ServiceError, StorageError]
        domain_to_api:
          catch: [DomainError, ValidationError]
          raise: [HttpError, ApiError]
      preserve:
        - original_exception_as_cause
        - relevant_context
        - stack_trace
      example: |
        try:
            result = db.execute(query)
        except SqlException as e:
            raise RepositoryError(
                f"Failed to query users: {e}",
                cause=e
            ) from e
    severity: warning
    rationale: |
      Higher layers shouldn't know about lower layer
      implementation details. Translate to appropriate abstraction.

  # ============================================================
  # Result Pattern
  # ============================================================

  - id: result-pattern
    description: Use Result types for expected failures
    check_type: error_pattern
    details:
      when_to_use:
        - validation_errors
        - business_rule_violations
        - expected_failure_conditions
        - operations_that_commonly_fail
      when_not_to_use:
        - programming_errors
        - infrastructure_failures
        - unrecoverable_conditions
      structure:
        success: "Result.ok(value)"
        failure: "Result.error(error)"
        check: "result.is_success / result.is_failure"
        access: "result.value / result.error"
      example: |
        def validate_email(email: str) -> Result[Email, ValidationError]:
            if not is_valid_format(email):
                return Result.error(ValidationError("Invalid email format"))
            return Result.ok(Email(email))
    severity: warning
    rationale: |
      Result types make failure handling explicit in the type
      system. Callers can't ignore potential failures.

  - id: result-not-exception-mixing
    description: Don't mix Result and exceptions for same concerns
    check_type: error_pattern
    details:
      principle: |
        Within a module, consistently use either Result or exceptions
        for handling the same category of errors.
      guidelines:
        expected_failures: use_result
        unexpected_failures: use_exceptions
        validation: use_result
        infrastructure_errors: use_exceptions
      anti_pattern: |
        # BAD: Sometimes Result, sometimes exception
        def process(data):
            if not valid(data):
                return Result.error("Invalid")  # Result
            try:
                save(data)
            except DbError:
                raise ProcessingError()  # Exception
    severity: warning
    rationale: |
      Mixing patterns confuses callers. Consistency makes
      error handling predictable.

  # ============================================================
  # Validation Patterns
  # ============================================================

  - id: fail-fast-validation
    description: Validate inputs early, fail fast
    check_type: validation_pattern
    details:
      validate_at:
        - function_entry
        - layer_boundaries
        - before_expensive_operations
      validation_order:
        1: required_fields
        2: type_correctness
        3: format_validation
        4: business_rules
      pattern: |
        def process_order(order: Order) -> Result:
            # Validate at entry
            validation = validate_order(order)
            if validation.is_failure:
                return validation

            # Proceed with valid data
            ...
    severity: warning
    rationale: |
      Early validation prevents wasted work and makes errors
      easier to diagnose. Don't validate deep in the call stack.

  - id: accumulate-validation-errors
    description: Collect all validation errors, not just first
    check_type: validation_pattern
    details:
      pattern:
        collect_all: true
        return_format: "list[ValidationError]"
      example: |
        def validate_user(user: UserInput) -> list[ValidationError]:
            errors = []
            if not user.name:
                errors.append(ValidationError("name", "Name is required"))
            if not is_valid_email(user.email):
                errors.append(ValidationError("email", "Invalid email format"))
            if user.age and user.age < 0:
                errors.append(ValidationError("age", "Age must be positive"))
            return errors
      anti_pattern: |
        # BAD: Only returns first error
        if not user.name:
            raise ValidationError("Name is required")
        if not user.email:
            raise ValidationError("Email is required")
    severity: warning
    rationale: |
      Returning all errors at once improves user experience.
      Users can fix all issues in one pass.

  # ============================================================
  # Error Propagation
  # ============================================================

  - id: dont-catch-to-rethrow-same
    description: Don't catch just to rethrow the same exception
    check_type: exception_handling
    details:
      bad_pattern: |
        try:
            operation()
        except SomeError:
            raise  # Pointless catch
      acceptable:
        - catch_log_reraise
        - catch_wrap_reraise
        - catch_cleanup_reraise
      example: |
        # Acceptable: logging before reraise
        try:
            operation()
        except OperationError as e:
            logger.error(f"Operation failed: {e}")
            raise
    severity: warning
    rationale: |
      Catching just to rethrow adds noise. Only catch if
      you're adding value (logging, wrapping, cleanup).

  - id: preserve-stack-trace
    description: Preserve original stack trace when wrapping exceptions
    check_type: exception_handling
    details:
      languages:
        python:
          correct: "raise NewError(...) from original_error"
          wrong: "raise NewError(...)"
        csharp:
          correct: "throw new NewException(..., innerException)"
          wrong: "throw new NewException(...)"
        typescript:
          correct: "throw new NewError(..., { cause: original })"
          wrong: "throw new NewError(...)"
      example: |
        try:
            external_call()
        except ExternalError as e:
            raise InternalError("External service failed") from e
    severity: error
    rationale: |
      Lost stack traces make debugging nearly impossible.
      Always chain exceptions to preserve the full trace.

  # ============================================================
  # Cleanup and Resources
  # ============================================================

  - id: cleanup-in-finally
    description: Use finally or context managers for cleanup
    check_type: resource_handling
    details:
      prefer:
        - context_managers
        - finally_blocks
        - disposable_pattern
      avoid:
        - cleanup_only_in_try
        - cleanup_only_in_except
      examples:
        python: |
          with open(file) as f:
              process(f)
          # or
          try:
              resource = acquire()
              use(resource)
          finally:
              resource.release()
    severity: warning
    rationale: |
      Cleanup in try or except may not run on all paths.
      finally/with guarantees cleanup regardless of outcome.

  - id: resource-acquisition
    description: Acquire resources late, release early
    check_type: resource_handling
    details:
      principles:
        - acquire_just_before_use
        - release_immediately_after
        - minimize_hold_time
        - use_scoped_resources
      anti_patterns:
        - acquire_at_function_start
        - release_only_at_function_end
        - holding_during_user_input
    severity: warning
    rationale: |
      Holding resources longer than needed leads to contention
      and resource exhaustion. Minimize the window.

escalation_triggers:
  - trigger_id: swallowed-exception
    condition: Exception caught with no handling
    severity: blocking
    prompt: |
      Exception is being swallowed:
      - Add logging at minimum
      - Consider if retry is appropriate
      - Propagate if can't handle
    rationale: |
      Swallowed exceptions hide bugs and make systems
      behave unpredictably.

  - trigger_id: generic-exception-catch
    condition: Catching Exception or BaseException
    severity: advisory
    prompt: |
      Generic exception catch detected:
      - Identify specific exceptions to catch
      - Add logging if truly catching all
      - Ensure reraise after handling
    rationale: |
      Generic catches hide bugs. Be specific about
      what errors you expect and can handle.

  - trigger_id: exception-without-context
    condition: Exception raised without diagnostic information
    severity: advisory
    prompt: |
      Exception lacks context for debugging:
      - Add descriptive message
      - Include relevant identifiers
      - Consider adding error code
    rationale: |
      Good error messages accelerate debugging.
      Include what, why, and relevant context.

quality_gates:
  - gate_id: error-handling-review
    checks:
      - Custom exceptions used appropriately
      - No swallowed exceptions
      - Specific exceptions caught
      - Stack traces preserved
      - Validation fails fast
    failure_action: escalate

  - gate_id: resource-handling-review
    checks:
      - Cleanup in finally/with
      - Resources released promptly
      - No resource leaks in error paths
    failure_action: advisory
