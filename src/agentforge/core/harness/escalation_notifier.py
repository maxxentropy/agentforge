# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: core-harness-escalation_notifier
# @test_path: tests/unit/harness/test_escalation_notifier.py

# Generated by AgentForge
# Spec: human_escalation
# Phase: green
# Date: 2025-12-31

"""Escalation notifier for sending notifications through configured channels."""

import json
from datetime import datetime
from pathlib import Path
from typing import Optional

from .escalation_domain import (
    EscalationPriority,
    EscalationChannel,
    Escalation
)


class EscalationNotifier:
    """Sends notifications through configured channels."""

    # ANSI color codes for priorities
    PRIORITY_COLORS = {
        EscalationPriority.LOW: "\033[32m",      # Green
        EscalationPriority.MEDIUM: "\033[33m",   # Yellow
        EscalationPriority.HIGH: "\033[91m",     # Light red
        EscalationPriority.CRITICAL: "\033[31m"  # Red
    }
    RESET_COLOR = "\033[0m"

    def __init__(
        self,
        channels: list[EscalationChannel],
        config: Optional[dict] = None
    ):
        """Initialize notifier with channels and config.

        Args:
            channels: Active notification channels
            config: Channel-specific configuration
        """
        self.channels = channels
        self.config = config or {}

    def notify(self, escalation: Escalation) -> dict:
        """Send notification for an escalation.

        Args:
            escalation: Escalation to notify about

        Returns:
            Dict mapping channel to success/failure
        """
        results = {}

        for channel in self.channels:
            try:
                if channel == EscalationChannel.CLI:
                    results[channel] = self.notify_cli(escalation)
                elif channel == EscalationChannel.FILE:
                    results[channel] = self.notify_file(escalation)
                elif channel == EscalationChannel.WEBHOOK:
                    webhook_url = self.config.get("webhook_url")
                    results[channel] = self.notify_webhook(escalation, webhook_url)
                elif channel == EscalationChannel.EMAIL:
                    # Email not implemented yet
                    results[channel] = False
                else:
                    results[channel] = False
            except Exception:
                results[channel] = False

        return results

    def notify_cli(self, escalation: Escalation) -> bool:
        """Display escalation in CLI.

        Args:
            escalation: Escalation to display

        Returns:
            True if display succeeded
        """
        try:
            color = self.get_priority_color(escalation.priority)
            reset = self.RESET_COLOR

            print(f"\n{color}{'='*60}{reset}")
            print(f"{color}ESCALATION [{escalation.priority.name}]{reset}")
            print(f"{'='*60}")
            print(f"ID: {escalation.id}")
            print(f"Session: {escalation.session_id}")
            print(f"Time: {escalation.created_at.isoformat()}")
            print(f"\n{color}Reason:{reset} {escalation.reason}")

            if escalation.recommended_actions:
                print(f"\n{color}Recommended Actions:{reset}")
                for i, action in enumerate(escalation.recommended_actions, 1):
                    print(f"  {i}. {action}")

            if escalation.context:
                print(f"\n{color}Context:{reset}")
                for key, value in escalation.context.items():
                    print(f"  {key}: {value}")

            print(f"{'='*60}\n")
            return True
        except Exception:
            return False

    def notify_file(
        self,
        escalation: Escalation,
        file_path: Optional[Path] = None
    ) -> bool:
        """Write escalation to file.

        Args:
            escalation: Escalation to write
            file_path: Optional file path

        Returns:
            True if write succeeded
        """
        try:
            if file_path is None:
                base_path = self.config.get("file_path_base", ".agentforge/escalations")
                file_path = Path(base_path) / f"{escalation.id}.json"

            file_path = Path(file_path)
            file_path.parent.mkdir(parents=True, exist_ok=True)

            data = self._escalation_to_dict(escalation)

            with open(file_path, 'w') as f:
                json.dump(data, f, indent=2, default=str)

            return True
        except Exception:
            return False

    def notify_webhook(
        self,
        escalation: Escalation,
        webhook_url: Optional[str] = None
    ) -> bool:
        """Send escalation via webhook.

        Args:
            escalation: Escalation to send
            webhook_url: Optional webhook URL

        Returns:
            True if POST succeeded
        """
        try:
            import requests

            url = webhook_url or self.config.get("webhook_url")
            if not url:
                return False

            data = self._escalation_to_dict(escalation)
            response = requests.post(url, json=data, timeout=10)

            return response.status_code == 200
        except Exception:
            return False

    def format_escalation(
        self,
        escalation: Escalation,
        format: str = "text"
    ) -> str:
        """Format escalation for display.

        Args:
            escalation: Escalation to format
            format: Output format ("text", "json", "markdown")

        Returns:
            Formatted string
        """
        if format == "json":
            data = self._escalation_to_dict(escalation)
            return json.dumps(data, indent=2, default=str)

        elif format == "markdown":
            lines = [
                f"# Escalation: {escalation.id}",
                "",
                f"**Priority:** {escalation.priority.name}",
                f"**Status:** {escalation.status.name}",
                f"**Session:** {escalation.session_id}",
                f"**Created:** {escalation.created_at.isoformat()}",
                "",
                "## Reason",
                escalation.reason,
            ]

            if escalation.recommended_actions:
                lines.extend(["", "## Recommended Actions"])
                for action in escalation.recommended_actions:
                    lines.append(f"- {action}")

            if escalation.context:
                lines.extend(["", "## Context", "```json"])
                lines.append(json.dumps(escalation.context, indent=2))
                lines.append("```")

            return "\n".join(lines)

        else:  # text format (default)
            lines = [
                f"Escalation: {escalation.id}",
                f"Priority: {escalation.priority.name}",
                f"Status: {escalation.status.name}",
                f"Session: {escalation.session_id}",
                f"Created: {escalation.created_at.isoformat()}",
                f"Reason: {escalation.reason}",
            ]

            if escalation.recommended_actions:
                lines.append("Recommended Actions:")
                for i, action in enumerate(escalation.recommended_actions, 1):
                    lines.append(f"  {i}. {action}")

            return "\n".join(lines)

    def get_priority_color(self, priority: EscalationPriority) -> str:
        """Get ANSI color code for priority.

        Args:
            priority: Priority level

        Returns:
            ANSI color escape code
        """
        return self.PRIORITY_COLORS.get(priority, "")

    def _escalation_to_dict(self, escalation: Escalation) -> dict:
        """Convert escalation to dict for serialization."""
        return {
            "id": escalation.id,
            "session_id": escalation.session_id,
            "created_at": escalation.created_at.isoformat(),
            "priority": escalation.priority.name,
            "status": escalation.status.name,
            "reason": escalation.reason,
            "context": escalation.context,
            "recommended_actions": escalation.recommended_actions,
            "timeout_seconds": escalation.timeout_seconds,
            "acknowledged_at": escalation.acknowledged_at.isoformat() if escalation.acknowledged_at else None,
            "resolved_at": escalation.resolved_at.isoformat() if escalation.resolved_at else None
        }
