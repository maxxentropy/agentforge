# @spec_file: .agentforge/specs/generate-v1.yaml
# @spec_id: generate-v1
# @component_id: tools-generate-domain
# @test_path: tests/unit/tools/test_builtin_checks_architecture.py

"""
LLM Generation Domain Model
===========================

Core domain entities for LLM-powered code generation.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional


class GenerationPhase(Enum):
    """Phases of code generation in TDD workflow."""

    RED = "red"  # Generate failing tests
    GREEN = "green"  # Generate passing implementation
    REFACTOR = "refactor"  # Improve without changing behavior


class GenerationMode(Enum):
    """Mode of code generation."""

    FULL = "full"  # Generate complete implementation
    INCREMENTAL = "incremental"  # Add to existing code
    FIX = "fix"  # Fix failing tests or errors


class FileAction(Enum):
    """Action to take on a generated file."""

    CREATE = "create"  # New file
    MODIFY = "modify"  # Update existing
    DELETE = "delete"  # Remove file


# =============================================================================
# Exceptions
# =============================================================================


class GenerationError(Exception):
    """Base exception for generation errors."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.message = message
        self.details = details or {}


class APIError(GenerationError):
    """Error from LLM API call."""

    def __init__(
        self,
        message: str,
        status_code: Optional[int] = None,
        response: Optional[str] = None,
        retryable: bool = True,
    ):
        super().__init__(message, {"status_code": status_code, "response": response})
        self.status_code = status_code
        self.response = response
        self.retryable = retryable


class ParseError(GenerationError):
    """Error parsing LLM response."""

    def __init__(
        self,
        message: str,
        raw_response: Optional[str] = None,
        position: Optional[int] = None,
    ):
        super().__init__(message, {"raw_response": raw_response, "position": position})
        self.raw_response = raw_response
        self.position = position


class WriteError(GenerationError):
    """Error writing generated files."""

    def __init__(
        self,
        message: str,
        path: Optional[Path] = None,
        original_error: Optional[Exception] = None,
    ):
        super().__init__(message, {"path": str(path) if path else None})
        self.path = path
        self.original_error = original_error


# =============================================================================
# Value Objects
# =============================================================================


@dataclass(frozen=True)
class TokenUsage:
    """Token usage statistics from LLM call."""

    prompt_tokens: int
    completion_tokens: int

    @property
    def total_tokens(self) -> int:
        """Total tokens used."""
        return self.prompt_tokens + self.completion_tokens

    @property
    def cost_estimate(self) -> float:
        """Estimated cost in USD (Claude Sonnet pricing)."""
        # Claude Sonnet: $3/1M input, $15/1M output
        input_cost = (self.prompt_tokens / 1_000_000) * 3.0
        output_cost = (self.completion_tokens / 1_000_000) * 15.0
        return input_cost + output_cost


# =============================================================================
# Entities
# =============================================================================


@dataclass
class GeneratedFile:
    """A file generated by the LLM."""

    path: Path
    content: str
    action: FileAction = FileAction.CREATE
    original_content: Optional[str] = None

    def __post_init__(self):
        """Ensure path is a Path object."""
        if isinstance(self.path, str):
            self.path = Path(self.path)

    @property
    def is_new(self) -> bool:
        """True if this is a new file."""
        return self.action == FileAction.CREATE

    @property
    def is_modification(self) -> bool:
        """True if modifying existing file."""
        return self.action == FileAction.MODIFY

    @property
    def line_count(self) -> int:
        """Number of lines in content."""
        return len(self.content.splitlines())

    def diff_summary(self) -> str:
        """Summary of changes if this is a modification."""
        if not self.is_modification or not self.original_content:
            return f"New file: {self.line_count} lines"

        original_lines = len(self.original_content.splitlines())
        new_lines = self.line_count
        diff = new_lines - original_lines
        sign = "+" if diff >= 0 else ""
        return f"Modified: {original_lines} â†’ {new_lines} lines ({sign}{diff})"


@dataclass
class GenerationContext:
    """Context for code generation request."""

    spec: Dict[str, Any]
    phase: GenerationPhase
    mode: GenerationMode = GenerationMode.FULL
    component_name: Optional[str] = None
    patterns: Dict[str, Any] = field(default_factory=dict)
    examples: List[Dict[str, Any]] = field(default_factory=list)
    error_context: Optional[Dict[str, Any]] = None
    existing_tests: Optional[str] = None
    existing_impl: Optional[str] = None

    @classmethod
    def for_red(
        cls,
        spec: Dict[str, Any],
        component_name: Optional[str] = None,
        patterns: Optional[Dict[str, Any]] = None,
        examples: Optional[List[Dict[str, Any]]] = None,
    ) -> "GenerationContext":
        """Create context for RED phase (test generation)."""
        return cls(
            spec=spec,
            phase=GenerationPhase.RED,
            mode=GenerationMode.FULL,
            component_name=component_name,
            patterns=patterns or {},
            examples=examples or [],
        )

    @classmethod
    def for_green(
        cls,
        spec: Dict[str, Any],
        existing_tests: str,
        component_name: Optional[str] = None,
        patterns: Optional[Dict[str, Any]] = None,
        examples: Optional[List[Dict[str, Any]]] = None,
    ) -> "GenerationContext":
        """Create context for GREEN phase (implementation)."""
        return cls(
            spec=spec,
            phase=GenerationPhase.GREEN,
            mode=GenerationMode.FULL,
            component_name=component_name,
            patterns=patterns or {},
            examples=examples or [],
            existing_tests=existing_tests,
        )

    @classmethod
    def for_fix(
        cls,
        spec: Dict[str, Any],
        error_context: Dict[str, Any],
        existing_tests: Optional[str] = None,
        existing_impl: Optional[str] = None,
    ) -> "GenerationContext":
        """Create context for FIX mode (error recovery)."""
        return cls(
            spec=spec,
            phase=GenerationPhase.GREEN,
            mode=GenerationMode.FIX,
            error_context=error_context,
            existing_tests=existing_tests,
            existing_impl=existing_impl,
        )

    @classmethod
    def for_refactor(
        cls,
        spec: Dict[str, Any],
        existing_impl: str,
        existing_tests: Optional[str] = None,
        patterns: Optional[Dict[str, Any]] = None,
    ) -> "GenerationContext":
        """Create context for REFACTOR phase (code improvement)."""
        return cls(
            spec=spec,
            phase=GenerationPhase.REFACTOR,
            mode=GenerationMode.INCREMENTAL,
            patterns=patterns or {},
            existing_tests=existing_tests,
            existing_impl=existing_impl,
        )


@dataclass
class GenerationResult:
    """Result of a code generation request."""

    success: bool
    files: List[GeneratedFile] = field(default_factory=list)
    explanation: str = ""
    model: str = ""
    token_usage: Optional[TokenUsage] = None
    error: Optional[str] = None
    raw_response: Optional[str] = None
    duration_seconds: float = 0.0
    timestamp: datetime = field(default_factory=datetime.utcnow)

    @property
    def tokens_used(self) -> int:
        """Total tokens used."""
        return self.token_usage.total_tokens if self.token_usage else 0

    @property
    def prompt_tokens(self) -> int:
        """Prompt tokens used."""
        return self.token_usage.prompt_tokens if self.token_usage else 0

    @property
    def completion_tokens(self) -> int:
        """Completion tokens used."""
        return self.token_usage.completion_tokens if self.token_usage else 0

    @property
    def file_count(self) -> int:
        """Number of files generated."""
        return len(self.files)

    @property
    def total_lines(self) -> int:
        """Total lines across all generated files."""
        return sum(f.line_count for f in self.files)

    @classmethod
    def failure(
        cls,
        error: str,
        raw_response: Optional[str] = None,
        duration_seconds: float = 0.0,
    ) -> "GenerationResult":
        """Create a failure result."""
        return cls(
            success=False,
            error=error,
            raw_response=raw_response,
            duration_seconds=duration_seconds,
        )

    @classmethod
    def success_result(
        cls,
        files: List[GeneratedFile],
        explanation: str,
        model: str,
        token_usage: TokenUsage,
        duration_seconds: float,
        raw_response: Optional[str] = None,
    ) -> "GenerationResult":
        """Create a success result."""
        return cls(
            success=True,
            files=files,
            explanation=explanation,
            model=model,
            token_usage=token_usage,
            duration_seconds=duration_seconds,
            raw_response=raw_response,
        )

    def summary(self) -> str:
        """Human-readable summary of the result."""
        if not self.success:
            return f"Generation failed: {self.error}"

        file_summary = ", ".join(str(f.path) for f in self.files[:3])
        if len(self.files) > 3:
            file_summary += f", ... ({len(self.files)} total)"

        return (
            f"Generated {self.file_count} files ({self.total_lines} lines) "
            f"using {self.tokens_used} tokens in {self.duration_seconds:.1f}s: "
            f"{file_summary}"
        )
