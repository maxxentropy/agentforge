# Generated by AgentForge
# Spec: agent_orchestrator
# Phase: green
# Date: 2025-12-31

"""Main orchestrator coordinating all Agent Harness components."""

import time
from datetime import datetime
from typing import Optional

from .orchestrator_domain import (
    OrchestratorState,
    ExecutionMode,
    ExecutionResult,
    OrchestratorConfig
)
from .session_domain import SessionState, SessionContext
from .monitor_domain import HealthStatus
from .recovery_domain import RecoveryAttempt
from .escalation_domain import EscalationResolution, ResolutionType


class AgentOrchestrator:
    """Main orchestrator coordinating all Agent Harness components."""

    def __init__(
        self,
        session_manager,
        memory_store,
        tool_selector,
        agent_monitor,
        recovery_executor,
        escalation_manager,
        config: Optional[OrchestratorConfig] = None
    ):
        """Initialize orchestrator with all components.

        Args:
            session_manager: Manages agent sessions
            memory_store: Handles memory storage and retrieval
            tool_selector: Selects tools for execution
            agent_monitor: Monitors agent health
            recovery_executor: Executes recovery strategies
            escalation_manager: Manages human escalations
            config: Orchestrator configuration
        """
        self.session_manager = session_manager
        self.memory_store = memory_store
        self.tool_selector = tool_selector
        self.agent_monitor = agent_monitor
        self.recovery_executor = recovery_executor
        self.escalation_manager = escalation_manager
        self.config = config or OrchestratorConfig()

        # Track session states
        self._session_states: dict[str, OrchestratorState] = {}
        self._session_iterations: dict[str, int] = {}
        self._session_history: dict[str, list[ExecutionResult]] = {}

    def start_session(
        self,
        task_description: str,
        context: Optional[dict] = None,
        execution_mode: Optional[ExecutionMode] = None
    ) -> str:
        """Initialize a new agent session.

        Args:
            task_description: Description of the task
            context: Optional context data
            execution_mode: Optional execution mode override

        Returns:
            Session ID
        """
        # Create session
        session = self.session_manager.create_session(
            metadata={
                "task_description": task_description,
                "context": context or {},
                "execution_mode": (execution_mode or self.config.execution_mode).name
            }
        )

        session_id = session.id

        # Initialize tracking
        self._session_states[session_id] = OrchestratorState.IDLE
        self._session_iterations[session_id] = 0
        self._session_history[session_id] = []

        # Store initial context in memory
        if context:
            self.memory_store.store(
                key=f"session:{session_id}:context",
                value=context,
                metadata={"type": "initial_context"}
            )

        return session_id

    def resume_session(self, session_id: str) -> bool:
        """Resume a paused session.

        Args:
            session_id: Session to resume

        Returns:
            True if successful
        """
        session = self.session_manager.get_session(session_id)
        if not session:
            return False

        # Update state
        self._session_states[session_id] = OrchestratorState.RUNNING

        # Restore iteration count if not tracked
        if session_id not in self._session_iterations:
            self._session_iterations[session_id] = session.metadata.get("iteration", 0)

        if session_id not in self._session_history:
            self._session_history[session_id] = []

        return True

    def execute_step(
        self,
        session_id: str,
        input_data: Optional[dict] = None
    ) -> ExecutionResult:
        """Execute one iteration of agent work.

        Args:
            session_id: Session to execute in
            input_data: Optional input for this step

        Returns:
            Execution result
        """
        start_time = time.time()
        self._session_states[session_id] = OrchestratorState.RUNNING

        # Check for pending escalations
        pending = self.escalation_manager.get_pending_escalations(session_id)
        if pending:
            self._session_states[session_id] = OrchestratorState.WAITING_FOR_HUMAN
            return ExecutionResult(
                task_id=f"{session_id}:step:{self._session_iterations[session_id]}",
                success=False,
                output=None,
                error="Waiting for escalation resolution",
                duration_seconds=time.time() - start_time,
                tools_used=[]
            )

        # Get available tools
        tools = self.get_available_tools(session_id)

        # Increment iteration
        self._session_iterations[session_id] = self._session_iterations.get(session_id, 0) + 1
        iteration = self._session_iterations[session_id]

        # Record observation (simulated step execution)
        self.agent_monitor.record_observation(
            observation_type="step_execution",
            details={
                "session_id": session_id,
                "iteration": iteration,
                "tools_available": tools,
                "input_data": input_data
            }
        )

        # Check health at intervals
        if iteration % self.config.health_check_interval == 0:
            recovery = self.handle_health_check(session_id)
            if recovery and recovery.result.name == "FAILED":
                self._session_states[session_id] = OrchestratorState.FAILED
                return ExecutionResult(
                    task_id=f"{session_id}:step:{iteration}",
                    success=False,
                    output=None,
                    error="Recovery failed",
                    duration_seconds=time.time() - start_time,
                    tools_used=[]
                )

        # Create checkpoint at intervals
        if self.config.auto_checkpoint and iteration % self.config.checkpoint_interval == 0:
            self._create_checkpoint(session_id)

        duration = time.time() - start_time

        result = ExecutionResult(
            task_id=f"{session_id}:step:{iteration}",
            success=True,
            output=f"Step {iteration} completed",
            error=None,
            duration_seconds=duration,
            tools_used=tools[:2] if tools else []  # Simulate tool usage
        )

        # Store in history
        self._session_history.setdefault(session_id, []).append(result)

        return result

    def run_until_complete(
        self,
        session_id: str,
        max_iterations: Optional[int] = None
    ) -> ExecutionResult:
        """Run agent until task completion or limit.

        Args:
            session_id: Session to run
            max_iterations: Optional iteration limit override

        Returns:
            Final execution result
        """
        limit = max_iterations or self.config.max_iterations
        last_result = None

        for _ in range(limit):
            result = self.execute_step(session_id)
            last_result = result

            # Check for blocking states
            state = self._session_states.get(session_id, OrchestratorState.IDLE)
            if state in [OrchestratorState.WAITING_FOR_HUMAN, OrchestratorState.PAUSED,
                        OrchestratorState.FAILED, OrchestratorState.COMPLETED]:
                break

            if not result.success:
                break

        return last_result or ExecutionResult(
            task_id=f"{session_id}:final",
            success=False,
            output=None,
            error="No iterations executed",
            duration_seconds=0.0,
            tools_used=[]
        )

    def pause_session(self, session_id: str, reason: str) -> bool:
        """Pause agent execution.

        Args:
            session_id: Session to pause
            reason: Reason for pausing

        Returns:
            True if successful
        """
        session = self.session_manager.get_session(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.PAUSED

        # Update session
        session.state = SessionState.PAUSED
        session.metadata["pause_reason"] = reason
        session.metadata["paused_at"] = datetime.now().isoformat()
        self.session_manager.update_session(session)

        return True

    def get_status(self, session_id: str) -> dict:
        """Get current orchestrator status.

        Args:
            session_id: Session to get status for

        Returns:
            Status dictionary
        """
        session = self.session_manager.get_session(session_id)

        # Get health
        health = self.agent_monitor.get_health(session_id)

        # Get pending escalations
        pending = self.escalation_manager.get_pending_escalations(session_id)

        state = self._session_states.get(session_id, OrchestratorState.IDLE)

        return {
            "state": state.name,
            "iteration_count": self._session_iterations.get(session_id, 0),
            "health_status": health,
            "pending_escalations": len(pending),
            "last_checkpoint_id": session.metadata.get("last_checkpoint_id") if session else None
        }

    def get_available_tools(self, session_id: str) -> list[str]:
        """Get tools available for current session.

        Args:
            session_id: Session to get tools for

        Returns:
            List of tool names
        """
        session = self.session_manager.get_session(session_id)
        phase = session.metadata.get("phase", "default") if session else "default"

        return self.tool_selector.get_tool_names(phase=phase)

    def handle_health_check(self, session_id: str) -> Optional[RecoveryAttempt]:
        """Check health and trigger recovery if needed.

        Args:
            session_id: Session to check

        Returns:
            Recovery attempt if triggered, None otherwise
        """
        if not self.config.recovery_enabled:
            return None

        health = self.agent_monitor.get_health(session_id)

        if health.status == HealthStatus.HEALTHY:
            return None

        # Has issues, trigger recovery
        self._session_states[session_id] = OrchestratorState.RECOVERING

        session = self.session_manager.get_session(session_id)
        current_state = session.metadata if session else {}

        attempt = self.recovery_executor.execute_recovery(
            health=health,
            session_id=session_id,
            current_state=current_state
        )

        self._session_states[session_id] = OrchestratorState.RUNNING

        return attempt

    def handle_escalation(
        self,
        session_id: str,
        resolution: EscalationResolution
    ) -> bool:
        """Process pending escalation.

        Args:
            session_id: Session with escalation
            resolution: Human's resolution

        Returns:
            True if successful
        """
        session = self.session_manager.get_session(session_id)
        if not session:
            return False

        # Apply resolution
        if resolution.resolution_type == ResolutionType.APPROVED:
            self._session_states[session_id] = OrchestratorState.RUNNING
        elif resolution.resolution_type == ResolutionType.REJECTED:
            self._session_states[session_id] = OrchestratorState.FAILED
        elif resolution.resolution_type == ResolutionType.DEFERRED:
            self._session_states[session_id] = OrchestratorState.PAUSED
        else:
            self._session_states[session_id] = OrchestratorState.RUNNING

        # Update session
        session.metadata["last_resolution"] = {
            "type": resolution.resolution_type.name,
            "decision": resolution.decision,
            "resolved_at": resolution.resolved_at.isoformat()
        }
        self.session_manager.update_session(session)

        return True

    def complete_session(
        self,
        session_id: str,
        result: ExecutionResult
    ) -> bool:
        """Mark session as completed.

        Args:
            session_id: Session to complete
            result: Final execution result

        Returns:
            True if successful
        """
        session = self.session_manager.get_session(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.COMPLETED

        session.state = SessionState.COMPLETED
        session.metadata["completed_at"] = datetime.now().isoformat()
        session.metadata["final_result"] = {
            "success": result.success,
            "output": result.output,
            "duration_seconds": result.duration_seconds
        }
        self.session_manager.update_session(session)

        return True

    def fail_session(self, session_id: str, error: str) -> bool:
        """Mark session as failed.

        Args:
            session_id: Session to fail
            error: Error message

        Returns:
            True if successful
        """
        session = self.session_manager.get_session(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.FAILED

        session.state = SessionState.ABORTED
        session.metadata["failed_at"] = datetime.now().isoformat()
        session.metadata["error"] = error
        self.session_manager.update_session(session)

        return True

    def get_session_history(self, session_id: str) -> list[ExecutionResult]:
        """Get execution history for session.

        Args:
            session_id: Session to get history for

        Returns:
            List of execution results
        """
        return self._session_history.get(session_id, [])

    def cleanup(self, max_age_days: int = 30) -> int:
        """Clean up old sessions and checkpoints.

        Args:
            max_age_days: Maximum age of items to keep

        Returns:
            Count of cleaned items
        """
        return self.session_manager.cleanup_sessions(max_age_days=max_age_days)

    def _create_checkpoint(self, session_id: str) -> None:
        """Create a checkpoint for the session."""
        session = self.session_manager.get_session(session_id)
        if not session:
            return

        try:
            checkpoint = self.recovery_executor.checkpoint(
                session_id=session_id,
                phase=session.metadata.get("phase", "unknown"),
                state=session.metadata,
                files=None
            )
            if checkpoint.details:
                session.metadata["last_checkpoint_id"] = checkpoint.details.get("checkpoint_id")
                self.session_manager.update_session(session)
        except Exception:
            pass  # Checkpoint failure shouldn't break execution
