# Generated by AgentForge
# Spec: agent_orchestrator
# Phase: green (updated to match real APIs)
# Date: 2025-12-31

"""
Tests for AgentOrchestrator - main orchestrator coordinating all components.
These tests verify orchestration of sessions, tool execution, monitoring,
recovery, and escalation handling.

Updated to use actual component APIs:
- SessionManager: create(), load(), save(), pause(), resume(), complete(), abort()
- AgentMonitor: observe_action(), get_health(original_task, tokens_used, token_budget)
- ToolSelector: get_tool_names(workflow, phase, domain)
"""

import pytest
from datetime import datetime
from pathlib import Path
from unittest.mock import Mock, MagicMock, patch
import tempfile

from tools.harness.agent_orchestrator import AgentOrchestrator
from tools.harness.orchestrator_domain import (
    OrchestratorState,
    ExecutionMode,
    AgentTask,
    ExecutionResult,
    OrchestratorConfig
)
from tools.harness.session_domain import SessionContext, SessionState, TokenBudget
from tools.harness.monitor_domain import AgentHealth, HealthStatus, Recommendation
from tools.harness.recovery_domain import RecoveryAttempt, RecoveryAction, RecoveryResult
from tools.harness.escalation_domain import (
    Escalation, EscalationStatus, EscalationPriority,
    EscalationResolution, ResolutionType
)


def create_mock_session(
    session_id: str = "session-001",
    state: SessionState = SessionState.ACTIVE,
    workflow_type: str = "agent",
    current_phase: str = "execute",
    tokens_used: int = 0,
    total_budget: int = 100000
) -> Mock:
    """Create a mock SessionContext with correct structure."""
    mock_session = Mock(spec=SessionContext)
    mock_session.session_id = session_id
    mock_session.state = state
    mock_session.workflow_type = workflow_type
    mock_session.current_phase = current_phase
    mock_session.created_at = datetime.now()
    mock_session.updated_at = datetime.now()

    # Token budget with proper structure
    mock_token_budget = Mock(spec=TokenBudget)
    mock_token_budget.tokens_used = tokens_used
    mock_token_budget.total_budget = total_budget
    mock_token_budget.tokens_remaining = total_budget - tokens_used
    mock_session.token_budget = mock_token_budget

    return mock_session


class TestAgentOrchestratorInit:
    """Test AgentOrchestrator initialization."""

    def test_init_with_all_components(self):
        """Test initialization with all required components."""
        session_manager = Mock()
        memory_manager = Mock()
        tool_selector = Mock()
        agent_monitor = Mock()
        recovery_executor = Mock()
        escalation_manager = Mock()

        orchestrator = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=memory_manager,
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=recovery_executor,
            escalation_manager=escalation_manager
        )

        assert orchestrator.session_manager == session_manager
        assert orchestrator.memory_manager == memory_manager
        assert orchestrator.tool_selector == tool_selector
        assert orchestrator.agent_monitor == agent_monitor
        assert orchestrator.recovery_executor == recovery_executor
        assert orchestrator.escalation_manager == escalation_manager

    def test_init_with_default_config(self):
        """Test initialization creates default config."""
        orchestrator = AgentOrchestrator(
            session_manager=Mock(),
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

        assert orchestrator.config is not None
        assert orchestrator.config.execution_mode == ExecutionMode.AUTONOMOUS

    def test_init_with_custom_config(self):
        """Test initialization with custom config."""
        config = OrchestratorConfig(
            execution_mode=ExecutionMode.SUPERVISED,
            max_iterations=50
        )

        orchestrator = AgentOrchestrator(
            session_manager=Mock(),
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock(),
            config=config
        )

        assert orchestrator.config.execution_mode == ExecutionMode.SUPERVISED
        assert orchestrator.config.max_iterations == 50


class TestStartSession:
    """Test session start functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.create.return_value = mock_session

        memory_manager = Mock()
        memory_manager.set = Mock()

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=memory_manager,
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_start_session_returns_session_id(self, orchestrator):
        """Test that start_session returns a session ID."""
        session_id = orchestrator.start_session(
            task_description="Implement feature",
            context={"file": "main.py"}
        )

        assert session_id is not None
        assert isinstance(session_id, str)
        assert session_id == "session-001"

    def test_start_session_calls_create(self, orchestrator):
        """Test that start_session creates session via manager."""
        orchestrator.start_session(
            task_description="Test task",
            context={},
            workflow_type="spec",
            initial_phase="intake",
            token_budget=50000
        )

        orchestrator.session_manager.create.assert_called_once_with(
            workflow_type="spec",
            initial_phase="intake",
            token_budget=50000
        )

    def test_start_session_with_execution_mode(self, orchestrator):
        """Test starting session with specific execution mode."""
        session_id = orchestrator.start_session(
            task_description="Interactive task",
            execution_mode=ExecutionMode.INTERACTIVE
        )

        assert session_id is not None

    def test_start_session_stores_context_in_memory(self, orchestrator):
        """Test that start_session stores context in memory manager."""
        orchestrator.start_session(
            task_description="Task with context",
            context={"key": "value"}
        )

        # Memory manager's set should be called with context
        orchestrator.memory_manager.set.assert_called()

    def test_start_session_saves_session(self, orchestrator):
        """Test that start_session saves the session."""
        orchestrator.start_session(
            task_description="Test task"
        )

        orchestrator.session_manager.save.assert_called_once()


class TestResumeSession:
    """Test session resume functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session(state=SessionState.PAUSED)
        session_manager.load.return_value = mock_session

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_resume_session_returns_true_on_success(self, orchestrator):
        """Test that resume_session returns True for valid session."""
        result = orchestrator.resume_session("session-001")

        assert result is True

    def test_resume_session_returns_false_for_nonexistent(self, orchestrator):
        """Test resume_session returns False for nonexistent session."""
        orchestrator.session_manager.load.return_value = None

        result = orchestrator.resume_session("nonexistent")

        assert result is False

    def test_resume_session_loads_session(self, orchestrator):
        """Test that resume_session loads session state."""
        orchestrator.resume_session("session-001")

        orchestrator.session_manager.load.assert_called_with("session-001")

    def test_resume_session_calls_session_manager_resume(self, orchestrator):
        """Test that resume_session calls session manager's resume."""
        orchestrator.resume_session("session-001")

        orchestrator.session_manager.resume.assert_called_once()


class TestExecuteStep:
    """Test single execution step functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read_file", "write_file"]

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

        # Initialize session tracking by calling start_session first
        session_manager.create.return_value = mock_session
        orch.start_session("Test task")

        return orch

    def test_execute_step_returns_execution_result(self, orchestrator):
        """Test that execute_step returns an ExecutionResult."""
        result = orchestrator.execute_step("session-001")

        assert isinstance(result, ExecutionResult)

    def test_execute_step_checks_for_escalations(self, orchestrator):
        """Test that execute_step checks for pending escalations."""
        orchestrator.execute_step("session-001")

        orchestrator.escalation_manager.get_pending_escalations.assert_called()

    def test_execute_step_calls_observe_action(self, orchestrator):
        """Test that execute_step records observation via observe_action."""
        orchestrator.execute_step("session-001")

        orchestrator.agent_monitor.observe_action.assert_called()

    def test_execute_step_with_input_data(self, orchestrator):
        """Test execute_step with additional input data."""
        result = orchestrator.execute_step(
            "session-001",
            input_data={"user_input": "continue"}
        )

        assert result is not None


class TestRunUntilComplete:
    """Test run until completion functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read_file", "write_file"]

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager,
            config=OrchestratorConfig(max_iterations=5)
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_run_until_complete_returns_result(self, orchestrator):
        """Test that run_until_complete returns final result."""
        result = orchestrator.run_until_complete("session-001")

        assert isinstance(result, ExecutionResult)

    def test_run_until_complete_respects_max_iterations(self, orchestrator):
        """Test that execution stops at max iterations."""
        result = orchestrator.run_until_complete(
            "session-001",
            max_iterations=3
        )

        assert result is not None

    def test_run_until_complete_uses_config_max(self, orchestrator):
        """Test that run_until_complete uses config max_iterations."""
        result = orchestrator.run_until_complete("session-001")

        # Should respect config.max_iterations = 5
        assert result is not None


class TestPauseSession:
    """Test session pause functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

        # Initialize session tracking
        orch.start_session("Test task")

        return orch

    def test_pause_session_returns_true(self, orchestrator):
        """Test that pause_session returns True on success."""
        result = orchestrator.pause_session("session-001", "User requested")

        assert result is True

    def test_pause_session_calls_session_manager_pause(self, orchestrator):
        """Test that pause_session calls session manager's pause method."""
        orchestrator.pause_session("session-001", "Maintenance")

        orchestrator.session_manager.pause.assert_called_once()

    def test_pause_session_returns_false_for_nonexistent(self, orchestrator):
        """Test pause_session returns False for nonexistent session."""
        orchestrator.session_manager.load.return_value = None

        result = orchestrator.pause_session("nonexistent", "reason")

        assert result is False


class TestGetStatus:
    """Test status retrieval functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session(tokens_used=5000, total_budget=100000)
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_get_status_returns_dict(self, orchestrator):
        """Test that get_status returns a status dict."""
        status = orchestrator.get_status("session-001")

        assert isinstance(status, dict)

    def test_get_status_includes_state(self, orchestrator):
        """Test that status includes orchestrator state."""
        status = orchestrator.get_status("session-001")

        assert "state" in status

    def test_get_status_includes_iteration_count(self, orchestrator):
        """Test that status includes iteration count."""
        status = orchestrator.get_status("session-001")

        assert "iteration_count" in status

    def test_get_status_includes_health(self, orchestrator):
        """Test that status includes health status."""
        status = orchestrator.get_status("session-001")

        assert "health_status" in status

    def test_get_status_includes_pending_escalations(self, orchestrator):
        """Test that status includes pending escalation count."""
        status = orchestrator.get_status("session-001")

        assert "pending_escalations" in status

    def test_get_status_calls_get_health_with_context(self, orchestrator):
        """Test that get_status calls get_health with proper parameters."""
        orchestrator.get_status("session-001")

        orchestrator.agent_monitor.get_health.assert_called_with(
            original_task="Test task",
            tokens_used=5000,
            token_budget=100000
        )


class TestGetAvailableTools:
    """Test tool availability functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read", "write", "search"]

        session_manager = Mock()
        mock_session = create_mock_session(
            workflow_type="tdflow",
            current_phase="red"
        )
        session_manager.load.return_value = mock_session

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=tool_selector,
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_get_available_tools_returns_list(self, orchestrator):
        """Test that get_available_tools returns a list."""
        tools = orchestrator.get_available_tools("session-001")

        assert isinstance(tools, list)

    def test_get_available_tools_uses_tool_selector(self, orchestrator):
        """Test that tool selector is used."""
        tools = orchestrator.get_available_tools("session-001")

        assert "read" in tools
        assert "write" in tools

    def test_get_available_tools_passes_workflow_and_phase(self, orchestrator):
        """Test that get_tool_names is called with workflow, phase, domain."""
        orchestrator.get_available_tools("session-001")

        orchestrator.tool_selector.get_tool_names.assert_called_once_with(
            workflow="tdflow",
            phase="red",
            domain=None
        )


class TestHandleHealthCheck:
    """Test health check handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        agent_monitor = Mock()
        recovery_executor = Mock()

        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=agent_monitor,
            recovery_executor=recovery_executor,
            escalation_manager=Mock()
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_handle_health_check_returns_none_when_healthy(self, orchestrator):
        """Test that no recovery is triggered when healthy."""
        orchestrator.agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        result = orchestrator.handle_health_check("session-001")

        assert result is None

    def test_handle_health_check_triggers_recovery_when_unhealthy(self, orchestrator):
        """Test that recovery is triggered when issues detected."""
        orchestrator.agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.DEGRADED,
            issues=["Loop detected"],
            recommendation=Recommendation.ESCALATE
        )
        orchestrator.recovery_executor.execute_recovery.return_value = RecoveryAttempt(
            action=RecoveryAction.CHECKPOINT,
            timestamp=datetime.now(),
            trigger="Loop detected",
            result=RecoveryResult.SUCCESS
        )

        result = orchestrator.handle_health_check("session-001")

        assert result is not None
        orchestrator.recovery_executor.execute_recovery.assert_called()


class TestHandleEscalation:
    """Test escalation handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        escalation_manager = Mock()

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=escalation_manager
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_handle_escalation_returns_true_on_success(self, orchestrator):
        """Test that handle_escalation returns True on success."""
        resolution = EscalationResolution(
            escalation_id="esc-001",
            resolution_type=ResolutionType.APPROVED,
            decision="Continue",
            resolved_at=datetime.now()
        )

        result = orchestrator.handle_escalation("session-001", resolution)

        assert result is True

    def test_handle_escalation_returns_false_for_nonexistent_session(self, orchestrator):
        """Test handle_escalation returns False for nonexistent session."""
        orchestrator.session_manager.load.return_value = None

        resolution = EscalationResolution(
            escalation_id="esc-001",
            resolution_type=ResolutionType.APPROVED,
            decision="Proceed",
            resolved_at=datetime.now()
        )

        result = orchestrator.handle_escalation("nonexistent", resolution)

        assert result is False


class TestCompleteSession:
    """Test session completion functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_complete_session_returns_true(self, orchestrator):
        """Test that complete_session returns True on success."""
        result = ExecutionResult(
            task_id="task-001",
            success=True,
            output="Done",
            error=None,
            duration_seconds=10.0,
            tools_used=[]
        )

        success = orchestrator.complete_session("session-001", result)

        assert success is True

    def test_complete_session_calls_session_manager_complete(self, orchestrator):
        """Test that complete_session calls session manager's complete method."""
        result = ExecutionResult(
            task_id="task-001",
            success=True,
            output="Complete",
            error=None,
            duration_seconds=5.0,
            tools_used=[]
        )

        orchestrator.complete_session("session-001", result)

        orchestrator.session_manager.complete.assert_called_once()


class TestFailSession:
    """Test session failure handling functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        orch = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

        # Initialize session
        orch.start_session("Test task")

        return orch

    def test_fail_session_returns_true(self, orchestrator):
        """Test that fail_session returns True on success."""
        success = orchestrator.fail_session("session-001", "Unrecoverable error")

        assert success is True

    def test_fail_session_calls_session_manager_abort(self, orchestrator):
        """Test that fail_session calls session manager's abort method."""
        orchestrator.fail_session("session-001", "Fatal error")

        orchestrator.session_manager.abort.assert_called_once_with(reason="Fatal error")


class TestGetSessionHistory:
    """Test session history retrieval functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        mock_session = create_mock_session()
        session_manager.load.return_value = mock_session
        session_manager.create.return_value = mock_session

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_get_session_history_returns_list(self, orchestrator):
        """Test that get_session_history returns a list."""
        history = orchestrator.get_session_history("session-001")

        assert isinstance(history, list)


class TestCleanup:
    """Test cleanup functionality."""

    @pytest.fixture
    def orchestrator(self):
        """Create orchestrator with mocked components."""
        session_manager = Mock()
        session_manager.cleanup_old_sessions.return_value = 5

        return AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=Mock(),
            agent_monitor=Mock(),
            recovery_executor=Mock(),
            escalation_manager=Mock()
        )

    def test_cleanup_returns_count(self, orchestrator):
        """Test that cleanup returns count of cleaned items."""
        count = orchestrator.cleanup(max_age_days=30)

        assert isinstance(count, int)
        assert count == 5

    def test_cleanup_uses_session_manager_cleanup_old_sessions(self, orchestrator):
        """Test that cleanup uses session manager's cleanup_old_sessions."""
        orchestrator.cleanup(max_age_days=7)

        orchestrator.session_manager.cleanup_old_sessions.assert_called_once_with(
            days=7,
            dry_run=False
        )


class TestOrchestratorIntegration:
    """Integration tests for AgentOrchestrator."""

    def test_full_session_lifecycle(self):
        """Test complete session lifecycle."""
        # Setup mocks
        mock_session = create_mock_session()

        session_manager = Mock()
        session_manager.create.return_value = mock_session
        session_manager.load.return_value = mock_session

        agent_monitor = Mock()
        agent_monitor.get_health.return_value = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE
        )

        escalation_manager = Mock()
        escalation_manager.get_pending_escalations.return_value = []

        tool_selector = Mock()
        tool_selector.get_tool_names.return_value = ["read", "write", "search"]

        orchestrator = AgentOrchestrator(
            session_manager=session_manager,
            memory_manager=Mock(),
            tool_selector=tool_selector,
            agent_monitor=agent_monitor,
            recovery_executor=Mock(),
            escalation_manager=escalation_manager,
            config=OrchestratorConfig(max_iterations=3)
        )

        # Start session
        session_id = orchestrator.start_session("Test task", {})
        assert session_id is not None
        assert session_id == "session-001"

        # Execute step
        result = orchestrator.execute_step(session_id)
        assert isinstance(result, ExecutionResult)

        # Get status
        status = orchestrator.get_status(session_id)
        assert "state" in status

        # Complete session
        success = orchestrator.complete_session(session_id, result)
        assert success is True
        session_manager.complete.assert_called_once()
