# Generated by AgentForge
# Spec: agent_monitor
# Phase: red
# Date: 2025-12-31 05:32:37 UTC

"""
Tests for monitor domain entities.
These tests verify the structure and behavior of domain objects used for agent monitoring.
"""

import pytest
from datetime import datetime
from typing import Optional

from tools.harness.monitor_domain import (
    ObservationType,
    Observation,
    HealthStatus,
    Recommendation,
    LoopDetection,
    ThrashingDetection,
    AgentHealth
)


class TestObservationType:
    """Test ObservationType enum values and behavior."""
    
    def test_observation_type_has_all_required_values(self):
        """Test that ObservationType enum contains all specified values."""
        expected_values = {'ACTION', 'OUTPUT', 'VERIFICATION', 'STATE_CHANGE', 'ERROR'}
        actual_values = {item.name for item in ObservationType}
        assert actual_values == expected_values
    
    def test_observation_type_action_value(self):
        """Test that ACTION value exists and is accessible."""
        assert ObservationType.ACTION is not None
        assert ObservationType.ACTION.name == 'ACTION'
    
    def test_observation_type_output_value(self):
        """Test that OUTPUT value exists and is accessible."""
        assert ObservationType.OUTPUT is not None
        assert ObservationType.OUTPUT.name == 'OUTPUT'
    
    def test_observation_type_verification_value(self):
        """Test that VERIFICATION value exists and is accessible."""
        assert ObservationType.VERIFICATION is not None
        assert ObservationType.VERIFICATION.name == 'VERIFICATION'
    
    def test_observation_type_state_change_value(self):
        """Test that STATE_CHANGE value exists and is accessible."""
        assert ObservationType.STATE_CHANGE is not None
        assert ObservationType.STATE_CHANGE.name == 'STATE_CHANGE'
    
    def test_observation_type_error_value(self):
        """Test that ERROR value exists and is accessible."""
        assert ObservationType.ERROR is not None
        assert ObservationType.ERROR.name == 'ERROR'


class TestObservation:
    """Test Observation entity structure and behavior."""
    
    def test_observation_creation_with_required_fields(self):
        """Test creating observation with type, timestamp, and data."""
        timestamp = datetime.now()
        data = {"action": "test_action", "details": "test details"}
        
        observation = Observation(
            type=ObservationType.ACTION,
            timestamp=timestamp,
            data=data
        )
        
        assert observation.type == ObservationType.ACTION
        assert observation.timestamp == timestamp
        assert observation.data == data
        assert observation.context is None
    
    def test_observation_creation_with_optional_context(self):
        """Test creating observation with optional context field."""
        timestamp = datetime.now()
        data = {"error": "test error"}
        context = "During file processing"
        
        observation = Observation(
            type=ObservationType.ERROR,
            timestamp=timestamp,
            data=data,
            context=context
        )
        
        assert observation.type == ObservationType.ERROR
        assert observation.timestamp == timestamp
        assert observation.data == data
        assert observation.context == context
    
    def test_observation_data_field_accepts_dict(self):
        """Test that observation data field accepts dictionary."""
        data = {
            "file_path": "/test/path.py",
            "lines_changed": 5,
            "operation": "modify"
        }
        
        observation = Observation(
            type=ObservationType.OUTPUT,
            timestamp=datetime.now(),
            data=data
        )
        
        assert observation.data == data
        assert isinstance(observation.data, dict)
    
    def test_observation_context_is_optional_string(self):
        """Test that context field is optional and accepts string or None."""
        # Test with None
        obs1 = Observation(
            type=ObservationType.VERIFICATION,
            timestamp=datetime.now(),
            data={"passed": True}
        )
        assert obs1.context is None
        
        # Test with string
        obs2 = Observation(
            type=ObservationType.VERIFICATION,
            timestamp=datetime.now(),
            data={"passed": False},
            context="Unit test execution"
        )
        assert obs2.context == "Unit test execution"


class TestHealthStatus:
    """Test HealthStatus enum values and behavior."""
    
    def test_health_status_has_all_required_values(self):
        """Test that HealthStatus enum contains all specified values."""
        expected_values = {'HEALTHY', 'DEGRADED', 'CRITICAL'}
        actual_values = {item.name for item in HealthStatus}
        assert actual_values == expected_values
    
    def test_health_status_healthy_value(self):
        """Test that HEALTHY value exists and is accessible."""
        assert HealthStatus.HEALTHY is not None
        assert HealthStatus.HEALTHY.name == 'HEALTHY'
    
    def test_health_status_degraded_value(self):
        """Test that DEGRADED value exists and is accessible."""
        assert HealthStatus.DEGRADED is not None
        assert HealthStatus.DEGRADED.name == 'DEGRADED'
    
    def test_health_status_critical_value(self):
        """Test that CRITICAL value exists and is accessible."""
        assert HealthStatus.CRITICAL is not None
        assert HealthStatus.CRITICAL.name == 'CRITICAL'


class TestRecommendation:
    """Test Recommendation enum values and behavior."""
    
    def test_recommendation_has_all_required_values(self):
        """Test that Recommendation enum contains all specified values."""
        expected_values = {'CONTINUE', 'CHECKPOINT', 'ESCALATE', 'ABORT'}
        actual_values = {item.name for item in Recommendation}
        assert actual_values == expected_values
    
    def test_recommendation_continue_value(self):
        """Test that CONTINUE value exists and is accessible."""
        assert Recommendation.CONTINUE is not None
        assert Recommendation.CONTINUE.name == 'CONTINUE'
    
    def test_recommendation_checkpoint_value(self):
        """Test that CHECKPOINT value exists and is accessible."""
        assert Recommendation.CHECKPOINT is not None
        assert Recommendation.CHECKPOINT.name == 'CHECKPOINT'
    
    def test_recommendation_escalate_value(self):
        """Test that ESCALATE value exists and is accessible."""
        assert Recommendation.ESCALATE is not None
        assert Recommendation.ESCALATE.name == 'ESCALATE'
    
    def test_recommendation_abort_value(self):
        """Test that ABORT value exists and is accessible."""
        assert Recommendation.ABORT is not None
        assert Recommendation.ABORT.name == 'ABORT'


class TestLoopDetection:
    """Test LoopDetection entity structure and behavior."""
    
    def test_loop_detection_creation_with_no_loop(self):
        """Test creating LoopDetection when no loop is detected."""
        loop_detection = LoopDetection(
            detected=False,
            pattern=None,
            count=0,
            observations=[]
        )
        
        assert loop_detection.detected is False
        assert loop_detection.pattern is None
        assert loop_detection.count == 0
        assert loop_detection.observations == []
    
    def test_loop_detection_creation_with_detected_loop(self):
        """Test creating LoopDetection when loop is detected."""
        observations = [
            Observation(ObservationType.ACTION, datetime.now(), {"action": "test"}),
            Observation(ObservationType.ACTION, datetime.now(), {"action": "test"}),
            Observation(ObservationType.ACTION, datetime.now(), {"action": "test"})
        ]
        
        loop_detection = LoopDetection(
            detected=True,
            pattern="Repeated action: test",
            count=3,
            observations=observations
        )
        
        assert loop_detection.detected is True
        assert loop_detection.pattern == "Repeated action: test"
        assert loop_detection.count == 3
        assert len(loop_detection.observations) == 3
    
    def test_loop_detection_pattern_is_optional(self):
        """Test that pattern field is optional and can be None."""
        loop_detection = LoopDetection(
            detected=True,
            pattern=None,
            count=2,
            observations=[]
        )
        
        assert loop_detection.pattern is None
    
    def test_loop_detection_observations_list_type(self):
        """Test that observations field accepts list of Observation objects."""
        obs1 = Observation(ObservationType.ERROR, datetime.now(), {"error": "test"})
        obs2 = Observation(ObservationType.ERROR, datetime.now(), {"error": "test"})
        
        loop_detection = LoopDetection(
            detected=True,
            pattern="Repeated error",
            count=2,
            observations=[obs1, obs2]
        )
        
        assert isinstance(loop_detection.observations, list)
        assert len(loop_detection.observations) == 2
        assert all(isinstance(obs, Observation) for obs in loop_detection.observations)


class TestThrashingDetection:
    """Test ThrashingDetection entity structure and behavior."""
    
    def test_thrashing_detection_creation_with_no_thrashing(self):
        """Test creating ThrashingDetection when no thrashing is detected."""
        thrashing_detection = ThrashingDetection(
            detected=False,
            pattern=None,
            affected_files=[],
            alternation_count=0
        )
        
        assert thrashing_detection.detected is False
        assert thrashing_detection.pattern is None
        assert thrashing_detection.affected_files == []
        assert thrashing_detection.alternation_count == 0
    
    def test_thrashing_detection_creation_with_detected_thrashing(self):
        """Test creating ThrashingDetection when thrashing is detected."""
        affected_files = ["/path/to/file1.py", "/path/to/file2.py"]
        
        thrashing_detection = ThrashingDetection(
            detected=True,
            pattern="Alternating file modifications",
            affected_files=affected_files,
            alternation_count=4
        )
        
        assert thrashing_detection.detected is True
        assert thrashing_detection.pattern == "Alternating file modifications"
        assert thrashing_detection.affected_files == affected_files
        assert thrashing_detection.alternation_count == 4
    
    def test_thrashing_detection_pattern_is_optional(self):
        """Test that pattern field is optional and can be None."""
        thrashing_detection = ThrashingDetection(
            detected=True,
            pattern=None,
            affected_files=["test.py"],
            alternation_count=3
        )
        
        assert thrashing_detection.pattern is None
    
    def test_thrashing_detection_affected_files_list_type(self):
        """Test that affected_files field accepts list of strings."""
        files = ["file1.py", "file2.py", "file3.py"]
        
        thrashing_detection = ThrashingDetection(
            detected=True,
            pattern="Multiple file thrashing",
            affected_files=files,
            alternation_count=6
        )
        
        assert isinstance(thrashing_detection.affected_files, list)
        assert len(thrashing_detection.affected_files) == 3
        assert all(isinstance(f, str) for f in thrashing_detection.affected_files)


class TestAgentHealth:
    """Test AgentHealth entity structure and behavior."""
    
    def test_agent_health_creation_healthy_status(self):
        """Test creating AgentHealth with healthy status."""
        agent_health = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE,
            loop_detection=None,
            thrashing_detection=None,
            drift_score=0.1,
            context_pressure=0.3,
            progress_score=0.8
        )
        
        assert agent_health.status == HealthStatus.HEALTHY
        assert agent_health.issues == []
        assert agent_health.recommendation == Recommendation.CONTINUE
        assert agent_health.loop_detection is None
        assert agent_health.thrashing_detection is None
        assert agent_health.drift_score == 0.1
        assert agent_health.context_pressure == 0.3
        assert agent_health.progress_score == 0.8
    
    def test_agent_health_creation_critical_status_with_issues(self):
        """Test creating AgentHealth with critical status and detected issues."""
        loop_detection = LoopDetection(True, "Action loop", 5, [])
        thrashing_detection = ThrashingDetection(True, "File thrashing", ["test.py"], 4)
        issues = ["Loop detected", "High drift", "Low progress"]
        
        agent_health = AgentHealth(
            status=HealthStatus.CRITICAL,
            issues=issues,
            recommendation=Recommendation.ABORT,
            loop_detection=loop_detection,
            thrashing_detection=thrashing_detection,
            drift_score=0.8,
            context_pressure=0.95,
            progress_score=0.05
        )
        
        assert agent_health.status == HealthStatus.CRITICAL
        assert agent_health.issues == issues
        assert agent_health.recommendation == Recommendation.ABORT
        assert agent_health.loop_detection == loop_detection
        assert agent_health.thrashing_detection == thrashing_detection
        assert agent_health.drift_score == 0.8
        assert agent_health.context_pressure == 0.95
        assert agent_health.progress_score == 0.05
    
    def test_agent_health_optional_detections_can_be_none(self):
        """Test that loop_detection and thrashing_detection can be None."""
        agent_health = AgentHealth(
            status=HealthStatus.DEGRADED,
            issues=["Minor drift"],
            recommendation=Recommendation.CHECKPOINT,
            loop_detection=None,
            thrashing_detection=None,
            drift_score=0.4,
            context_pressure=0.6,
            progress_score=0.5
        )
        
        assert agent_health.loop_detection is None
        assert agent_health.thrashing_detection is None
    
    def test_agent_health_issues_list_contains_strings(self):
        """Test that issues field contains list of string descriptions."""
        issues = [
            "Loop detected with 3 repetitions",
            "Drift score above threshold",
            "Context pressure high"
        ]
        
        agent_health = AgentHealth(
            status=HealthStatus.DEGRADED,
            issues=issues,
            recommendation=Recommendation.CHECKPOINT,
            loop_detection=None,
            thrashing_detection=None,
            drift_score=0.4,
            context_pressure=0.85,
            progress_score=0.2
        )
        
        assert isinstance(agent_health.issues, list)
        assert len(agent_health.issues) == 3
        assert all(isinstance(issue, str) for issue in agent_health.issues)
    
    def test_agent_health_score_fields_are_floats(self):
        """Test that drift_score, context_pressure, and progress_score are floats."""
        agent_health = AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE,
            loop_detection=None,
            thrashing_detection=None,
            drift_score=0.25,
            context_pressure=0.45,
            progress_score=0.75
        )
        
        assert isinstance(agent_health.drift_score, float)
        assert isinstance(agent_health.context_pressure, float)
        assert isinstance(agent_health.progress_score, float)
        
        # Verify scores are in expected 0.0-1.0 range
        assert 0.0 <= agent_health.drift_score <= 1.0
        assert 0.0 <= agent_health.context_pressure <= 1.0
        assert 0.0 <= agent_health.progress_score <= 1.0
