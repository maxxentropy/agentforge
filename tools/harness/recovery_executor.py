# Generated by AgentForge
# Spec: recovery_strategies
# Phase: green
# Date: 2025-12-31

"""Recovery executor for automated agent recovery strategies."""

from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, List, Dict, Any

from .recovery_domain import (
    RecoveryAction, RecoveryResult, Checkpoint,
    RecoveryAttempt, RecoveryPolicy
)
from .checkpoint_manager import CheckpointManager
from .monitor_domain import AgentHealth


class RecoveryExecutor:
    """Executes recovery strategies based on health status."""

    DEFAULT_POLICIES = [
        RecoveryPolicy(
            name="loop_recovery",
            triggers=["loop", "Loop detected", "Repeated action"],
            actions=[RecoveryAction.CHECKPOINT, RecoveryAction.ROLLBACK, RecoveryAction.RESET],
            max_attempts=3,
            cooldown_seconds=30
        ),
        RecoveryPolicy(
            name="drift_recovery",
            triggers=["drift", "High drift", "Moderate drift"],
            actions=[RecoveryAction.CHECKPOINT, RecoveryAction.SUMMARIZE, RecoveryAction.ESCALATE],
            max_attempts=2,
            cooldown_seconds=60
        ),
        RecoveryPolicy(
            name="thrashing_recovery",
            triggers=["thrashing", "Thrashing detected", "Files modified repeatedly"],
            actions=[RecoveryAction.CHECKPOINT, RecoveryAction.ROLLBACK],
            max_attempts=3,
            cooldown_seconds=30
        ),
        RecoveryPolicy(
            name="context_pressure_recovery",
            triggers=["context pressure", "Critical context", "High context"],
            actions=[RecoveryAction.SUMMARIZE, RecoveryAction.CHECKPOINT],
            max_attempts=2,
            cooldown_seconds=120
        ),
        RecoveryPolicy(
            name="stall_recovery",
            triggers=["progress", "low progress", "Very low progress"],
            actions=[RecoveryAction.RETRY, RecoveryAction.ESCALATE],
            max_attempts=2,
            cooldown_seconds=60
        ),
    ]

    def __init__(
        self,
        checkpoint_manager: CheckpointManager,
        policies: Optional[List[RecoveryPolicy]] = None
    ):
        """Initialize executor with checkpoint manager and policies."""
        self.checkpoint_manager = checkpoint_manager
        self.policies = policies if policies is not None else self.DEFAULT_POLICIES.copy()
        self.recovery_history: List[RecoveryAttempt] = []
        self.last_recovery_times: Dict[str, datetime] = {}

    def execute_recovery(
        self,
        health: AgentHealth,
        session_id: str,
        current_state: Dict[str, Any]
    ) -> RecoveryAttempt:
        """Execute appropriate recovery based on health issues."""
        if not health.issues:
            return RecoveryAttempt(
                action=RecoveryAction.SKIP,
                timestamp=datetime.now(),
                trigger="no_issues",
                result=RecoveryResult.SKIPPED,
                details={"reason": "No issues to recover from"}
            )

        # Find matching policy for first issue
        for issue in health.issues:
            policy = self.get_policy_for_issue(issue)
            if policy:
                # Check cooldown
                if not self._check_cooldown(policy.name, policy.cooldown_seconds):
                    continue

                # Try actions in order until one succeeds
                context = {
                    "session_id": session_id,
                    "state": current_state,
                    "issue": issue,
                    "health": health
                }

                for action in policy.actions:
                    attempt = self.execute_action(action, context)
                    self.recovery_history.append(attempt)

                    if attempt.result == RecoveryResult.SUCCESS:
                        self.last_recovery_times[policy.name] = datetime.now()
                        return attempt

                # All actions failed
                return RecoveryAttempt(
                    action=RecoveryAction.ESCALATE,
                    timestamp=datetime.now(),
                    trigger=issue,
                    result=RecoveryResult.FAILED,
                    details={"reason": "All recovery actions failed"},
                    error="Recovery exhausted"
                )

        # No matching policy found
        return RecoveryAttempt(
            action=RecoveryAction.SKIP,
            timestamp=datetime.now(),
            trigger=health.issues[0] if health.issues else "unknown",
            result=RecoveryResult.SKIPPED,
            details={"reason": "No matching recovery policy"}
        )

    def execute_action(
        self,
        action: RecoveryAction,
        context: Dict[str, Any]
    ) -> RecoveryAttempt:
        """Execute a single recovery action."""
        session_id = context.get("session_id", "unknown")
        state = context.get("state", {})
        issue = context.get("trigger", context.get("issue", "unknown"))

        try:
            if action == RecoveryAction.CHECKPOINT:
                return self.checkpoint(
                    session_id=session_id,
                    phase=state.get("phase", "unknown"),
                    state=state,
                    files=None
                )
            elif action == RecoveryAction.ROLLBACK:
                return self.rollback(session_id)
            elif action == RecoveryAction.SUMMARIZE:
                ctx = context.get("context", "")
                max_tokens = context.get("max_tokens", 4000)
                return self.summarize_context(ctx, max_tokens)
            elif action == RecoveryAction.RESET:
                preserve = context.get("preserve_keys", [])
                return self.reset_state(session_id, preserve)
            elif action == RecoveryAction.ESCALATE:
                reason = context.get("reason", issue)
                return self.escalate(reason, context)
            elif action == RecoveryAction.RETRY:
                return RecoveryAttempt(
                    action=RecoveryAction.RETRY,
                    timestamp=datetime.now(),
                    trigger=issue,
                    result=RecoveryResult.SUCCESS,
                    details={"action": "retry_requested"}
                )
            elif action == RecoveryAction.SKIP:
                return RecoveryAttempt(
                    action=RecoveryAction.SKIP,
                    timestamp=datetime.now(),
                    trigger=issue,
                    result=RecoveryResult.SKIPPED
                )
            else:
                return RecoveryAttempt(
                    action=action,
                    timestamp=datetime.now(),
                    trigger=issue,
                    result=RecoveryResult.FAILED,
                    error=f"Unknown action: {action}"
                )
        except Exception as e:
            return RecoveryAttempt(
                action=action,
                timestamp=datetime.now(),
                trigger=issue,
                result=RecoveryResult.FAILED,
                error=str(e)
            )

    def checkpoint(
        self,
        session_id: str,
        phase: str,
        state: Dict[str, Any],
        files: Optional[List[Path]] = None
    ) -> RecoveryAttempt:
        """Create a checkpoint."""
        try:
            checkpoint = self.checkpoint_manager.create_checkpoint(
                session_id=session_id,
                phase=phase,
                state=state,
                files_to_backup=files,
                description=f"Recovery checkpoint at {phase}"
            )
            return RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger="checkpoint_requested",
                result=RecoveryResult.SUCCESS,
                details={"checkpoint_id": checkpoint.id}
            )
        except Exception as e:
            return RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger="checkpoint_requested",
                result=RecoveryResult.FAILED,
                error=str(e)
            )

    def rollback(self, session_id: str) -> RecoveryAttempt:
        """Rollback to last checkpoint."""
        try:
            checkpoints = self.checkpoint_manager.list_checkpoints(session_id)
            if not checkpoints:
                return RecoveryAttempt(
                    action=RecoveryAction.ROLLBACK,
                    timestamp=datetime.now(),
                    trigger="rollback_requested",
                    result=RecoveryResult.FAILED,
                    error="No checkpoints available"
                )

            # Get most recent checkpoint
            latest = max(checkpoints, key=lambda c: c.timestamp)
            success = self.checkpoint_manager.restore_checkpoint(latest.id)

            if success:
                return RecoveryAttempt(
                    action=RecoveryAction.ROLLBACK,
                    timestamp=datetime.now(),
                    trigger="rollback_requested",
                    result=RecoveryResult.SUCCESS,
                    details={"checkpoint_id": latest.id, "state": latest.state}
                )
            else:
                return RecoveryAttempt(
                    action=RecoveryAction.ROLLBACK,
                    timestamp=datetime.now(),
                    trigger="rollback_requested",
                    result=RecoveryResult.FAILED,
                    error="Checkpoint restoration failed"
                )
        except Exception as e:
            return RecoveryAttempt(
                action=RecoveryAction.ROLLBACK,
                timestamp=datetime.now(),
                trigger="rollback_requested",
                result=RecoveryResult.FAILED,
                error=str(e)
            )

    def summarize_context(self, context: str, max_tokens: int) -> RecoveryAttempt:
        """Compress context to reduce token pressure."""
        try:
            if not context:
                return RecoveryAttempt(
                    action=RecoveryAction.SUMMARIZE,
                    timestamp=datetime.now(),
                    trigger="summarize_requested",
                    result=RecoveryResult.SUCCESS,
                    details={"summarized_context": "", "original_length": 0}
                )

            # Simple summarization: keep first and last portions
            # Rough token estimate: 1 token â‰ˆ 4 characters
            max_chars = max_tokens * 4

            if len(context) <= max_chars:
                return RecoveryAttempt(
                    action=RecoveryAction.SUMMARIZE,
                    timestamp=datetime.now(),
                    trigger="summarize_requested",
                    result=RecoveryResult.SUCCESS,
                    details={
                        "summarized_context": context,
                        "original_length": len(context),
                        "no_change": True
                    }
                )

            # Keep first 30% and last 50%, summarize middle
            first_portion = int(max_chars * 0.3)
            last_portion = int(max_chars * 0.5)

            first_part = context[:first_portion]
            last_part = context[-last_portion:]

            summarized = f"{first_part}\n\n[... context summarized ...]\n\n{last_part}"

            return RecoveryAttempt(
                action=RecoveryAction.SUMMARIZE,
                timestamp=datetime.now(),
                trigger="summarize_requested",
                result=RecoveryResult.SUCCESS,
                details={
                    "summarized_context": summarized,
                    "original_length": len(context),
                    "new_length": len(summarized)
                }
            )
        except Exception as e:
            return RecoveryAttempt(
                action=RecoveryAction.SUMMARIZE,
                timestamp=datetime.now(),
                trigger="summarize_requested",
                result=RecoveryResult.FAILED,
                error=str(e)
            )

    def reset_state(
        self,
        session_id: str,
        preserve_keys: List[str]
    ) -> RecoveryAttempt:
        """Clear problematic state."""
        try:
            # This would typically interact with session/memory storage
            # For now, return success with preserved keys info
            return RecoveryAttempt(
                action=RecoveryAction.RESET,
                timestamp=datetime.now(),
                trigger="reset_requested",
                result=RecoveryResult.SUCCESS,
                details={
                    "session_id": session_id,
                    "preserved_keys": preserve_keys,
                    "reset_complete": True
                }
            )
        except Exception as e:
            return RecoveryAttempt(
                action=RecoveryAction.RESET,
                timestamp=datetime.now(),
                trigger="reset_requested",
                result=RecoveryResult.FAILED,
                error=str(e)
            )

    def escalate(self, reason: str, context: Dict[str, Any]) -> RecoveryAttempt:
        """Trigger human escalation."""
        # Escalation always succeeds - it's the fallback
        escalation_data = {
            "reason": reason,
            "timestamp": datetime.now().isoformat(),
            "session_id": context.get("session_id"),
            "state_snapshot": context.get("state", {}),
            "health_status": str(context.get("health", {}).status) if "health" in context else None,
            "recommended_actions": [
                "Review agent behavior",
                "Check for stuck loops",
                "Verify task requirements",
                "Consider manual intervention"
            ]
        }

        return RecoveryAttempt(
            action=RecoveryAction.ESCALATE,
            timestamp=datetime.now(),
            trigger=reason,
            result=RecoveryResult.SUCCESS,
            details=escalation_data
        )

    def get_recovery_history(
        self,
        session_id: Optional[str] = None,
        limit: int = 10
    ) -> List[RecoveryAttempt]:
        """Get recent recovery attempts."""
        history = self.recovery_history

        if session_id:
            history = [
                a for a in history
                if a.details and a.details.get("session_id") == session_id
            ]

        return history[-limit:]

    def register_policy(self, policy: RecoveryPolicy) -> None:
        """Add a new recovery policy."""
        # Replace existing policy with same name
        self.policies = [p for p in self.policies if p.name != policy.name]
        self.policies.append(policy)

    def get_policy_for_issue(self, issue: str) -> Optional[RecoveryPolicy]:
        """Find matching policy for an issue."""
        issue_lower = issue.lower()
        for policy in self.policies:
            for trigger in policy.triggers:
                if trigger.lower() in issue_lower or issue_lower in trigger.lower():
                    return policy
        return None

    def _check_cooldown(self, policy_name: str, cooldown_seconds: int) -> bool:
        """Check if cooldown period has passed for a policy."""
        last_time = self.last_recovery_times.get(policy_name)
        if not last_time:
            return True

        elapsed = (datetime.now() - last_time).total_seconds()
        return elapsed >= cooldown_seconds
