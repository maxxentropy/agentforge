# @spec_file: .agentforge/specs/generate-v1.yaml
# @spec_id: generate-v1
# @component_id: tools-generate-writer
# @test_path: tests/unit/tools/generate/test_engine.py

"""
Code Writer
===========

Writes generated files to disk with safety features:
- Atomic writes (temp file + rename)
- Backup of existing files
- Rollback capability
- Header comments for generated files
"""

import os
import shutil
import tempfile
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Optional

from tools.generate.domain import GeneratedFile, FileAction, WriteError


@dataclass
class WriteOperation:
    """Record of a single write operation for rollback."""

    path: Path
    action: FileAction
    backup_path: Optional[Path] = None
    original_existed: bool = False
    timestamp: datetime = field(default_factory=datetime.utcnow)


class CodeWriter:
    """
    Writes generated code files to disk.

    Features:
    - Atomic writes using temp file + rename
    - Automatic backup of existing files
    - Rollback to restore original state
    - Optional header comments on generated files
    """

    DEFAULT_BACKUP_DIR = Path(".agentforge/backups")

    HEADER_TEMPLATE = '''# Generated by AgentForge
# Spec: {spec_name}
# Phase: {phase}
# Date: {timestamp}

'''

    def __init__(
        self,
        project_root: Optional[Path] = None,
        backup_dir: Optional[Path] = None,
        add_header: bool = True,
        atomic_writes: bool = True,
    ):
        """
        Initialize code writer.

        Args:
            project_root: Root directory for relative paths
            backup_dir: Directory for file backups
            add_header: Whether to add header comments to files
            atomic_writes: Whether to use atomic write pattern
        """
        self.project_root = project_root or Path.cwd()
        self.backup_dir = backup_dir or self.DEFAULT_BACKUP_DIR
        self.add_header = add_header
        self.atomic_writes = atomic_writes

        # Track operations for rollback
        self._operations: List[WriteOperation] = []

        # Metadata for headers
        self._spec_name: str = "unknown"
        self._phase: str = "unknown"

    def set_metadata(self, spec_name: str, phase: str) -> None:
        """
        Set metadata for file headers.

        Args:
            spec_name: Name of the specification
            phase: Current phase (red/green/refactor)
        """
        self._spec_name = spec_name
        self._phase = phase

    def write(self, files: List[GeneratedFile]) -> List[Path]:
        """
        Write generated files to disk.

        Args:
            files: List of GeneratedFile objects

        Returns:
            List of paths that were written

        Raises:
            WriteError: If any write operation fails
        """
        written_paths = []

        for file in files:
            try:
                path = self._write_file(file)
                written_paths.append(path)
            except Exception as e:
                # On error, attempt rollback of successful writes
                self.rollback()
                raise WriteError(
                    f"Failed to write {file.path}: {e}",
                    path=file.path,
                    original_error=e,
                )

        return written_paths

    def _write_file(self, file: GeneratedFile) -> Path:
        """
        Write a single file with backup and atomic write.

        Args:
            file: GeneratedFile to write

        Returns:
            Path that was written
        """
        # Resolve path relative to project root
        if file.path.is_absolute():
            target_path = file.path
        else:
            target_path = self.project_root / file.path

        # Handle different actions
        if file.action == FileAction.DELETE:
            return self._delete_file(target_path)
        else:
            return self._create_or_modify_file(file, target_path)

    def _create_or_modify_file(
        self,
        file: GeneratedFile,
        target_path: Path,
    ) -> Path:
        """Create or modify a file."""
        # Track operation
        operation = WriteOperation(
            path=target_path,
            action=file.action,
            original_existed=target_path.exists(),
        )

        # Backup existing file if it exists
        if target_path.exists():
            operation.backup_path = self._backup_file(target_path)

        # Prepare content
        content = file.content
        if self.add_header and target_path.suffix == ".py":
            content = self._add_header(content)

        # Create parent directories
        target_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        if self.atomic_writes:
            self._atomic_write(target_path, content)
        else:
            target_path.write_text(content)

        self._operations.append(operation)
        return target_path

    def _delete_file(self, target_path: Path) -> Path:
        """Delete a file with backup."""
        if not target_path.exists():
            return target_path

        operation = WriteOperation(
            path=target_path,
            action=FileAction.DELETE,
            original_existed=True,
            backup_path=self._backup_file(target_path),
        )

        target_path.unlink()
        self._operations.append(operation)
        return target_path

    def _backup_file(self, path: Path) -> Path:
        """
        Create backup of existing file.

        Args:
            path: File to backup

        Returns:
            Path to backup file
        """
        # Ensure backup directory exists
        backup_root = self.project_root / self.backup_dir
        backup_root.mkdir(parents=True, exist_ok=True)

        # Create timestamped backup filename
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S_%f")
        relative_path = path.relative_to(self.project_root) if path.is_relative_to(self.project_root) else path
        safe_name = str(relative_path).replace("/", "_").replace("\\", "_")
        backup_name = f"{timestamp}_{safe_name}"
        backup_path = backup_root / backup_name

        # Copy file to backup
        shutil.copy2(path, backup_path)
        return backup_path

    def _atomic_write(self, path: Path, content: str) -> None:
        """
        Write file atomically using temp file + rename.

        Args:
            path: Target path
            content: Content to write
        """
        # Write to temp file in same directory (for same-filesystem rename)
        fd, temp_path = tempfile.mkstemp(
            suffix=".tmp",
            dir=path.parent,
        )
        try:
            with os.fdopen(fd, "w") as f:
                f.write(content)
            # Atomic rename
            shutil.move(temp_path, path)
        except Exception:
            # Clean up temp file on error
            if os.path.exists(temp_path):
                os.remove(temp_path)
            raise

    def _add_header(self, content: str) -> str:
        """
        Add header comment to content.

        Preserves shebang and encoding declarations.
        """
        lines = content.split("\n")
        header = self.HEADER_TEMPLATE.format(
            spec_name=self._spec_name,
            phase=self._phase,
            timestamp=datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC"),
        )

        # Check for shebang or encoding
        insert_at = 0
        preserved = []

        for i, line in enumerate(lines[:2]):
            if line.startswith("#!") or line.startswith("# -*-") or "coding" in line:
                preserved.append(line)
                insert_at = i + 1
            else:
                break

        if preserved:
            return "\n".join(preserved) + "\n" + header + "\n".join(lines[insert_at:])
        else:
            return header + content

    def rollback(self) -> int:
        """
        Rollback all write operations.

        Restores files from backups and removes newly created files.

        Returns:
            Number of operations rolled back
        """
        rolled_back = 0

        # Process in reverse order
        for operation in reversed(self._operations):
            try:
                self._rollback_operation(operation)
                rolled_back += 1
            except Exception:
                # Best effort - continue with other rollbacks
                pass

        self._operations.clear()
        return rolled_back

    def _rollback_operation(self, operation: WriteOperation) -> None:
        """Rollback a single operation."""
        if operation.action == FileAction.DELETE:
            # Restore deleted file from backup
            if operation.backup_path and operation.backup_path.exists():
                shutil.copy2(operation.backup_path, operation.path)

        elif operation.action in (FileAction.CREATE, FileAction.MODIFY):
            if operation.original_existed:
                # Restore from backup
                if operation.backup_path and operation.backup_path.exists():
                    shutil.copy2(operation.backup_path, operation.path)
            else:
                # Remove newly created file
                if operation.path.exists():
                    operation.path.unlink()

    def clear_history(self) -> None:
        """Clear operation history (after successful completion)."""
        self._operations.clear()

    def cleanup_backups(self, max_age_days: int = 7) -> int:
        """
        Remove old backup files.

        Args:
            max_age_days: Remove backups older than this

        Returns:
            Number of backups removed
        """
        backup_root = self.project_root / self.backup_dir
        if not backup_root.exists():
            return 0

        removed = 0
        cutoff = datetime.utcnow().timestamp() - (max_age_days * 24 * 60 * 60)

        for backup_file in backup_root.iterdir():
            if backup_file.is_file():
                if backup_file.stat().st_mtime < cutoff:
                    backup_file.unlink()
                    removed += 1

        return removed

    @property
    def operation_count(self) -> int:
        """Number of operations in current session."""
        return len(self._operations)

    @property
    def has_pending_operations(self) -> bool:
        """Whether there are operations that can be rolled back."""
        return len(self._operations) > 0
