# @spec_file: .agentforge/specs/core-bridge-v1.yaml
# @spec_id: core-bridge-v1
# @component_id: core-bridge-contract_builder
# @test_path: tests/unit/tools/bridge/test_contract_builder.py

"""
Contract Builder
================

Builds and writes contract YAML files from generated checks.
"""

from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional

from bridge.domain import (
    GeneratedCheck,
    GeneratedContract,
    GenerationMetadata,
)

try:
    import yaml
except ImportError:
    yaml = None  # type: ignore


# Contract file header template
CONTRACT_HEADER = """# ============================================================================
# AUTO-GENERATED CONTRACT - DO NOT EDIT MANUALLY
#
# Generated by: AgentForge Bridge v{version}
# Source: {source}
# Generated: {timestamp}
#
# To regenerate: {regenerate_command}
# To customize: Copy to a new file and modify
# ============================================================================

"""


class ContractBuilder:
    """
    Builds contract YAML files from generated checks.

    Creates contracts with:
    - Header comments with provenance
    - Proper schema version
    - Generation metadata
    - Grouped checks by source pattern
    """

    GENERATOR_VERSION = "1.0.0"

    def __init__(
        self,
        root_path: Path,
        output_dir: str = "contracts",
    ):
        """
        Initialize contract builder.

        Args:
            root_path: Repository root path
            output_dir: Output directory for contracts
        """
        self.root_path = Path(root_path).resolve()
        self.output_dir = self.root_path / output_dir

    def build_contract(
        self,
        zone_name: Optional[str],
        language: str,
        checks: List[GeneratedCheck],
        profile_path: str,
        profile_hash: str,
        confidence_threshold: float = 0.6,
    ) -> GeneratedContract:
        """
        Build a generated contract from checks.

        Args:
            zone_name: Zone name (or None for default)
            language: Primary language
            checks: List of generated checks
            profile_path: Path to source profile
            profile_hash: Hash of profile content
            confidence_threshold: Confidence threshold used

        Returns:
            GeneratedContract object
        """
        name = zone_name or "generated"

        # Build metadata
        metadata = GenerationMetadata(
            source_profile=profile_path,
            source_hash=profile_hash,
            generated_at=datetime.now(),
            generator_version=self.GENERATOR_VERSION,
            zone=zone_name,
            confidence_threshold=confidence_threshold,
            patterns_mapped=self._group_patterns(checks),
            regenerate_command=f"agentforge bridge refresh{' --zone ' + zone_name if zone_name else ''}",
        )

        # Build applies_to paths
        applies_to_paths = None
        exclude_paths = ["**/tests/**", "**/Tests/**", "**/*.Tests.cs"]

        if zone_name:
            # Zone-specific paths would be added here
            pass

        # Build tags
        tags = ["generated"]
        if zone_name:
            tags.append(zone_name)
        tags.append(language)

        # Description
        description = f"Auto-generated patterns for {name}.\n"
        description += f"Based on discovered patterns with confidence >= {confidence_threshold}."

        return GeneratedContract(
            name=name,
            zone=zone_name,
            language=language,
            checks=checks,
            metadata=metadata,
            description=description,
            applies_to_paths=applies_to_paths,
            exclude_paths=exclude_paths,
            tags=tags,
        )

    def _group_patterns(self, checks: List[GeneratedCheck]) -> Dict[str, float]:
        """Group checks by source pattern with max confidence."""
        patterns: Dict[str, float] = {}
        for check in checks:
            pattern = check.source_pattern
            if pattern not in patterns or check.source_confidence > patterns[pattern]:
                patterns[pattern] = check.source_confidence
        return patterns

    def write_contract(
        self,
        contract: GeneratedContract,
        dry_run: bool = False,
    ) -> Optional[Path]:
        """
        Write contract to YAML file.

        Args:
            contract: Contract to write
            dry_run: If True, don't actually write

        Returns:
            Path to written file (or would-be path for dry run)
        """
        if yaml is None:
            raise ImportError("PyYAML is required for contract writing")

        # Determine output path
        filename = f"{contract.name}.contract.yaml"
        output_path = self.output_dir / filename

        if dry_run:
            return output_path

        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Build content
        content = self._build_yaml_content(contract)

        # Write file
        output_path.write_text(content)

        return output_path

    def _build_yaml_content(self, contract: GeneratedContract) -> str:
        """Build full YAML content with header."""
        # Build header
        header = CONTRACT_HEADER.format(
            version=self.GENERATOR_VERSION,
            source=contract.metadata.source_profile,
            timestamp=contract.metadata.generated_at.isoformat(),
            regenerate_command=contract.metadata.regenerate_command or "agentforge bridge refresh",
        )

        # Build YAML body
        contract_dict = contract.to_dict()

        # Group checks by source pattern for readability
        checks = contract_dict.pop("checks", [])
        # Don't include empty checks here - we'll add them manually below

        # Sort checks by source pattern
        checks_by_pattern: Dict[str, List[dict]] = {}
        for check in checks:
            pattern = check.get("generation", {}).get("source_pattern", "other")
            if pattern not in checks_by_pattern:
                checks_by_pattern[pattern] = []
            checks_by_pattern[pattern].append(check)

        # Add checks with pattern group comments
        yaml_body = yaml.dump(contract_dict, default_flow_style=False, sort_keys=False)

        # Build checks section with comments
        checks_section = "\nchecks:\n"
        for pattern, pattern_checks in checks_by_pattern.items():
            # Get confidence for this pattern
            confidence = pattern_checks[0].get("generation", {}).get("source_confidence", 0)
            needs_review = any(
                c.get("generation", {}).get("review_required", False)
                for c in pattern_checks
            )

            # Add pattern group comment
            review_note = " - NEEDS REVIEW" if needs_review else ""
            checks_section += f"  # {'='*70}\n"
            checks_section += f"  # {pattern.upper()} Pattern (confidence: {confidence:.2f}){review_note}\n"
            checks_section += f"  # {'='*70}\n\n"

            # Add checks
            for check in pattern_checks:
                check_yaml = yaml.dump([check], default_flow_style=False, sort_keys=False)
                # Indent properly
                indented = "  " + check_yaml.replace("\n", "\n  ").rstrip() + "\n\n"
                checks_section += indented

        return header + yaml_body + checks_section

    def preview_contract(self, contract: GeneratedContract) -> str:
        """
        Generate preview of contract without writing.

        Args:
            contract: Contract to preview

        Returns:
            YAML content as string
        """
        return self._build_yaml_content(contract)

    def get_output_path(self, contract_name: str) -> Path:
        """Get the output path for a contract name."""
        return self.output_dir / f"{contract_name}.contract.yaml"

    def contract_exists(self, contract_name: str) -> bool:
        """Check if a contract file already exists."""
        return self.get_output_path(contract_name).exists()
