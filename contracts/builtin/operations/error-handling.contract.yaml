schema_version: '2.0'
contract:
  name: error-handling
  type: operations
  description: 'Comprehensive error handling patterns covering exceptions,

    Result types, validation, and error propagation strategies.

    '
  version: 1.0.0
  enabled: false  # Disabled - check types not yet implemented
  tags:
  - builtin
  - operations
  - code-quality
checks:
- id: custom-exception-hierarchy
  name: Design meaningful exception hierarchies
  description: Design meaningful exception hierarchies
  type: exception_design
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    structure:
      base_exception:
        name: '{Module}Error'
        inherits: Exception
        purpose: Base for all module exceptions
      specific_exceptions:
        pattern: '{Specific}Error'
        inherits: base_exception
        examples:
        - ValidationError
        - NotFoundError
        - AuthorizationError
        - ConfigurationError
    include:
    - error_code
    - message
    - context_dict
    - original_exception
    example: "class ServiceError(Exception):\n    def __init__(self, message, code=None, context=None,\
      \ cause=None):\n        super().__init__(message)\n        self.code = code\n        self.context\
      \ = context or {}\n        self.__cause__ = cause\n"
  rationale: 'Custom exceptions allow specific handling. Generic exceptions

    force callers to parse messages or catch too broadly.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: exception-information
  name: Exceptions must carry diagnostic information
  description: Exceptions must carry diagnostic information
  type: exception_design
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    required:
    - descriptive_message
    - relevant_context
    recommended:
    - error_code
    - documentation_link
    - suggested_action
    avoid:
    - empty_message
    - generic_message
    - exposing_internals
    examples:
      bad: 'raise ValueError("Error")

        '
      good: "raise UserNotFoundError(\n    f\"User '{user_id}' not found in organization '{org_id}'\"\
        ,\n    code=\"USER_NOT_FOUND\",\n    context={\"user_id\": user_id, \"org_id\": org_id}\n)\n"
  rationale: 'Good error messages accelerate debugging. Include what

    happened, what was expected, and relevant identifiers.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: catch-specific-exceptions
  name: Catch specific exceptions, not generic ones
  description: Catch specific exceptions, not generic ones
  type: exception_handling
  severity: error
  enabled: false  # Disabled - check types not yet implemented
  config:
    avoid:
    - bare_except
    - catch_exception_base
    - catch_all_reraise
    prefer:
    - specific_exception_types
    - exception_hierarchies
    allowed_generic_catch:
    - top_level_handlers
    - thread_boundaries
    - with_logging_and_reraise
    examples:
      bad: "try:\n    operation()\nexcept Exception:\n    pass\n"
      good: "try:\n    operation()\nexcept ValidationError as e:\n    handle_validation(e)\nexcept NotFoundError\
        \ as e:\n    handle_not_found(e)\n"
  rationale: 'Generic catches hide bugs. Different errors need

    different handling strategies.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: no-swallowed-exceptions
  name: Never silently swallow exceptions
  description: Never silently swallow exceptions
  type: exception_handling
  severity: error
  enabled: false  # Disabled - check types not yet implemented
  config:
    violations:
    - empty_except_block
    - except_pass
    - catch_without_action
    acceptable:
    - log_and_continue
    - return_default
    - raise_different
    require:
    - logging_in_catch
    - or_reraise
    - or_convert_to_result
    examples:
      bad: "try:\n    risky_operation()\nexcept Exception:\n    pass  # Silent failure!\n"
      good: "try:\n    risky_operation()\nexcept OperationError as e:\n    logger.warning(f\"Operation\
        \ failed, using default: {e}\")\n    return default_value\n"
  rationale: 'Swallowed exceptions hide bugs and make debugging

    extremely difficult. Always handle or propagate.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: exception-translation
  name: Translate exceptions at layer boundaries
  description: Translate exceptions at layer boundaries
  type: exception_handling
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    pattern:
      infrastructure_to_domain:
        catch:
        - SqlException
        - HttpException
        - IOError
        raise:
        - RepositoryError
        - ServiceError
        - StorageError
      domain_to_api:
        catch:
        - DomainError
        - ValidationError
        raise:
        - HttpError
        - ApiError
    preserve:
    - original_exception_as_cause
    - relevant_context
    - stack_trace
    example: "try:\n    result = db.execute(query)\nexcept SqlException as e:\n    raise RepositoryError(\n\
      \        f\"Failed to query users: {e}\",\n        cause=e\n    ) from e\n"
  rationale: 'Higher layers shouldn''t know about lower layer

    implementation details. Translate to appropriate abstraction.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: result-pattern
  name: Use Result types for expected failures
  description: Use Result types for expected failures
  type: error_pattern
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    when_to_use:
    - validation_errors
    - business_rule_violations
    - expected_failure_conditions
    - operations_that_commonly_fail
    when_not_to_use:
    - programming_errors
    - infrastructure_failures
    - unrecoverable_conditions
    structure:
      success: Result.ok(value)
      failure: Result.error(error)
      check: result.is_success / result.is_failure
      access: result.value / result.error
    example: "def validate_email(email: str) -> Result[Email, ValidationError]:\n    if not is_valid_format(email):\n\
      \        return Result.error(ValidationError(\"Invalid email format\"))\n    return Result.ok(Email(email))\n"
  rationale: 'Result types make failure handling explicit in the type

    system. Callers can''t ignore potential failures.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: result-not-exception-mixing
  name: Don't mix Result and exceptions for same concerns
  description: Don't mix Result and exceptions for same concerns
  type: error_pattern
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    principle: 'Within a module, consistently use either Result or exceptions

      for handling the same category of errors.

      '
    guidelines:
      expected_failures: use_result
      unexpected_failures: use_exceptions
      validation: use_result
      infrastructure_errors: use_exceptions
    anti_pattern: "# BAD: Sometimes Result, sometimes exception\ndef process(data):\n    if not valid(data):\n\
      \        return Result.error(\"Invalid\")  # Result\n    try:\n        save(data)\n    except DbError:\n\
      \        raise ProcessingError()  # Exception\n"
  rationale: 'Mixing patterns confuses callers. Consistency makes

    error handling predictable.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: fail-fast-validation
  name: Validate inputs early, fail fast
  description: Validate inputs early, fail fast
  type: validation_pattern
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    validate_at:
    - function_entry
    - layer_boundaries
    - before_expensive_operations
    validation_order:
      1: required_fields
      2: type_correctness
      3: format_validation
      4: business_rules
    pattern: "def process_order(order: Order) -> Result:\n    # Validate at entry\n    validation = validate_order(order)\n\
      \    if validation.is_failure:\n        return validation\n\n    # Proceed with valid data\n   \
      \ ...\n"
  rationale: 'Early validation prevents wasted work and makes errors

    easier to diagnose. Don''t validate deep in the call stack.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: accumulate-validation-errors
  name: Collect all validation errors, not just first
  description: Collect all validation errors, not just first
  type: validation_pattern
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    pattern:
      collect_all: true
      return_format: list[ValidationError]
    example: "def validate_user(user: UserInput) -> list[ValidationError]:\n    errors = []\n    if not\
      \ user.name:\n        errors.append(ValidationError(\"name\", \"Name is required\"))\n    if not\
      \ is_valid_email(user.email):\n        errors.append(ValidationError(\"email\", \"Invalid email\
      \ format\"))\n    if user.age and user.age < 0:\n        errors.append(ValidationError(\"age\",\
      \ \"Age must be positive\"))\n    return errors\n"
    anti_pattern: "# BAD: Only returns first error\nif not user.name:\n    raise ValidationError(\"Name\
      \ is required\")\nif not user.email:\n    raise ValidationError(\"Email is required\")\n"
  rationale: 'Returning all errors at once improves user experience.

    Users can fix all issues in one pass.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: dont-catch-to-rethrow-same
  name: Don't catch just to rethrow the same exception
  description: Don't catch just to rethrow the same exception
  type: exception_handling
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    bad_pattern: "try:\n    operation()\nexcept SomeError:\n    raise  # Pointless catch\n"
    acceptable:
    - catch_log_reraise
    - catch_wrap_reraise
    - catch_cleanup_reraise
    example: "# Acceptable: logging before reraise\ntry:\n    operation()\nexcept OperationError as e:\n\
      \    logger.error(f\"Operation failed: {e}\")\n    raise\n"
  rationale: 'Catching just to rethrow adds noise. Only catch if

    you''re adding value (logging, wrapping, cleanup).

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: preserve-stack-trace
  name: Preserve original stack trace when wrapping except
  description: Preserve original stack trace when wrapping exceptions
  type: exception_handling
  severity: error
  enabled: false  # Disabled - check types not yet implemented
  config:
    languages:
      python:
        correct: raise NewError(...) from original_error
        wrong: raise NewError(...)
      csharp:
        correct: throw new NewException(..., innerException)
        wrong: throw new NewException(...)
      typescript:
        correct: 'throw new NewError(..., { cause: original })'
        wrong: throw new NewError(...)
    example: "try:\n    external_call()\nexcept ExternalError as e:\n    raise InternalError(\"External\
      \ service failed\") from e\n"
  rationale: 'Lost stack traces make debugging nearly impossible.

    Always chain exceptions to preserve the full trace.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: cleanup-in-finally
  name: Use finally or context managers for cleanup
  description: Use finally or context managers for cleanup
  type: resource_handling
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    prefer:
    - context_managers
    - finally_blocks
    - disposable_pattern
    avoid:
    - cleanup_only_in_try
    - cleanup_only_in_except
    examples:
      python: "with open(file) as f:\n    process(f)\n# or\ntry:\n    resource = acquire()\n    use(resource)\n\
        finally:\n    resource.release()\n"
  rationale: 'Cleanup in try or except may not run on all paths.

    finally/with guarantees cleanup regardless of outcome.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
- id: resource-acquisition
  name: Acquire resources late, release early
  description: Acquire resources late, release early
  type: resource_handling
  severity: warning
  enabled: false  # Disabled - check types not yet implemented
  config:
    principles:
    - acquire_just_before_use
    - release_immediately_after
    - minimize_hold_time
    - use_scoped_resources
    anti_patterns:
    - acquire_at_function_start
    - release_only_at_function_end
    - holding_during_user_input
  rationale: 'Holding resources longer than needed leads to contention

    and resource exhaustion. Minimize the window.

    '
  applies_to:
    paths:
    - '**/*.py'
    exclude_paths:
    - '**/node_modules/**'
    - '**/venv/**'
    - '**/__pycache__/**'
escalation_triggers:
- trigger_id: swallowed-exception
  condition: Exception caught with no handling
  severity: blocking
  prompt: 'Exception is being swallowed:

    - Add logging at minimum

    - Consider if retry is appropriate

    - Propagate if can''t handle

    '
  rationale: 'Swallowed exceptions hide bugs and make systems

    behave unpredictably.

    '
- trigger_id: generic-exception-catch
  condition: Catching Exception or BaseException
  severity: advisory
  prompt: 'Generic exception catch detected:

    - Identify specific exceptions to catch

    - Add logging if truly catching all

    - Ensure reraise after handling

    '
  rationale: 'Generic catches hide bugs. Be specific about

    what errors you expect and can handle.

    '
- trigger_id: exception-without-context
  condition: Exception raised without diagnostic information
  severity: advisory
  prompt: 'Exception lacks context for debugging:

    - Add descriptive message

    - Include relevant identifiers

    - Consider adding error code

    '
  rationale: 'Good error messages accelerate debugging.

    Include what, why, and relevant context.

    '
quality_gates:
- gate_id: error-handling-review
  checks:
  - Custom exceptions used appropriately
  - No swallowed exceptions
  - Specific exceptions caught
  - Stack traces preserved
  - Validation fails fast
  failure_action: escalate
- gate_id: resource-handling-review
  checks:
  - Cleanup in finally/with
  - Resources released promptly
  - No resource leaks in error paths
  failure_action: advisory
