# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: core-harness-memory_store
# @test_path: tests/unit/harness/test_memory_store.py

# Generated by AgentForge
# Spec: unknown
# Phase: green
# Date: 2025-12-31 05:10:41 UTC

"""Persistence layer for memory tiers."""

import tempfile
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Any

from agentforge.core.harness.memory_domain import MemoryTier, MemoryEntry


class MemoryWriteError(Exception):
    """Raised when memory write operations fail."""
    pass


class MemoryStore:
    """Persistence layer for memory tiers with YAML storage."""
    
    def __init__(self, tier_paths: Optional[Dict[MemoryTier, Optional[Path]]] = None):
        """Initialize store with configurable paths for each tier.
        
        Args:
            tier_paths: Optional mapping of tiers to file paths. 
                       If None, uses default paths.
        """
        if tier_paths is None:
            # Default paths as per specification
            home = Path.home()
            agentforge_dir = Path(".agentforge")
            
            tier_paths = {
                MemoryTier.SESSION: None,  # In-memory only
                MemoryTier.TASK: agentforge_dir / "tasks" / "{task_id}" / "memory.yaml",
                MemoryTier.PROJECT: agentforge_dir / "project_memory.yaml", 
                MemoryTier.ORGANIZATION: home / ".agentforge" / "org_memory.yaml"
            }
        
        self._tier_paths = tier_paths
        self._data: Dict[MemoryTier, Dict[str, MemoryEntry]] = {}
    
    def get(self, key: str, tier: MemoryTier) -> Optional[MemoryEntry]:
        """Retrieve value by key from specified tier.
        
        Args:
            key: The key to retrieve
            tier: The memory tier to search
            
        Returns:
            MemoryEntry if found, None otherwise
        """
        try:
            tier_data = self._load_tier(tier)
            return tier_data.get(key)
        except Exception:
            # Handle corrupted files gracefully
            return None
    
    def set(self, key: str, entry: MemoryEntry, tier: MemoryTier) -> None:
        """Store value at key in specified tier.
        
        Args:
            key: The key to store under
            entry: The memory entry to store
            tier: The memory tier to store in
            
        Raises:
            MemoryWriteError: If write to persistent tier fails
        """
        # Ensure tier data exists
        if tier not in self._data:
            self._data[tier] = self._load_tier(tier)
        
        # Store the entry
        self._data[tier][key] = entry
        
        # Auto-save for persistent tiers
        if self._tier_paths[tier] is not None:
            self._save_tier(tier)
    
    def delete(self, key: str, tier: MemoryTier) -> None:
        """Remove key from specified tier.
        
        Args:
            key: The key to remove
            tier: The memory tier to remove from
        """
        # Load tier data if not already loaded
        if tier not in self._data:
            self._data[tier] = self._load_tier(tier)
        
        # Remove key if it exists
        self._data[tier].pop(key, None)
        
        # Auto-save for persistent tiers
        if self._tier_paths[tier] is not None:
            self._save_tier(tier)
    
    def list_keys(self, tier: MemoryTier, prefix: Optional[str] = None) -> List[str]:
        """Return list of keys in tier, optionally filtered by prefix.
        
        Args:
            tier: The memory tier to list keys from
            prefix: Optional prefix to filter keys
            
        Returns:
            List of keys matching criteria
        """
        tier_data = self._load_tier(tier)
        keys = list(tier_data.keys())
        
        if prefix is not None:
            keys = [k for k in keys if k.startswith(prefix)]
        
        return keys
    
    def clear_tier(self, tier: MemoryTier) -> None:
        """Clear all entries from specified tier.
        
        Args:
            tier: The memory tier to clear
        """
        # Clear the tier data
        self._data[tier] = {}
        
        # Auto-save for persistent tiers
        if self._tier_paths[tier] is not None:
            self._save_tier(tier)
    
    def _load_tier(self, tier: MemoryTier) -> Dict[str, MemoryEntry]:
        """Load tier data from YAML file or memory.
        
        Args:
            tier: The memory tier to load
            
        Returns:
            Dictionary of key-value pairs for the tier
        """
        # For session tier, return in-memory data
        if self._tier_paths[tier] is None:
            return self._data.get(tier, {})
        
        # For persistent tiers, load from file
        tier_path = self._tier_paths[tier]
        
        try:
            with open(tier_path, 'r') as f:
                raw_data = yaml.safe_load(f) or {}
            
            # Convert raw data back to MemoryEntry objects
            tier_data = {}
            for key, entry_dict in raw_data.items():
                tier_data[key] = MemoryEntry.from_dict(entry_dict)
            
            return tier_data
            
        except (FileNotFoundError, OSError, yaml.YAMLError, Exception):
            # Handle missing/corrupted files gracefully
            return {}
    
    def _save_tier(self, tier: MemoryTier) -> None:
        """Persist tier data to YAML using atomic writes.
        
        Args:
            tier: The memory tier to save
            
        Raises:
            MemoryWriteError: If write operation fails
        """
        # Session tier is in-memory only
        if self._tier_paths[tier] is None:
            return
        
        tier_path = self._tier_paths[tier]
        tier_data = self._data.get(tier, {})
        
        try:
            # Create parent directories
            tier_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Serialize entries to dictionaries
            serialized_data = {}
            for key, entry in tier_data.items():
                serialized_data[key] = entry.to_dict()
            
            # Use atomic writes with temp file
            with tempfile.NamedTemporaryFile(
                mode='w', 
                dir=tier_path.parent,
                delete=False,
                suffix='.tmp'
            ) as temp_file:
                yaml.dump(serialized_data, temp_file, default_flow_style=False)
                temp_path = Path(temp_file.name)
            
            # Atomic move to final location
            temp_path.replace(tier_path)
            
        except (OSError, yaml.YAMLError, Exception) as e:
            raise MemoryWriteError(f"Failed to write tier {tier}: {e}")
