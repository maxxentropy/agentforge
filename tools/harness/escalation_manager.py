# Generated by AgentForge
# Spec: human_escalation
# Phase: green
# Date: 2025-12-31

"""Escalation manager for human-in-the-loop intervention."""

import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import Optional

from .escalation_domain import (
    EscalationPriority,
    EscalationStatus,
    EscalationChannel,
    ResolutionType,
    Escalation,
    EscalationResolution
)


class EscalationManager:
    """Manages escalation lifecycle."""

    def __init__(
        self,
        storage_path: Path,
        default_timeout: int = 3600,
        channels: Optional[list[EscalationChannel]] = None
    ):
        """Initialize escalation manager.

        Args:
            storage_path: Directory for escalation storage
            default_timeout: Default timeout in seconds
            channels: Active notification channels
        """
        self.storage_path = Path(storage_path)
        self.default_timeout = default_timeout
        self.channels = channels or [EscalationChannel.CLI]
        self.storage_path.mkdir(parents=True, exist_ok=True)

    def create_escalation(
        self,
        session_id: str,
        reason: str,
        context: dict,
        priority: EscalationPriority = EscalationPriority.MEDIUM,
        recommended_actions: Optional[list[str]] = None,
        timeout_seconds: Optional[int] = None
    ) -> Escalation:
        """Create a new escalation request.

        Args:
            session_id: Session identifier
            reason: Why escalation was triggered
            context: Relevant state and history
            priority: Urgency level
            recommended_actions: Suggested actions for human
            timeout_seconds: Auto-resolve after timeout

        Returns:
            Created escalation
        """
        escalation_id = f"esc-{uuid.uuid4().hex[:12]}"

        escalation = Escalation(
            id=escalation_id,
            session_id=session_id,
            created_at=datetime.now(),
            priority=priority,
            status=EscalationStatus.PENDING,
            reason=reason,
            context=context,
            recommended_actions=recommended_actions or [],
            timeout_seconds=timeout_seconds if timeout_seconds is not None else self.default_timeout
        )

        self._save_escalation(escalation)
        return escalation

    def acknowledge_escalation(
        self,
        escalation_id: str,
        acknowledged_by: Optional[str] = None
    ) -> bool:
        """Mark escalation as seen by human.

        Args:
            escalation_id: Escalation to acknowledge
            acknowledged_by: Identifier for who acknowledged

        Returns:
            True if acknowledgment succeeded
        """
        escalation = self.get_escalation(escalation_id)
        if not escalation:
            return False

        escalation.status = EscalationStatus.ACKNOWLEDGED
        escalation.acknowledged_at = datetime.now()
        self._save_escalation(escalation)
        return True

    def resolve_escalation(
        self,
        escalation_id: str,
        resolution_type: ResolutionType,
        decision: str,
        notes: Optional[str] = None,
        resolved_by: Optional[str] = None
    ) -> EscalationResolution:
        """Record human's resolution.

        Args:
            escalation_id: Escalation to resolve
            resolution_type: How it was resolved
            decision: Human's decision or instruction
            notes: Additional notes
            resolved_by: Identifier for who resolved

        Returns:
            Resolution record
        """
        escalation = self.get_escalation(escalation_id)
        resolved_at = datetime.now()

        resolution = EscalationResolution(
            escalation_id=escalation_id,
            resolution_type=resolution_type,
            decision=decision,
            resolved_at=resolved_at,
            notes=notes,
            resolved_by=resolved_by
        )

        if escalation:
            escalation.status = EscalationStatus.RESOLVED
            escalation.resolved_at = resolved_at
            self._save_escalation(escalation)

        self._save_resolution(resolution)
        return resolution

    def get_escalation(self, escalation_id: str) -> Optional[Escalation]:
        """Get escalation by ID.

        Args:
            escalation_id: Escalation identifier

        Returns:
            Escalation if found, None otherwise
        """
        file_path = self.storage_path / f"{escalation_id}.json"
        if not file_path.exists():
            return None

        try:
            with open(file_path) as f:
                data = json.load(f)
            return self._dict_to_escalation(data)
        except Exception:
            return None

    def list_escalations(
        self,
        session_id: Optional[str] = None,
        status: Optional[EscalationStatus] = None,
        priority: Optional[EscalationPriority] = None
    ) -> list[Escalation]:
        """List escalations with filters.

        Args:
            session_id: Filter by session
            status: Filter by status
            priority: Filter by priority

        Returns:
            List of matching escalations
        """
        escalations = []

        for file_path in self.storage_path.glob("esc-*.json"):
            try:
                with open(file_path) as f:
                    data = json.load(f)
                escalation = self._dict_to_escalation(data)

                # Apply filters
                if session_id and escalation.session_id != session_id:
                    continue
                if status and escalation.status != status:
                    continue
                if priority and escalation.priority != priority:
                    continue

                escalations.append(escalation)
            except Exception:
                continue

        return escalations

    def get_pending_escalations(
        self,
        session_id: Optional[str] = None
    ) -> list[Escalation]:
        """Get all unresolved escalations.

        Args:
            session_id: Optional session filter

        Returns:
            List of pending escalations
        """
        return self.list_escalations(
            session_id=session_id,
            status=EscalationStatus.PENDING
        )

    def check_timeouts(self) -> list[Escalation]:
        """Check and resolve expired escalations.

        Returns:
            List of expired escalations
        """
        expired = []
        now = datetime.now()

        for escalation in self.list_escalations(status=EscalationStatus.PENDING):
            if escalation.timeout_seconds is not None:
                elapsed = (now - escalation.created_at).total_seconds()
                if elapsed >= escalation.timeout_seconds:
                    escalation.status = EscalationStatus.EXPIRED
                    escalation.resolved_at = now
                    self._save_escalation(escalation)
                    expired.append(escalation)

        return expired

    def cancel_escalation(self, escalation_id: str, reason: str) -> bool:
        """Cancel a pending escalation.

        Args:
            escalation_id: Escalation to cancel
            reason: Reason for cancellation

        Returns:
            True if cancellation succeeded
        """
        escalation = self.get_escalation(escalation_id)
        if not escalation:
            return False

        if escalation.status not in [EscalationStatus.PENDING, EscalationStatus.ACKNOWLEDGED]:
            return False

        escalation.status = EscalationStatus.CANCELLED
        self._save_escalation(escalation)
        return True

    def _save_escalation(self, escalation: Escalation) -> None:
        """Save escalation to storage."""
        file_path = self.storage_path / f"{escalation.id}.json"
        data = self._escalation_to_dict(escalation)

        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)

    def _save_resolution(self, resolution: EscalationResolution) -> None:
        """Save resolution to storage."""
        file_path = self.storage_path / f"{resolution.escalation_id}_resolution.json"
        data = {
            "escalation_id": resolution.escalation_id,
            "resolution_type": resolution.resolution_type.name,
            "decision": resolution.decision,
            "resolved_at": resolution.resolved_at.isoformat(),
            "notes": resolution.notes,
            "resolved_by": resolution.resolved_by
        }

        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2)

    def _escalation_to_dict(self, escalation: Escalation) -> dict:
        """Convert escalation to dict for storage."""
        return {
            "id": escalation.id,
            "session_id": escalation.session_id,
            "created_at": escalation.created_at.isoformat(),
            "priority": escalation.priority.name,
            "status": escalation.status.name,
            "reason": escalation.reason,
            "context": escalation.context,
            "recommended_actions": escalation.recommended_actions,
            "timeout_seconds": escalation.timeout_seconds,
            "acknowledged_at": escalation.acknowledged_at.isoformat() if escalation.acknowledged_at else None,
            "resolved_at": escalation.resolved_at.isoformat() if escalation.resolved_at else None
        }

    def _dict_to_escalation(self, data: dict) -> Escalation:
        """Convert dict to escalation object."""
        return Escalation(
            id=data["id"],
            session_id=data["session_id"],
            created_at=datetime.fromisoformat(data["created_at"]),
            priority=EscalationPriority[data["priority"]],
            status=EscalationStatus[data["status"]],
            reason=data["reason"],
            context=data["context"],
            recommended_actions=data["recommended_actions"],
            timeout_seconds=data.get("timeout_seconds"),
            acknowledged_at=datetime.fromisoformat(data["acknowledged_at"]) if data.get("acknowledged_at") else None,
            resolved_at=datetime.fromisoformat(data["resolved_at"]) if data.get("resolved_at") else None
        )
