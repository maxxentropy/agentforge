# @spec_file: .agentforge/specs/harness-v1.yaml
# @spec_id: harness-v1
# @component_id: tools-harness-tool_registry
# @test_path: tests/unit/harness/test_tool_registry.py

# Generated by AgentForge
# Spec: tool_selector
# Phase: green
# Date: 2025-12-31 05:26:10 UTC

from pathlib import Path
from typing import Optional, Dict, List
import yaml

from .tool_domain import ToolDefinition, ToolProfile, DomainTools


class DuplicateToolError(Exception):
    """Raised when registering a tool with an existing name."""
    pass


class ToolRegistry:
    """Central registry for tool definitions and profiles."""
    
    def __init__(self, config_path: Optional[Path] = None):
        """Initialize registry with optional config path."""
        self._tools: Dict[str, ToolDefinition] = {}
        self._profiles: Dict[tuple[str, str], ToolProfile] = {}  # (workflow, phase) -> profile
        self._domain_tools: Dict[str, DomainTools] = {}
        
        if config_path and config_path.exists():
            self.load_from_yaml(config_path)
    
    def register_tool(self, tool: ToolDefinition) -> None:
        """Register a tool definition."""
        if tool.name in self._tools:
            raise DuplicateToolError(f"Tool '{tool.name}' already exists")
        self._tools[tool.name] = tool
    
    def register_profile(self, profile: ToolProfile) -> None:
        """Register a workflow phase profile."""
        key = (profile.workflow, profile.phase)
        self._profiles[key] = profile
    
    def register_domain_tools(self, domain: str, tools: List[str]) -> None:
        """Register domain-specific tools."""
        # Create a DomainTools instance with empty detection patterns
        domain_tools = DomainTools(
            domain=domain,
            tools=tools,
            detection_patterns=[]
        )
        self._domain_tools[domain] = domain_tools
    
    def get_tool(self, name: str) -> Optional[ToolDefinition]:
        """Get tool definition by name."""
        return self._tools.get(name)
    
    def get_profile(self, workflow: str, phase: str) -> Optional[ToolProfile]:
        """Get profile for workflow/phase combination."""
        key = (workflow, phase)
        return self._profiles.get(key)
    
    def list_tools(self) -> List[str]:
        """List all registered tool names."""
        return list(self._tools.keys())
    
    def list_profiles(self) -> List[ToolProfile]:
        """List all registered profiles."""
        return list(self._profiles.values())

    def get_base_tools(self) -> List[ToolDefinition]:
        """Get tools marked as base tools (category='base' or always available)."""
        return [t for t in self._tools.values() if t.category == "base" or t.category == "file"]

    def get_domain_tools(self, domain: str) -> Optional[DomainTools]:
        """Get domain tools for a specific domain."""
        return self._domain_tools.get(domain)
    
    def load_from_yaml(self, path: Path) -> None:
        """Load tools and profiles from YAML config."""
        with open(path, 'r') as f:
            data = yaml.safe_load(f)
        
        # Load tools
        if 'tools' in data:
            for tool_data in data['tools']:
                tool = ToolDefinition.from_dict(tool_data)
                # Don't raise error for duplicates when loading from YAML
                self._tools[tool.name] = tool
        
        # Load profiles
        if 'profiles' in data:
            for profile_data in data['profiles']:
                profile = ToolProfile.from_dict(profile_data)
                key = (profile.workflow, profile.phase)
                self._profiles[key] = profile
        
        # Load domain tools
        if 'domain_tools' in data:
            for domain, domain_data in data['domain_tools'].items():
                domain_tools = DomainTools(
                    domain=domain,
                    tools=domain_data.get('tools', []),
                    detection_patterns=domain_data.get('detection_patterns', [])
                )
                self._domain_tools[domain] = domain_tools
    
    def save_to_yaml(self, path: Path) -> None:
        """Save current registry to YAML."""
        data = {
            'tools': [tool.to_dict() for tool in self._tools.values()],
            'profiles': [profile.to_dict() for profile in self._profiles.values()],
            'domain_tools': {
                domain: {
                    'tools': dt.tools,
                    'detection_patterns': dt.detection_patterns
                }
                for domain, dt in self._domain_tools.items()
            }
        }
        
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            yaml.safe_dump(data, f, default_flow_style=False, sort_keys=True)
