# Generated by AgentForge
# Spec: agent_monitor
# Phase: green
# Date: 2025-12-31 05:35:32 UTC

from datetime import datetime
from typing import Optional, List, Dict, Any
from collections import deque, defaultdict
import re

from .monitor_domain import (
    Observation, ObservationType, HealthStatus, Recommendation,
    LoopDetection, ThrashingDetection, AgentHealth
)


class MonitorConfig:
    def __init__(
        self,
        history_window: int = 100,
        loop_threshold: int = 3,
        drift_threshold: float = 0.5,
        thrash_threshold: int = 3,
        stall_threshold: int = 5
    ):
        self.history_window = history_window
        self.loop_threshold = loop_threshold
        self.drift_threshold = drift_threshold
        self.thrash_threshold = thrash_threshold
        self.stall_threshold = stall_threshold


class AgentMonitor:
    def __init__(self, config: Optional[MonitorConfig] = None):
        self.config = config or MonitorConfig()
        self.observations = deque(maxlen=self.config.history_window)
        self.file_modifications: Dict[str, List[datetime]] = defaultdict(list)
        
    def observe_action(self, action: str, details: Optional[dict] = None):
        """Record an agent action"""
        data = {"action": action}
        if details is not None:
            data["details"] = details
        observation = Observation(
            type=ObservationType.ACTION,
            timestamp=datetime.now(),
            data=data,
            context=None
        )
        self.observations.append(observation)

        # Track file modifications for thrashing detection
        if details and "file" in details:
            file_path = details["file"]
            self.file_modifications[file_path].append(datetime.now())
        
    def observe_output(self, output: str, output_type: str):
        """Record agent output"""
        observation = Observation(
            type=ObservationType.OUTPUT,
            timestamp=datetime.now(),
            data={"output": output, "output_type": output_type},
            context=None
        )
        self.observations.append(observation)
        
        # Track file modifications for thrashing detection
        if output_type == "file" and "path" in output:
            file_path = output
            self.file_modifications[file_path].append(datetime.now())
            
    def observe_verification(self, passed: bool, details: Optional[dict] = None):
        """Record verification result"""
        data = {"passed": passed}
        if details is not None:
            data["details"] = details
        observation = Observation(
            type=ObservationType.VERIFICATION,
            timestamp=datetime.now(),
            data=data,
            context=None
        )
        self.observations.append(observation)
        
    def observe_state_change(self, old_state: str, new_state: str):
        """Record state transition"""
        observation = Observation(
            type=ObservationType.STATE_CHANGE,
            timestamp=datetime.now(),
            data={"old_state": old_state, "new_state": new_state},
            context=None
        )
        self.observations.append(observation)
        
    def observe_error(self, error_type: str, message: str, details: Optional[dict] = None):
        """Record an error occurrence"""
        observation = Observation(
            type=ObservationType.ERROR,
            timestamp=datetime.now(),
            data={"error_type": error_type, "message": message, "details": details or {}},
            context=None
        )
        self.observations.append(observation)
        
    def detect_loop(self) -> Optional[LoopDetection]:
        """Check for repetitive action patterns"""
        if len(self.observations) < self.config.loop_threshold:
            return LoopDetection(detected=False)
            
        # Check for consecutive identical actions
        recent_actions = [obs for obs in list(self.observations)[-10:] 
                         if obs.type == ObservationType.ACTION]
        
        if len(recent_actions) >= self.config.loop_threshold:
            # Check for consecutive identical actions
            consecutive_count = 1
            last_action = recent_actions[-1].data.get("action", "")
            loop_observations = [recent_actions[-1]]
            
            for i in range(len(recent_actions) - 2, -1, -1):
                current_action = recent_actions[i].data.get("action", "")
                if current_action == last_action:
                    consecutive_count += 1
                    loop_observations.insert(0, recent_actions[i])
                else:
                    break
                    
            if consecutive_count >= self.config.loop_threshold:
                return LoopDetection(
                    detected=True,
                    pattern=f"Repeated action: {last_action}",
                    count=consecutive_count,
                    observations=loop_observations
                )
        
        # Check for repeated errors
        recent_errors = [obs for obs in list(self.observations)[-10:] 
                        if obs.type == ObservationType.ERROR]
        
        if len(recent_errors) >= self.config.loop_threshold:
            error_counts = defaultdict(int)
            for error_obs in recent_errors:
                error_key = error_obs.data.get("error_type", "")
                error_counts[error_key] += 1
                
            for error_type, count in error_counts.items():
                if count >= self.config.loop_threshold:
                    error_observations = [obs for obs in recent_errors 
                                        if obs.data.get("error_type") == error_type]
                    return LoopDetection(
                        detected=True,
                        pattern=f"Repeated error: {error_type}",
                        count=count,
                        observations=error_observations
                    )
        
        # Check for state cycles
        recent_states = [obs for obs in list(self.observations)[-10:] 
                        if obs.type == ObservationType.STATE_CHANGE]
        
        if len(recent_states) >= 4:  # Need at least A->B->A->B
            states = [obs.data.get("new_state", "") for obs in recent_states[-4:]]
            if len(states) >= 4 and states[0] == states[2] and states[1] == states[3] and states[0] != states[1]:
                return LoopDetection(
                    detected=True,
                    pattern=f"State cycle: {states[0]} <-> {states[1]}",
                    count=2,
                    observations=recent_states[-4:]
                )
        
        return LoopDetection(detected=False)
        
    def detect_drift(self, original_task: str) -> float:
        """Calculate drift score from original task"""
        if not original_task:
            return 0.0

        def extract_keywords(text: str) -> set:
            """Extract keywords, splitting on underscores and filtering short words."""
            # First replace underscores with spaces, then extract words
            normalized = text.lower().replace('_', ' ')
            words = re.findall(r'\b\w+\b', normalized)
            return {word for word in words if len(word) > 2}

        # Extract keywords from original task
        original_keywords = extract_keywords(original_task)

        if not original_keywords:
            return 0.0

        # Extract keywords from recent observations
        recent_text = []
        for obs in list(self.observations)[-20:]:  # Look at recent observations
            if obs.type == ObservationType.ACTION:
                recent_text.append(obs.data.get("action", ""))
            elif obs.type == ObservationType.OUTPUT:
                recent_text.append(obs.data.get("output", ""))

        if not recent_text:
            return 0.0

        recent_keywords = set()
        for text in recent_text:
            recent_keywords.update(extract_keywords(text))

        if not recent_keywords:
            return 1.0  # Complete drift if no keywords found

        # Calculate overlap ratio (how much of original task is covered)
        # Using overlap coefficient: |A âˆ© B| / min(|A|, |B|)
        # This is more lenient than Jaccard for unequal set sizes
        intersection = len(original_keywords & recent_keywords)

        if intersection == 0:
            return 1.0  # No overlap means complete drift

        # Use overlap coefficient normalized by original keywords
        overlap_ratio = intersection / len(original_keywords)
        drift_score = 1.0 - overlap_ratio

        return min(1.0, max(0.0, drift_score))
        
    def detect_thrashing(self) -> Optional[ThrashingDetection]:
        """Check for back-and-forth patterns"""
        # Check file modification thrashing
        thrashing_files = []
        max_alternations = 0
        
        for file_path, modifications in self.file_modifications.items():
            if len(modifications) >= self.config.thrash_threshold:
                thrashing_files.append(file_path)
                # Simple alternation count based on modification frequency
                max_alternations = max(max_alternations, len(modifications))
                
        if thrashing_files:
            return ThrashingDetection(
                detected=True,
                pattern=f"Files modified repeatedly: {', '.join(thrashing_files[:3])}",
                affected_files=thrashing_files,
                alternation_count=max_alternations
            )
            
        # Check for alternating states
        recent_states = [obs for obs in list(self.observations)[-10:]
                        if obs.type == ObservationType.STATE_CHANGE]

        if len(recent_states) >= self.config.thrash_threshold:
            state_sequence = [obs.data.get("new_state", "") for obs in recent_states]

            # Look for A-B-A-B pattern
            alternation_count = 0
            for i in range(len(state_sequence) - 3):
                if (state_sequence[i] == state_sequence[i+2] and
                    state_sequence[i+1] == state_sequence[i+3] and
                    state_sequence[i] != state_sequence[i+1]):
                    alternation_count += 1

            if alternation_count >= 1:  # Even one complete alternation is concerning
                return ThrashingDetection(
                    detected=True,
                    pattern="State alternation detected",
                    affected_files=[],
                    alternation_count=alternation_count + 1  # Count includes the base pattern
                )
        
        return ThrashingDetection(detected=False)
        
    def get_context_pressure(self, tokens_used: int, token_budget: int) -> float:
        """Calculate context window pressure"""
        if token_budget <= 0:
            return 1.0
        return min(1.0, max(0.0, tokens_used / token_budget))
        
    def get_progress_score(self) -> float:
        """Calculate progress based on verifications"""
        recent_verifications = [obs for obs in list(self.observations)[-20:]
                              if obs.type == ObservationType.VERIFICATION]

        if not recent_verifications:
            return 0.5  # Neutral - no verifications yet to measure
            
        successes = sum(1 for obs in recent_verifications 
                       if obs.data.get("passed", False))
        total = len(recent_verifications)
        
        if total == 0:
            return 0.5
            
        base_score = successes / total
        
        # Bonus for recent success trend
        if len(recent_verifications) >= 3:
            recent_three = recent_verifications[-3:]
            recent_successes = sum(1 for obs in recent_three 
                                 if obs.data.get("passed", False))
            if recent_successes == 3:
                base_score = min(1.0, base_score + 0.1)
                
        return base_score
        
    def get_health(
        self,
        original_task: Optional[str] = None,
        tokens_used: int = 0,
        token_budget: int = 100000
    ) -> AgentHealth:
        """Complete health assessment"""
        issues = []

        # Run all detections
        loop_detection = self.detect_loop()
        thrashing_detection = self.detect_thrashing()
        drift_score = self.detect_drift(original_task) if original_task else 0.0
        context_pressure = self.get_context_pressure(tokens_used, token_budget)
        progress_score = self.get_progress_score()

        # Collect all issues and determine worst status
        status = HealthStatus.HEALTHY
        recommendation = Recommendation.CONTINUE

        # Check for critical conditions (collect ALL, don't short-circuit)
        critical_found = False

        if loop_detection.detected and loop_detection.count >= 5:
            status = HealthStatus.CRITICAL
            recommendation = Recommendation.ABORT
            issues.append(f"Severe loop detected: {loop_detection.pattern}")
            critical_found = True

        if drift_score > 0.5:
            status = HealthStatus.CRITICAL
            if recommendation != Recommendation.ABORT:
                recommendation = Recommendation.ESCALATE
            issues.append(f"High drift from original task (score: {drift_score:.2f})")
            critical_found = True

        if thrashing_detection.detected and thrashing_detection.alternation_count >= 5:
            status = HealthStatus.CRITICAL
            if recommendation != Recommendation.ABORT:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Severe thrashing detected: {thrashing_detection.pattern}")
            critical_found = True

        if context_pressure > 0.95:
            status = HealthStatus.CRITICAL
            if recommendation != Recommendation.ABORT:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Critical context pressure: {context_pressure:.2f}")
            critical_found = True

        if progress_score < 0.1:
            status = HealthStatus.CRITICAL
            if recommendation != Recommendation.ABORT:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Very low progress score: {progress_score:.2f}")
            critical_found = True

        # Check for degraded conditions (only if not critical)
        if not critical_found:
            degraded_found = False

            if loop_detection.detected and loop_detection.count < 5:
                status = HealthStatus.DEGRADED
                recommendation = Recommendation.CHECKPOINT
                issues.append(f"Loop detected: {loop_detection.pattern}")
                degraded_found = True

            if 0.3 <= drift_score <= 0.5:
                status = HealthStatus.DEGRADED
                recommendation = Recommendation.CHECKPOINT
                issues.append(f"Moderate drift detected (score: {drift_score:.2f})")
                degraded_found = True

            if thrashing_detection.detected and thrashing_detection.alternation_count < 5:
                status = HealthStatus.DEGRADED
                recommendation = Recommendation.CHECKPOINT
                issues.append(f"Thrashing detected: {thrashing_detection.pattern}")
                degraded_found = True

            if 0.8 <= context_pressure <= 0.95:
                status = HealthStatus.DEGRADED
                recommendation = Recommendation.CHECKPOINT
                issues.append(f"High context pressure: {context_pressure:.2f}")
                degraded_found = True

            if 0.1 <= progress_score <= 0.3:
                status = HealthStatus.DEGRADED
                recommendation = Recommendation.CHECKPOINT
                issues.append(f"Low progress score: {progress_score:.2f}")

        return AgentHealth(
            status=status,
            issues=issues,
            recommendation=recommendation,
            loop_detection=loop_detection if loop_detection.detected else None,
            thrashing_detection=thrashing_detection if thrashing_detection.detected else None,
            drift_score=drift_score,
            context_pressure=context_pressure,
            progress_score=progress_score
        )
        
    def clear_history(self):
        """Clear observation history"""
        self.observations.clear()
        self.file_modifications.clear()
        
    def get_recent_observations(
        self,
        count: int = 10,
        type_filter: Optional[ObservationType] = None
    ) -> List[Observation]:
        """Get recent observations (most recent first)"""
        observations = list(self.observations)

        if type_filter:
            observations = [obs for obs in observations if obs.type == type_filter]

        # Return most recent first
        recent = observations[-count:] if observations else []
        return list(reversed(recent))
