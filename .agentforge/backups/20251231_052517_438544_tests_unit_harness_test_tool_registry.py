# Generated by AgentForge
# Spec: tool_selector
# Phase: red
# Date: 2025-12-31 05:24:02 UTC

"""Tests for the ToolRegistry class.

These tests verify the central registry functionality for tool definitions and profiles.
All tests should initially fail since the implementation doesn't exist yet.
"""

import pytest
from pathlib import Path
from unittest.mock import Mock, patch, mock_open
import yaml

from tools.harness.tool_registry import ToolRegistry, DuplicateToolError
from tools.harness.tool_domain import ToolDefinition, ToolProfile, DomainTools


class TestToolRegistryInit:
    """Test ToolRegistry initialization."""
    
    def test_init_without_config_path_creates_empty_registry(self):
        """Test that initializing without config path creates an empty registry."""
        registry = ToolRegistry()
        
        assert registry is not None
        assert registry.list_tools() == []
        assert registry.list_profiles() == []
    
    def test_init_with_config_path_loads_configuration(self):
        """Test that initializing with config path loads the configuration."""
        config_path = Path("test_config.yaml")
        
        with patch.object(ToolRegistry, 'load_from_yaml') as mock_load:
            registry = ToolRegistry(config_path=config_path)
            mock_load.assert_called_once_with(config_path)


class TestToolRegistryRegisterTool:
    """Test tool registration functionality."""
    
    def test_register_tool_adds_tool_to_registry(self):
        """Test that registering a tool adds it to the registry."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="test_tool",
            description="A test tool",
            parameters={},
            category="test"
        )
        
        registry.register_tool(tool)
        
        assert "test_tool" in registry.list_tools()
        assert registry.get_tool("test_tool") == tool
    
    def test_register_tool_with_duplicate_name_raises_error(self):
        """Test that registering a tool with existing name raises DuplicateToolError."""
        registry = ToolRegistry()
        tool1 = ToolDefinition(
            name="duplicate_tool",
            description="First tool",
            parameters={},
            category="test"
        )
        tool2 = ToolDefinition(
            name="duplicate_tool",
            description="Second tool",
            parameters={},
            category="test"
        )
        
        registry.register_tool(tool1)
        
        with pytest.raises(DuplicateToolError):
            registry.register_tool(tool2)
    
    def test_register_tool_with_complex_parameters(self):
        """Test registering a tool with complex parameter schema."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="complex_tool",
            description="A complex tool",
            parameters={
                "type": "object",
                "properties": {
                    "file_path": {"type": "string"},
                    "options": {"type": "array", "items": {"type": "string"}}
                },
                "required": ["file_path"]
            },
            category="file",
            requires_approval=True,
            handler="complex_handler"
        )
        
        registry.register_tool(tool)
        
        retrieved_tool = registry.get_tool("complex_tool")
        assert retrieved_tool.requires_approval is True
        assert retrieved_tool.handler == "complex_handler"
        assert retrieved_tool.parameters["required"] == ["file_path"]


class TestToolRegistryRegisterProfile:
    """Test profile registration functionality."""
    
    def test_register_profile_adds_profile_to_registry(self):
        """Test that registering a profile adds it to the registry."""
        registry = ToolRegistry()
        profile = ToolProfile(
            workflow="test_workflow",
            phase="test_phase",
            tools=["tool1", "tool2"],
            description="Test profile"
        )
        
        registry.register_profile(profile)
        
        profiles = registry.list_profiles()
        assert len(profiles) == 1
        assert profiles[0] == profile
        
        retrieved_profile = registry.get_profile("test_workflow", "test_phase")
        assert retrieved_profile == profile
    
    def test_register_profile_overwrites_existing_workflow_phase(self):
        """Test that registering a profile overwrites existing workflow/phase combination."""
        registry = ToolRegistry()
        profile1 = ToolProfile(
            workflow="workflow",
            phase="phase",
            tools=["tool1"],
            description="First profile"
        )
        profile2 = ToolProfile(
            workflow="workflow",
            phase="phase",
            tools=["tool2"],
            description="Second profile"
        )
        
        registry.register_profile(profile1)
        registry.register_profile(profile2)
        
        retrieved_profile = registry.get_profile("workflow", "phase")
        assert retrieved_profile == profile2
        assert retrieved_profile.tools == ["tool2"]


class TestToolRegistryRegisterDomainTools:
    """Test domain tools registration functionality."""
    
    def test_register_domain_tools_stores_domain_mapping(self):
        """Test that registering domain tools stores the domain mapping."""
        registry = ToolRegistry()
        tools = ["python_tool1", "python_tool2"]
        
        registry.register_domain_tools("python", tools)
        
        # This would need to be verified through get_domain_tools or similar method
        # For now, we'll test that it doesn't raise an error
        assert True  # Placeholder - actual verification depends on implementation
    
    def test_register_domain_tools_overwrites_existing_domain(self):
        """Test that registering domain tools overwrites existing domain."""
        registry = ToolRegistry()
        
        registry.register_domain_tools("python", ["old_tool"])
        registry.register_domain_tools("python", ["new_tool"])
        
        # Verification would depend on implementation details
        assert True  # Placeholder


class TestToolRegistryGetTool:
    """Test tool retrieval functionality."""
    
    def test_get_tool_returns_registered_tool(self):
        """Test that get_tool returns a previously registered tool."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="existing_tool",
            description="An existing tool",
            parameters={},
            category="test"
        )
        registry.register_tool(tool)
        
        result = registry.get_tool("existing_tool")
        
        assert result == tool
    
    def test_get_tool_returns_none_for_nonexistent_tool(self):
        """Test that get_tool returns None for non-existent tool."""
        registry = ToolRegistry()
        
        result = registry.get_tool("nonexistent_tool")
        
        assert result is None
    
    def test_get_tool_case_sensitive(self):
        """Test that get_tool is case sensitive."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="CaseSensitive",
            description="A case sensitive tool",
            parameters={},
            category="test"
        )
        registry.register_tool(tool)
        
        assert registry.get_tool("CaseSensitive") == tool
        assert registry.get_tool("casesensitive") is None
        assert registry.get_tool("CASESENSITIVE") is None


class TestToolRegistryGetProfile:
    """Test profile retrieval functionality."""
    
    def test_get_profile_returns_registered_profile(self):
        """Test that get_profile returns a previously registered profile."""
        registry = ToolRegistry()
        profile = ToolProfile(
            workflow="test_workflow",
            phase="test_phase",
            tools=["tool1", "tool2"]
        )
        registry.register_profile(profile)
        
        result = registry.get_profile("test_workflow", "test_phase")
        
        assert result == profile
    
    def test_get_profile_returns_none_for_nonexistent_profile(self):
        """Test that get_profile returns None for non-existent profile."""
        registry = ToolRegistry()
        
        result = registry.get_profile("nonexistent_workflow", "nonexistent_phase")
        
        assert result is None
    
    def test_get_profile_returns_none_for_partial_match(self):
        """Test that get_profile returns None when only workflow or phase matches."""
        registry = ToolRegistry()
        profile = ToolProfile(
            workflow="existing_workflow",
            phase="existing_phase",
            tools=["tool1"]
        )
        registry.register_profile(profile)
        
        assert registry.get_profile("existing_workflow", "wrong_phase") is None
        assert registry.get_profile("wrong_workflow", "existing_phase") is None


class TestToolRegistryListMethods:
    """Test list functionality."""
    
    def test_list_tools_returns_empty_list_for_empty_registry(self):
        """Test that list_tools returns empty list for empty registry."""
        registry = ToolRegistry()
        
        result = registry.list_tools()
        
        assert result == []
    
    def test_list_tools_returns_all_registered_tool_names(self):
        """Test that list_tools returns all registered tool names."""
        registry = ToolRegistry()
        tools = [
            ToolDefinition(name="tool1", description="Tool 1", parameters={}, category="test"),
            ToolDefinition(name="tool2", description="Tool 2", parameters={}, category="test"),
            ToolDefinition(name="tool3", description="Tool 3", parameters={}, category="test")
        ]
        
        for tool in tools:
            registry.register_tool(tool)
        
        result = registry.list_tools()
        
        assert set(result) == {"tool1", "tool2", "tool3"}
        assert len(result) == 3
    
    def test_list_profiles_returns_empty_list_for_empty_registry(self):
        """Test that list_profiles returns empty list for empty registry."""
        registry = ToolRegistry()
        
        result = registry.list_profiles()
        
        assert result == []
    
    def test_list_profiles_returns_all_registered_profiles(self):
        """Test that list_profiles returns all registered profiles."""
        registry = ToolRegistry()
        profiles = [
            ToolProfile(workflow="workflow1", phase="phase1", tools=["tool1"]),
            ToolProfile(workflow="workflow1", phase="phase2", tools=["tool2"]),
            ToolProfile(workflow="workflow2", phase="phase1", tools=["tool3"])
        ]
        
        for profile in profiles:
            registry.register_profile(profile)
        
        result = registry.list_profiles()
        
        assert len(result) == 3
        assert all(profile in result for profile in profiles)


class TestToolRegistryLoadFromYaml:
    """Test YAML loading functionality."""
    
    def test_load_from_yaml_loads_tools_and_profiles(self):
        """Test that load_from_yaml loads tools and profiles from YAML file."""
        registry = ToolRegistry()
        yaml_content = {
            'tools': [
                {
                    'name': 'yaml_tool',
                    'description': 'Tool from YAML',
                    'parameters': {},
                    'category': 'test',
                    'requires_approval': False
                }
            ],
            'profiles': [
                {
                    'workflow': 'yaml_workflow',
                    'phase': 'yaml_phase',
                    'tools': ['yaml_tool']
                }
            ]
        }
        
        with patch('builtins.open', mock_open(read_data=yaml.dump(yaml_content))):
            with patch('yaml.safe_load', return_value=yaml_content):
                registry.load_from_yaml(Path("test.yaml"))
        
        assert "yaml_tool" in registry.list_tools()
        assert registry.get_profile("yaml_workflow", "yaml_phase") is not None
    
    def test_load_from_yaml_handles_missing_file(self):
        """Test that load_from_yaml handles missing file gracefully."""
        registry = ToolRegistry()
        
        with patch('builtins.open', side_effect=FileNotFoundError):
            with pytest.raises(FileNotFoundError):
                registry.load_from_yaml(Path("nonexistent.yaml"))
    
    def test_load_from_yaml_handles_invalid_yaml(self):
        """Test that load_from_yaml handles invalid YAML content."""
        registry = ToolRegistry()
        
        with patch('builtins.open', mock_open(read_data="invalid: yaml: content:")):
            with patch('yaml.safe_load', side_effect=yaml.YAMLError("Invalid YAML")):
                with pytest.raises(yaml.YAMLError):
                    registry.load_from_yaml(Path("invalid.yaml"))


class TestToolRegistrySaveToYaml:
    """Test YAML saving functionality."""
    
    def test_save_to_yaml_writes_tools_and_profiles(self):
        """Test that save_to_yaml writes current registry to YAML file."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="save_tool",
            description="Tool to save",
            parameters={},
            category="test"
        )
        profile = ToolProfile(
            workflow="save_workflow",
            phase="save_phase",
            tools=["save_tool"]
        )
        
        registry.register_tool(tool)
        registry.register_profile(profile)
        
        mock_file = mock_open()
        with patch('builtins.open', mock_file):
            with patch('yaml.dump') as mock_yaml_dump:
                registry.save_to_yaml(Path("output.yaml"))
        
        mock_file.assert_called_once_with(Path("output.yaml"), 'w')
        mock_yaml_dump.assert_called_once()
    
    def test_save_to_yaml_handles_write_error(self):
        """Test that save_to_yaml handles write errors."""
        registry = ToolRegistry()
        
        with patch('builtins.open', side_effect=PermissionError("Cannot write")):
            with pytest.raises(PermissionError):
                registry.save_to_yaml(Path("readonly.yaml"))
    
    def test_save_to_yaml_creates_valid_structure(self):
        """Test that save_to_yaml creates a valid YAML structure."""
        registry = ToolRegistry()
        tool = ToolDefinition(
            name="struct_tool",
            description="Structural tool",
            parameters={"type": "object"},
            category="test",
            requires_approval=True
        )
        registry.register_tool(tool)
        
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('yaml.dump') as mock_yaml_dump:
                registry.save_to_yaml(Path("structure.yaml"))
                
                # Verify the structure passed to yaml.dump
                call_args = mock_yaml_dump.call_args[0][0]
                assert 'tools' in call_args
                assert 'profiles' in call_args
                assert len(call_args['tools']) == 1
                assert call_args['tools'][0]['name'] == 'struct_tool'


class TestToolRegistryIntegration:
    """Integration tests for ToolRegistry."""
    
    def test_full_workflow_register_retrieve_save_load(self):
        """Test complete workflow of registering, retrieving, saving, and loading."""
        # Create and populate registry
        registry1 = ToolRegistry()
        
        tool = ToolDefinition(
            name="integration_tool",
            description="Integration test tool",
            parameters={"type": "object", "properties": {"param": {"type": "string"}}},
            category="integration",
            requires_approval=True
        )
        profile = ToolProfile(
            workflow="integration_workflow",
            phase="integration_phase",
            tools=["integration_tool"],
            description="Integration test profile"
        )
        
        registry1.register_tool(tool)
        registry1.register_profile(profile)
        registry1.register_domain_tools("integration_domain", ["integration_tool"])
        
        # Verify registration
        assert registry1.get_tool("integration_tool") == tool
        assert registry1.get_profile("integration_workflow", "integration_phase") == profile
        
        # Save to YAML
        yaml_data = {
            'tools': [tool.to_dict()],
            'profiles': [profile.to_dict()],
            'domain_tools': {
                'integration_domain': ['integration_tool']
            }
        }
        
        # Load into new registry
        registry2 = ToolRegistry()
        with patch('builtins.open', mock_open(read_data=yaml.dump(yaml_data))):
            with patch('yaml.safe_load', return_value=yaml_data):
                registry2.load_from_yaml(Path("integration.yaml"))
        
        # Verify loaded data matches original
        loaded_tool = registry2.get_tool("integration_tool")
        loaded_profile = registry2.get_profile("integration_workflow", "integration_phase")
        
        assert loaded_tool is not None
        assert loaded_tool.name == tool.name
        assert loaded_tool.description == tool.description
        assert loaded_profile is not None
        assert loaded_profile.workflow == profile.workflow
        assert loaded_profile.phase == profile.phase
