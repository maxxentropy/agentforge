# @spec_file: .agentforge/specs/harness-v1.yaml
# @spec_id: harness-v1
# @component_id: tools-harness-escalation_manager
# @impl_path: tools/harness/escalation_manager.py

# Generated by AgentForge
# Spec: human_escalation
# Phase: red
# Date: 2025-12-31

"""
Tests for EscalationManager - manages escalation lifecycle.
These tests verify escalation creation, acknowledgment, resolution, and timeout handling.
"""

import pytest
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import Mock, patch
import tempfile

from tools.harness.escalation_manager import EscalationManager
from tools.harness.escalation_domain import (
    EscalationPriority,
    EscalationStatus,
    EscalationChannel,
    ResolutionType,
    Escalation,
    EscalationResolution
)


class TestEscalationManagerInit:
    """Test EscalationManager initialization."""

    def test_init_with_storage_path_creates_manager(self):
        """Test that EscalationManager can be initialized with storage path."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = EscalationManager(storage_path=storage_path)

            assert manager is not None
            assert manager.storage_path == storage_path
            assert manager.default_timeout == 3600  # default

    def test_init_with_custom_timeout_sets_default(self):
        """Test that EscalationManager respects custom default_timeout."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir)
            manager = EscalationManager(storage_path=storage_path, default_timeout=7200)

            assert manager.default_timeout == 7200

    def test_init_creates_storage_directory_if_not_exists(self):
        """Test that EscalationManager creates storage directory."""
        with tempfile.TemporaryDirectory() as temp_dir:
            storage_path = Path(temp_dir) / "escalations"
            manager = EscalationManager(storage_path=storage_path)

            assert storage_path.exists()
            assert storage_path.is_dir()

    def test_init_with_channels_sets_active_channels(self):
        """Test that EscalationManager accepts channel configuration."""
        with tempfile.TemporaryDirectory() as temp_dir:
            channels = [EscalationChannel.CLI, EscalationChannel.FILE]
            manager = EscalationManager(
                storage_path=Path(temp_dir),
                channels=channels
            )

            assert manager.channels == channels


class TestCreateEscalation:
    """Test escalation creation functionality."""

    @pytest.fixture
    def manager(self):
        """Create an EscalationManager for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            yield EscalationManager(storage_path=Path(temp_dir))

    def test_create_escalation_with_minimal_params(self, manager):
        """Test creating escalation with only required parameters."""
        escalation = manager.create_escalation(
            session_id="session-123",
            reason="Test escalation",
            context={"key": "value"}
        )

        assert isinstance(escalation, Escalation)
        assert escalation.session_id == "session-123"
        assert escalation.reason == "Test escalation"
        assert escalation.context == {"key": "value"}
        assert escalation.priority == EscalationPriority.MEDIUM  # default
        assert escalation.status == EscalationStatus.PENDING
        assert escalation.id is not None

    def test_create_escalation_with_all_params(self, manager):
        """Test creating escalation with all parameters."""
        escalation = manager.create_escalation(
            session_id="session-456",
            reason="Critical error",
            context={"error": "details"},
            priority=EscalationPriority.CRITICAL,
            recommended_actions=["Action 1", "Action 2"],
            timeout_seconds=7200
        )

        assert escalation.priority == EscalationPriority.CRITICAL
        assert escalation.recommended_actions == ["Action 1", "Action 2"]
        assert escalation.timeout_seconds == 7200

    def test_create_escalation_generates_unique_ids(self, manager):
        """Test that each escalation gets a unique ID."""
        esc1 = manager.create_escalation("session", "reason", {})
        esc2 = manager.create_escalation("session", "reason", {})

        assert esc1.id != esc2.id

    def test_create_escalation_persists_to_storage(self, manager):
        """Test that escalation is saved to storage."""
        escalation = manager.create_escalation(
            session_id="session-persist",
            reason="Persist test",
            context={}
        )

        # Should be retrievable
        retrieved = manager.get_escalation(escalation.id)
        assert retrieved is not None
        assert retrieved.id == escalation.id

    def test_create_escalation_sets_created_at_timestamp(self, manager):
        """Test that creation timestamp is set correctly."""
        before = datetime.now()
        escalation = manager.create_escalation("session", "reason", {})
        after = datetime.now()

        assert before <= escalation.created_at <= after


class TestAcknowledgeEscalation:
    """Test escalation acknowledgment functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_acknowledge_escalation_returns_true(self, manager_with_escalation):
        """Test acknowledging an existing escalation succeeds."""
        manager, escalation = manager_with_escalation

        result = manager.acknowledge_escalation(escalation.id)

        assert result is True

    def test_acknowledge_escalation_updates_status(self, manager_with_escalation):
        """Test that acknowledgment updates escalation status."""
        manager, escalation = manager_with_escalation

        manager.acknowledge_escalation(escalation.id)

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.ACKNOWLEDGED
        assert updated.acknowledged_at is not None

    def test_acknowledge_escalation_with_acknowledged_by(self, manager_with_escalation):
        """Test acknowledgment with user identifier."""
        manager, escalation = manager_with_escalation

        manager.acknowledge_escalation(escalation.id, acknowledged_by="user@example.com")

        # Acknowledgment recorded (implementation may vary)
        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.ACKNOWLEDGED

    def test_acknowledge_nonexistent_escalation_returns_false(self, manager_with_escalation):
        """Test acknowledging nonexistent escalation fails."""
        manager, _ = manager_with_escalation

        result = manager.acknowledge_escalation("nonexistent-id")

        assert result is False


class TestResolveEscalation:
    """Test escalation resolution functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_resolve_escalation_returns_resolution(self, manager_with_escalation):
        """Test resolving an escalation returns resolution object."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="Proceed with operation"
        )

        assert isinstance(resolution, EscalationResolution)
        assert resolution.escalation_id == escalation.id
        assert resolution.resolution_type == ResolutionType.APPROVED
        assert resolution.decision == "Proceed with operation"

    def test_resolve_escalation_updates_status(self, manager_with_escalation):
        """Test that resolution updates escalation status."""
        manager, escalation = manager_with_escalation

        manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="OK"
        )

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.RESOLVED
        assert updated.resolved_at is not None

    def test_resolve_escalation_with_notes(self, manager_with_escalation):
        """Test resolution with additional notes."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.MODIFIED,
            decision="Changed approach",
            notes="Detailed explanation here"
        )

        assert resolution.notes == "Detailed explanation here"

    def test_resolve_escalation_with_resolved_by(self, manager_with_escalation):
        """Test resolution with resolver identifier."""
        manager, escalation = manager_with_escalation

        resolution = manager.resolve_escalation(
            escalation_id=escalation.id,
            resolution_type=ResolutionType.APPROVED,
            decision="OK",
            resolved_by="admin@example.com"
        )

        assert resolution.resolved_by == "admin@example.com"

    def test_resolve_escalation_supports_all_resolution_types(self, manager_with_escalation):
        """Test that all resolution types are supported."""
        manager, _ = manager_with_escalation

        for res_type in ResolutionType:
            esc = manager.create_escalation("session", f"Test {res_type.name}", {})
            resolution = manager.resolve_escalation(
                escalation_id=esc.id,
                resolution_type=res_type,
                decision="Test"
            )
            assert resolution.resolution_type == res_type


class TestGetEscalation:
    """Test escalation retrieval functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={"key": "value"}
            )
            yield manager, escalation

    def test_get_escalation_returns_escalation(self, manager_with_escalation):
        """Test retrieving an existing escalation."""
        manager, escalation = manager_with_escalation

        retrieved = manager.get_escalation(escalation.id)

        assert retrieved is not None
        assert retrieved.id == escalation.id
        assert retrieved.reason == escalation.reason

    def test_get_escalation_nonexistent_returns_none(self, manager_with_escalation):
        """Test retrieving nonexistent escalation returns None."""
        manager, _ = manager_with_escalation

        retrieved = manager.get_escalation("nonexistent-id")

        assert retrieved is None


class TestListEscalations:
    """Test escalation listing functionality."""

    @pytest.fixture
    def manager_with_multiple_escalations(self):
        """Create manager with multiple escalations."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc1 = manager.create_escalation(
                session_id="session-1",
                reason="Low priority",
                context={},
                priority=EscalationPriority.LOW
            )
            esc2 = manager.create_escalation(
                session_id="session-1",
                reason="High priority",
                context={},
                priority=EscalationPriority.HIGH
            )
            esc3 = manager.create_escalation(
                session_id="session-2",
                reason="Medium priority",
                context={},
                priority=EscalationPriority.MEDIUM
            )

            yield manager, [esc1, esc2, esc3]

    def test_list_escalations_returns_all(self, manager_with_multiple_escalations):
        """Test listing all escalations."""
        manager, created = manager_with_multiple_escalations

        escalations = manager.list_escalations()

        assert len(escalations) == 3

    def test_list_escalations_filter_by_session(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by session."""
        manager, _ = manager_with_multiple_escalations

        escalations = manager.list_escalations(session_id="session-1")

        assert len(escalations) == 2
        for esc in escalations:
            assert esc.session_id == "session-1"

    def test_list_escalations_filter_by_status(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by status."""
        manager, created = manager_with_multiple_escalations

        # Resolve one
        manager.resolve_escalation(created[0].id, ResolutionType.APPROVED, "OK")

        pending = manager.list_escalations(status=EscalationStatus.PENDING)
        resolved = manager.list_escalations(status=EscalationStatus.RESOLVED)

        assert len(pending) == 2
        assert len(resolved) == 1

    def test_list_escalations_filter_by_priority(self, manager_with_multiple_escalations):
        """Test listing escalations filtered by priority."""
        manager, _ = manager_with_multiple_escalations

        high = manager.list_escalations(priority=EscalationPriority.HIGH)

        assert len(high) == 1
        assert high[0].priority == EscalationPriority.HIGH


class TestGetPendingEscalations:
    """Test getting pending escalations."""

    @pytest.fixture
    def manager_with_mixed_escalations(self):
        """Create manager with pending and resolved escalations."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            pending1 = manager.create_escalation("session-1", "Pending 1", {})
            pending2 = manager.create_escalation("session-2", "Pending 2", {})
            resolved = manager.create_escalation("session-1", "Resolved", {})
            manager.resolve_escalation(resolved.id, ResolutionType.APPROVED, "OK")

            yield manager, [pending1, pending2, resolved]

    def test_get_pending_escalations_returns_only_pending(self, manager_with_mixed_escalations):
        """Test that only pending escalations are returned."""
        manager, _ = manager_with_mixed_escalations

        pending = manager.get_pending_escalations()

        assert len(pending) == 2
        for esc in pending:
            assert esc.status == EscalationStatus.PENDING

    def test_get_pending_escalations_filter_by_session(self, manager_with_mixed_escalations):
        """Test filtering pending escalations by session."""
        manager, _ = manager_with_mixed_escalations

        pending = manager.get_pending_escalations(session_id="session-1")

        assert len(pending) == 1
        assert pending[0].session_id == "session-1"


class TestCheckTimeouts:
    """Test timeout checking functionality."""

    def test_check_timeouts_expires_old_escalations(self):
        """Test that old escalations are marked as expired."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            # Create escalation with very short timeout
            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0  # Immediate timeout
            )

            # Check timeouts
            expired = manager.check_timeouts()

            assert len(expired) >= 1
            updated = manager.get_escalation(esc.id)
            assert updated.status == EscalationStatus.EXPIRED

    def test_check_timeouts_returns_expired_list(self):
        """Test that expired escalations are returned."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0
            )

            expired = manager.check_timeouts()

            expired_ids = [e.id for e in expired]
            assert esc.id in expired_ids

    def test_check_timeouts_ignores_non_pending(self):
        """Test that resolved escalations aren't expired."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            esc = manager.create_escalation(
                session_id="session",
                reason="Test",
                context={},
                timeout_seconds=0
            )
            manager.resolve_escalation(esc.id, ResolutionType.APPROVED, "OK")

            expired = manager.check_timeouts()

            expired_ids = [e.id for e in expired]
            assert esc.id not in expired_ids


class TestCancelEscalation:
    """Test escalation cancellation functionality."""

    @pytest.fixture
    def manager_with_escalation(self):
        """Create manager with an existing escalation."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))
            escalation = manager.create_escalation(
                session_id="session-123",
                reason="Test",
                context={}
            )
            yield manager, escalation

    def test_cancel_escalation_returns_true(self, manager_with_escalation):
        """Test cancelling an existing escalation succeeds."""
        manager, escalation = manager_with_escalation

        result = manager.cancel_escalation(escalation.id, "No longer needed")

        assert result is True

    def test_cancel_escalation_updates_status(self, manager_with_escalation):
        """Test that cancellation updates status."""
        manager, escalation = manager_with_escalation

        manager.cancel_escalation(escalation.id, "Cancelled")

        updated = manager.get_escalation(escalation.id)
        assert updated.status == EscalationStatus.CANCELLED

    def test_cancel_nonexistent_escalation_returns_false(self, manager_with_escalation):
        """Test cancelling nonexistent escalation fails."""
        manager, _ = manager_with_escalation

        result = manager.cancel_escalation("nonexistent-id", "reason")

        assert result is False

    def test_cancel_resolved_escalation_returns_false(self, manager_with_escalation):
        """Test cancelling already resolved escalation fails."""
        manager, escalation = manager_with_escalation

        manager.resolve_escalation(escalation.id, ResolutionType.APPROVED, "OK")
        result = manager.cancel_escalation(escalation.id, "reason")

        assert result is False


class TestEscalationManagerIntegration:
    """Integration tests for EscalationManager."""

    def test_full_escalation_lifecycle(self):
        """Test complete escalation lifecycle."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            # Create
            esc = manager.create_escalation(
                session_id="session",
                reason="Integration test",
                context={"test": True}
            )
            assert esc.status == EscalationStatus.PENDING

            # Acknowledge
            manager.acknowledge_escalation(esc.id)
            esc = manager.get_escalation(esc.id)
            assert esc.status == EscalationStatus.ACKNOWLEDGED

            # Resolve
            resolution = manager.resolve_escalation(
                esc.id,
                ResolutionType.APPROVED,
                "Test passed"
            )
            assert resolution.resolution_type == ResolutionType.APPROVED

            esc = manager.get_escalation(esc.id)
            assert esc.status == EscalationStatus.RESOLVED

    def test_multiple_sessions_isolation(self):
        """Test that escalations are properly isolated by session."""
        with tempfile.TemporaryDirectory() as temp_dir:
            manager = EscalationManager(storage_path=Path(temp_dir))

            for i in range(3):
                for j in range(2):
                    manager.create_escalation(f"session-{i}", f"Esc {j}", {})

            for i in range(3):
                session_escs = manager.list_escalations(session_id=f"session-{i}")
                assert len(session_escs) == 2
