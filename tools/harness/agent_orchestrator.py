# Generated by AgentForge
# Spec: agent_orchestrator
# Phase: green (revised)
# Date: 2025-12-31

"""Main orchestrator coordinating all Agent Harness components."""

import time
from datetime import datetime
from pathlib import Path
from typing import Optional, Any, TYPE_CHECKING

from .orchestrator_domain import (
    OrchestratorState,
    ExecutionMode,
    ExecutionResult,
    OrchestratorConfig
)
from .session_domain import SessionState, SessionContext
from .monitor_domain import HealthStatus
from .recovery_domain import RecoveryAttempt
from .escalation_domain import EscalationResolution, ResolutionType

if TYPE_CHECKING:
    from .llm_executor import LLMExecutor
    from .llm_executor_domain import ExecutionContext
    from .execution_context_store import ExecutionContextStore


class AgentOrchestrator:
    """Main orchestrator coordinating all Agent Harness components.

    This orchestrator adapts to the real component APIs:
    - SessionManager: single-session model with load/save
    - MemoryManager: tiered memory with get/set
    - AgentMonitor: observe_* methods and get_health with task context
    - ToolSelector: get_tool_names with workflow/phase/domain
    - LLMExecutor: optional component for agent decision-making
    """

    def __init__(
        self,
        session_manager,
        memory_manager,  # MemoryManager, not MemoryStore
        tool_selector,
        agent_monitor,
        recovery_executor,
        escalation_manager,
        config: Optional[OrchestratorConfig] = None,
        llm_executor: Optional["LLMExecutor"] = None,
        working_dir: Optional[Path] = None,
        execution_store: Optional["ExecutionContextStore"] = None
    ):
        """Initialize orchestrator with all components.

        Args:
            session_manager: Manages agent sessions (SessionManager)
            memory_manager: Handles memory storage (MemoryManager)
            tool_selector: Selects tools for execution (ToolSelector)
            agent_monitor: Monitors agent health (AgentMonitor)
            recovery_executor: Executes recovery strategies (RecoveryExecutor)
            escalation_manager: Manages human escalations (EscalationManager)
            config: Orchestrator configuration
            llm_executor: Optional LLM executor for agent decisions
            working_dir: Working directory for tool execution
            execution_store: Optional store for persisting execution context
        """
        self.session_manager = session_manager
        self.memory_manager = memory_manager
        self.tool_selector = tool_selector
        self.agent_monitor = agent_monitor
        self.recovery_executor = recovery_executor
        self.escalation_manager = escalation_manager
        self.config = config or OrchestratorConfig()
        self.llm_executor = llm_executor
        self.working_dir = working_dir or Path.cwd()

        # Initialize execution store for YAML persistence
        if execution_store is None and llm_executor is not None:
            from .execution_context_store import ExecutionContextStore
            execution_store = ExecutionContextStore(self.working_dir / ".agentforge" / "sessions")
        self.execution_store = execution_store

        # Track session states (orchestrator-specific tracking)
        self._session_states: dict[str, OrchestratorState] = {}
        self._session_iterations: dict[str, int] = {}
        self._session_history: dict[str, list[ExecutionResult]] = {}
        # Store task descriptions per session for health checks
        self._session_tasks: dict[str, str] = {}
        self._session_contexts: dict[str, dict] = {}
        # Store LLM execution contexts per session
        self._llm_contexts: dict[str, "ExecutionContext"] = {}

    def start_session(
        self,
        task_description: str,
        context: Optional[dict] = None,
        execution_mode: Optional[ExecutionMode] = None,
        workflow_type: str = "agent",
        initial_phase: str = "execute",
        token_budget: int = 100000
    ) -> str:
        """Initialize a new agent session.

        Args:
            task_description: Description of the task
            context: Optional context data
            execution_mode: Optional execution mode override
            workflow_type: Workflow type for session
            initial_phase: Initial phase
            token_budget: Token budget for session

        Returns:
            Session ID
        """
        # Create session using actual SessionManager API
        session = self.session_manager.create(
            workflow_type=workflow_type,
            initial_phase=initial_phase,
            token_budget=token_budget
        )

        session_id = session.session_id

        # Initialize orchestrator tracking
        self._session_states[session_id] = OrchestratorState.IDLE
        self._session_iterations[session_id] = 0
        self._session_history[session_id] = []
        self._session_tasks[session_id] = task_description
        self._session_contexts[session_id] = {
            "task_description": task_description,
            "context": context or {},
            "execution_mode": (execution_mode or self.config.execution_mode).name
        }

        # Store initial context in memory if memory_manager supports it
        if context and hasattr(self.memory_manager, 'set'):
            from .memory_domain import MemoryTier
            from datetime import timedelta
            self.memory_manager.set(
                key=f"session:{session_id}:context",
                value=context,
                tier=MemoryTier.SESSION,
                ttl=timedelta(hours=24)
            )

        # Initialize LLM execution context if executor available
        if self.llm_executor:
            self._init_llm_context(
                session_id=session_id,
                task_description=task_description,
                current_phase=initial_phase,
                token_budget=token_budget,
                memory_context=context or {}
            )

        # Save session
        self.session_manager.save()

        return session_id

    def _init_llm_context(
        self,
        session_id: str,
        task_description: str,
        current_phase: str,
        token_budget: int,
        memory_context: dict
    ) -> None:
        """Initialize LLM execution context for a session.

        Args:
            session_id: Session ID
            task_description: Task to execute
            current_phase: Current workflow phase
            token_budget: Token budget
            memory_context: Memory context dict
        """
        from .llm_executor_domain import ExecutionContext

        # Get available tools
        tools = self.get_available_tools(session_id) if hasattr(self, '_session_states') else []

        self._llm_contexts[session_id] = ExecutionContext(
            session_id=session_id,
            task_description=task_description,
            current_phase=current_phase,
            available_tools=tools,
            memory_context=memory_context,
            token_budget=token_budget
        )

    def resume_session(self, session_id: str) -> bool:
        """Resume a paused session.

        Args:
            session_id: Session to resume

        Returns:
            True if successful
        """
        # Load session using actual API
        session = self.session_manager.load(session_id)
        if not session:
            return False

        # Update orchestrator state
        self._session_states[session_id] = OrchestratorState.RUNNING

        # Restore iteration count if not tracked
        if session_id not in self._session_iterations:
            self._session_iterations[session_id] = 0

        if session_id not in self._session_history:
            self._session_history[session_id] = []

        # Resume the session in session manager
        self.session_manager.resume()

        return True

    def execute_step(
        self,
        session_id: str,
        input_data: Optional[dict] = None
    ) -> ExecutionResult:
        """Execute one iteration of agent work.

        Args:
            session_id: Session to execute in
            input_data: Optional input for this step

        Returns:
            Execution result
        """
        start_time = time.time()
        self._session_states[session_id] = OrchestratorState.RUNNING

        # Check for pending escalations
        pending = self.escalation_manager.get_pending_escalations(session_id)
        if pending:
            self._session_states[session_id] = OrchestratorState.WAITING_FOR_HUMAN
            return ExecutionResult(
                task_id=f"{session_id}:step:{self._session_iterations.get(session_id, 0)}",
                success=False,
                output=None,
                error="Waiting for escalation resolution",
                duration_seconds=time.time() - start_time,
                tools_used=[]
            )

        # Get available tools
        tools = self.get_available_tools(session_id)

        # Increment iteration
        self._session_iterations[session_id] = self._session_iterations.get(session_id, 0) + 1
        iteration = self._session_iterations[session_id]

        # Record observation using actual AgentMonitor API
        self.agent_monitor.observe_action(
            action=f"step_execution_{iteration}",
            details={
                "session_id": session_id,
                "iteration": iteration,
                "tools_available": tools,
                "input_data": input_data
            }
        )

        # Check health at intervals
        if iteration % self.config.health_check_interval == 0:
            recovery = self.handle_health_check(session_id)
            if recovery and recovery.result.name == "FAILED":
                self._session_states[session_id] = OrchestratorState.FAILED
                return ExecutionResult(
                    task_id=f"{session_id}:step:{iteration}",
                    success=False,
                    output=None,
                    error="Recovery failed",
                    duration_seconds=time.time() - start_time,
                    tools_used=[]
                )

        # Create checkpoint at intervals
        if self.config.auto_checkpoint and iteration % self.config.checkpoint_interval == 0:
            self._create_checkpoint(session_id)

        # Execute step using LLM executor if available
        if self.llm_executor and session_id in self._llm_contexts:
            result = self._execute_llm_step(session_id, tools, iteration, start_time)
        else:
            # Fallback: no LLM executor, just return placeholder result
            duration = time.time() - start_time
            result = ExecutionResult(
                task_id=f"{session_id}:step:{iteration}",
                success=True,
                output=f"Step {iteration} completed (no LLM executor)",
                error=None,
                duration_seconds=duration,
                tools_used=tools[:2] if tools else []
            )

        # Store in history
        self._session_history.setdefault(session_id, []).append(result)

        return result

    def _execute_llm_step(
        self,
        session_id: str,
        tools: list[str],
        iteration: int,
        start_time: float
    ) -> ExecutionResult:
        """Execute a step using the LLM executor.

        Args:
            session_id: Session ID
            tools: Available tools
            iteration: Current iteration
            start_time: Step start time

        Returns:
            ExecutionResult
        """
        from .llm_executor_domain import ActionType

        llm_context = self._llm_contexts[session_id]
        llm_context.available_tools = tools

        # Execute step via LLM
        step_result = self.llm_executor.execute_step(llm_context)

        duration = time.time() - start_time

        if not step_result.success:
            self._session_states[session_id] = OrchestratorState.FAILED
            return ExecutionResult(
                task_id=f"{session_id}:step:{iteration}",
                success=False,
                output=None,
                error=step_result.error,
                duration_seconds=duration,
                tools_used=[]
            )

        # Record observation for monitoring
        action = step_result.action
        if action:
            self.agent_monitor.observe_output(output=action.reasoning)

            # Check action type for state transitions
            if action.action_type == ActionType.COMPLETE:
                self._session_states[session_id] = OrchestratorState.COMPLETED
            elif action.action_type == ActionType.ESCALATE:
                self._session_states[session_id] = OrchestratorState.WAITING_FOR_HUMAN
                # Create escalation
                from .escalation_domain import EscalationPriority
                self.escalation_manager.create_escalation(
                    session_id=session_id,
                    reason=action.reasoning,
                    context={"iteration": iteration},
                    priority=EscalationPriority.NORMAL
                )
            elif action.action_type == ActionType.ASK_USER:
                self._session_states[session_id] = OrchestratorState.WAITING_FOR_HUMAN

        # Collect tool names used
        tools_used = [r.tool_name for r in step_result.tool_results]

        # Persist context and step result to YAML for auditability
        if self.execution_store:
            try:
                self.execution_store.save_context(llm_context)
                self.execution_store.append_step(session_id, step_result)
            except Exception:
                pass  # Don't fail execution if persistence fails

        return ExecutionResult(
            task_id=f"{session_id}:step:{iteration}",
            success=True,
            output=action.response if action else "Step completed",
            error=None,
            duration_seconds=duration,
            tools_used=tools_used
        )

    def run_until_complete(
        self,
        session_id: str,
        max_iterations: Optional[int] = None
    ) -> ExecutionResult:
        """Run agent until task completion or limit.

        Args:
            session_id: Session to run
            max_iterations: Optional iteration limit override

        Returns:
            Final execution result
        """
        limit = max_iterations or self.config.max_iterations
        last_result = None

        for _ in range(limit):
            result = self.execute_step(session_id)
            last_result = result

            # Check for blocking states
            state = self._session_states.get(session_id, OrchestratorState.IDLE)
            if state in [OrchestratorState.WAITING_FOR_HUMAN, OrchestratorState.PAUSED,
                        OrchestratorState.FAILED, OrchestratorState.COMPLETED]:
                break

            if not result.success:
                break

        return last_result or ExecutionResult(
            task_id=f"{session_id}:final",
            success=False,
            output=None,
            error="No iterations executed",
            duration_seconds=0.0,
            tools_used=[]
        )

    def pause_session(self, session_id: str, reason: str) -> bool:
        """Pause agent execution.

        Args:
            session_id: Session to pause
            reason: Reason for pausing

        Returns:
            True if successful
        """
        # Load the session
        session = self.session_manager.load(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.PAUSED

        # Use SessionManager's pause method
        self.session_manager.pause()

        # Store pause reason in orchestrator context
        if session_id in self._session_contexts:
            self._session_contexts[session_id]["pause_reason"] = reason
            self._session_contexts[session_id]["paused_at"] = datetime.now().isoformat()

        return True

    def get_status(self, session_id: str) -> dict:
        """Get current orchestrator status.

        Args:
            session_id: Session to get status for

        Returns:
            Status dictionary
        """
        # Load session
        session = self.session_manager.load(session_id)

        # Get health using actual API (needs task context)
        task_description = self._session_tasks.get(session_id, "unknown task")
        tokens_used = session.token_budget.tokens_used if session else 0
        token_budget = session.token_budget.total_budget if session else 100000

        health = self.agent_monitor.get_health(
            original_task=task_description,
            tokens_used=tokens_used,
            token_budget=token_budget
        )

        # Get pending escalations
        pending = self.escalation_manager.get_pending_escalations(session_id)

        state = self._session_states.get(session_id, OrchestratorState.IDLE)

        return {
            "state": state.name,
            "iteration_count": self._session_iterations.get(session_id, 0),
            "health_status": health,
            "pending_escalations": len(pending),
            "current_phase": session.current_phase if session else None,
            "tokens_used": tokens_used,
            "token_budget": token_budget
        }

    def get_available_tools(self, session_id: str) -> list[str]:
        """Get tools available for current session.

        Args:
            session_id: Session to get tools for

        Returns:
            List of tool names
        """
        session = self.session_manager.load(session_id)
        workflow = session.workflow_type if session else "agent"
        phase = session.current_phase if session else "execute"

        # Use actual ToolSelector API
        return self.tool_selector.get_tool_names(
            workflow=workflow,
            phase=phase,
            domain=None  # Auto-detect from project
        )

    def handle_health_check(self, session_id: str) -> Optional[RecoveryAttempt]:
        """Check health and trigger recovery if needed.

        Args:
            session_id: Session to check

        Returns:
            Recovery attempt if triggered, None otherwise
        """
        if not self.config.recovery_enabled:
            return None

        # Get health using actual API
        task_description = self._session_tasks.get(session_id, "unknown task")
        session = self.session_manager.load(session_id)
        tokens_used = session.token_budget.tokens_used if session else 0
        token_budget = session.token_budget.total_budget if session else 100000

        health = self.agent_monitor.get_health(
            original_task=task_description,
            tokens_used=tokens_used,
            token_budget=token_budget
        )

        if health.status == HealthStatus.HEALTHY:
            return None

        # Has issues, trigger recovery
        self._session_states[session_id] = OrchestratorState.RECOVERING

        current_state = self._session_contexts.get(session_id, {})

        attempt = self.recovery_executor.execute_recovery(
            health=health,
            session_id=session_id,
            current_state=current_state
        )

        self._session_states[session_id] = OrchestratorState.RUNNING

        return attempt

    def handle_escalation(
        self,
        session_id: str,
        resolution: EscalationResolution
    ) -> bool:
        """Process pending escalation.

        Args:
            session_id: Session with escalation
            resolution: Human's resolution

        Returns:
            True if successful
        """
        session = self.session_manager.load(session_id)
        if not session:
            return False

        # Apply resolution
        if resolution.resolution_type == ResolutionType.APPROVED:
            self._session_states[session_id] = OrchestratorState.RUNNING
        elif resolution.resolution_type == ResolutionType.REJECTED:
            self._session_states[session_id] = OrchestratorState.FAILED
        elif resolution.resolution_type == ResolutionType.DEFERRED:
            self._session_states[session_id] = OrchestratorState.PAUSED
        else:
            self._session_states[session_id] = OrchestratorState.RUNNING

        # Store resolution in orchestrator context
        if session_id in self._session_contexts:
            self._session_contexts[session_id]["last_resolution"] = {
                "type": resolution.resolution_type.name,
                "decision": resolution.decision,
                "resolved_at": resolution.resolved_at.isoformat()
            }

        return True

    def complete_session(
        self,
        session_id: str,
        result: ExecutionResult
    ) -> bool:
        """Mark session as completed.

        Args:
            session_id: Session to complete
            result: Final execution result

        Returns:
            True if successful
        """
        session = self.session_manager.load(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.COMPLETED

        # Use SessionManager's complete method
        self.session_manager.complete()

        # Store completion info in orchestrator context
        if session_id in self._session_contexts:
            self._session_contexts[session_id]["completed_at"] = datetime.now().isoformat()
            self._session_contexts[session_id]["final_result"] = {
                "success": result.success,
                "output": result.output,
                "duration_seconds": result.duration_seconds
            }

        return True

    def fail_session(self, session_id: str, error: str) -> bool:
        """Mark session as failed.

        Args:
            session_id: Session to fail
            error: Error message

        Returns:
            True if successful
        """
        session = self.session_manager.load(session_id)
        if not session:
            return False

        self._session_states[session_id] = OrchestratorState.FAILED

        # Use SessionManager's abort method
        self.session_manager.abort(reason=error)

        # Store failure info in orchestrator context
        if session_id in self._session_contexts:
            self._session_contexts[session_id]["failed_at"] = datetime.now().isoformat()
            self._session_contexts[session_id]["error"] = error

        return True

    def get_session_history(self, session_id: str) -> list[ExecutionResult]:
        """Get execution history for session.

        Args:
            session_id: Session to get history for

        Returns:
            List of execution results
        """
        return self._session_history.get(session_id, [])

    def cleanup(self, max_age_days: int = 30) -> int:
        """Clean up old sessions and checkpoints.

        Args:
            max_age_days: Maximum age of items to keep

        Returns:
            Count of cleaned items
        """
        # Use actual SessionManager API
        return self.session_manager.cleanup_old_sessions(
            days=max_age_days,
            dry_run=False
        )

    def _create_checkpoint(self, session_id: str) -> None:
        """Create a checkpoint for the session."""
        session = self.session_manager.load(session_id)
        if not session:
            return

        try:
            # Use recovery_executor's checkpoint method
            checkpoint = self.recovery_executor.checkpoint(
                session_id=session_id,
                phase=session.current_phase or "unknown",
                state=self._session_contexts.get(session_id, {}),
                files=None
            )
            if checkpoint and hasattr(checkpoint, 'details') and checkpoint.details:
                # Store checkpoint ID in orchestrator context
                if session_id in self._session_contexts:
                    self._session_contexts[session_id]["last_checkpoint_id"] = checkpoint.details.get("checkpoint_id")
        except Exception:
            pass  # Checkpoint failure shouldn't break execution
