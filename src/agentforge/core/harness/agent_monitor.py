# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: core-harness-agent_monitor
# @test_path: tests/unit/harness/test_agent_monitor.py

# Generated by AgentForge
# Spec: agent_monitor
# Phase: green
# Date: 2025-12-31 05:35:32 UTC

import re
from collections import defaultdict, deque
from datetime import datetime

from .monitor_domain import (
    AgentHealth,
    HealthStatus,
    LoopDetection,
    Observation,
    ObservationType,
    Recommendation,
    ThrashingDetection,
)


class MonitorConfig:
    def __init__(
        self,
        history_window: int = 100,
        loop_threshold: int = 3,
        drift_threshold: float = 0.5,
        thrash_threshold: int = 3,
        stall_threshold: int = 5
    ):
        self.history_window = history_window
        self.loop_threshold = loop_threshold
        self.drift_threshold = drift_threshold
        self.thrash_threshold = thrash_threshold
        self.stall_threshold = stall_threshold


class AgentMonitor:
    def __init__(self, config: MonitorConfig | None = None):
        self.config = config or MonitorConfig()
        self.observations = deque(maxlen=self.config.history_window)
        self.file_modifications: dict[str, list[datetime]] = defaultdict(list)

    def observe_action(self, action: str, details: dict | None = None):
        """Record an agent action"""
        data = {"action": action}
        if details is not None:
            data["details"] = details
        observation = Observation(
            type=ObservationType.ACTION,
            timestamp=datetime.now(),
            data=data,
            context=None
        )
        self.observations.append(observation)

        # Track file modifications for thrashing detection
        if details and "file" in details:
            file_path = details["file"]
            self.file_modifications[file_path].append(datetime.now())

    def observe_output(self, output: str, output_type: str):
        """Record agent output"""
        observation = Observation(
            type=ObservationType.OUTPUT,
            timestamp=datetime.now(),
            data={"output": output, "output_type": output_type},
            context=None
        )
        self.observations.append(observation)

        # Track file modifications for thrashing detection
        if output_type == "file" and "path" in output:
            file_path = output
            self.file_modifications[file_path].append(datetime.now())

    def observe_verification(self, passed: bool, details: dict | None = None):
        """Record verification result"""
        data = {"passed": passed}
        if details is not None:
            data["details"] = details
        observation = Observation(
            type=ObservationType.VERIFICATION,
            timestamp=datetime.now(),
            data=data,
            context=None
        )
        self.observations.append(observation)

    def observe_state_change(self, old_state: str, new_state: str):
        """Record state transition"""
        observation = Observation(
            type=ObservationType.STATE_CHANGE,
            timestamp=datetime.now(),
            data={"old_state": old_state, "new_state": new_state},
            context=None
        )
        self.observations.append(observation)

    def observe_error(self, error_type: str, message: str, details: dict | None = None):
        """Record an error occurrence"""
        observation = Observation(
            type=ObservationType.ERROR,
            timestamp=datetime.now(),
            data={"error_type": error_type, "message": message, "details": details or {}},
            context=None
        )
        self.observations.append(observation)

    def _detect_consecutive_actions(self, recent_actions: list[Observation]) -> LoopDetection | None:
        """Check for consecutive identical actions."""
        if len(recent_actions) < self.config.loop_threshold:
            return None

        consecutive_count = 1
        last_action = recent_actions[-1].data.get("action", "")
        loop_observations = [recent_actions[-1]]

        for i in range(len(recent_actions) - 2, -1, -1):
            current_action = recent_actions[i].data.get("action", "")
            if current_action == last_action:
                consecutive_count += 1
                loop_observations.insert(0, recent_actions[i])
            else:
                break

        if consecutive_count >= self.config.loop_threshold:
            return LoopDetection(
                detected=True,
                pattern=f"Repeated action: {last_action}",
                count=consecutive_count,
                observations=loop_observations
            )
        return None

    def _detect_repeated_errors(self, recent_errors: list[Observation]) -> LoopDetection | None:
        """Check for repeated errors of the same type."""
        if len(recent_errors) < self.config.loop_threshold:
            return None

        error_counts: dict[str, int] = defaultdict(int)
        for error_obs in recent_errors:
            error_key = error_obs.data.get("error_type", "")
            error_counts[error_key] += 1

        for error_type, count in error_counts.items():
            if count >= self.config.loop_threshold:
                error_observations = [obs for obs in recent_errors
                                      if obs.data.get("error_type") == error_type]
                return LoopDetection(
                    detected=True,
                    pattern=f"Repeated error: {error_type}",
                    count=count,
                    observations=error_observations
                )
        return None

    def _detect_state_cycles(self, recent_states: list[Observation]) -> LoopDetection | None:
        """Check for A->B->A->B state cycling patterns."""
        if len(recent_states) < 4:
            return None

        states = [obs.data.get("new_state", "") for obs in recent_states[-4:]]
        is_cycle = (states[0] == states[2] and states[1] == states[3] and states[0] != states[1])

        if is_cycle:
            return LoopDetection(
                detected=True,
                pattern=f"State cycle: {states[0]} <-> {states[1]}",
                count=2,
                observations=recent_states[-4:]
            )
        return None

    def detect_loop(self) -> LoopDetection | None:
        """Check for repetitive action patterns."""
        if len(self.observations) < self.config.loop_threshold:
            return LoopDetection(detected=False)

        recent_obs = list(self.observations)[-10:]

        # Check consecutive actions
        recent_actions = [obs for obs in recent_obs if obs.type == ObservationType.ACTION]
        result = self._detect_consecutive_actions(recent_actions)
        if result:
            return result

        # Check repeated errors
        recent_errors = [obs for obs in recent_obs if obs.type == ObservationType.ERROR]
        result = self._detect_repeated_errors(recent_errors)
        if result:
            return result

        # Check state cycles
        recent_states = [obs for obs in recent_obs if obs.type == ObservationType.STATE_CHANGE]
        result = self._detect_state_cycles(recent_states)
        if result:
            return result

        return LoopDetection(detected=False)

    def _extract_keywords(self, text: str) -> set[str]:
        """Extract keywords, splitting on underscores and filtering short words."""
        normalized = text.lower().replace('_', ' ')
        words = re.findall(r'\b\w+\b', normalized)
        return {word for word in words if len(word) > 2}

    def _get_recent_keywords(self) -> set[str]:
        """Extract keywords from recent observations."""
        keywords: set[str] = set()
        for obs in list(self.observations)[-20:]:
            if obs.type == ObservationType.ACTION:
                keywords.update(self._extract_keywords(obs.data.get("action", "")))
            elif obs.type == ObservationType.OUTPUT:
                keywords.update(self._extract_keywords(obs.data.get("output", "")))
        return keywords

    def detect_drift(self, original_task: str) -> float:
        """Calculate drift score from original task."""
        if not original_task:
            return 0.0

        original_keywords = self._extract_keywords(original_task)
        if not original_keywords:
            return 0.0

        recent_keywords = self._get_recent_keywords()
        if not recent_keywords:
            return 0.0

        intersection = len(original_keywords & recent_keywords)
        if intersection == 0:
            return 1.0  # Complete drift

        # Overlap coefficient normalized by original keywords
        return max(0.0, min(1.0, 1.0 - (intersection / len(original_keywords))))

    def detect_thrashing(self) -> ThrashingDetection | None:
        """Check for back-and-forth patterns."""
        # Check file modification thrashing first
        file_result = self._detect_file_thrashing()
        if file_result.detected:
            return file_result

        # Check for alternating states
        state_result = self._detect_state_thrashing()
        if state_result.detected:
            return state_result

        return ThrashingDetection(detected=False)

    def _detect_file_thrashing(self) -> ThrashingDetection:
        """Check for file modification thrashing patterns."""
        thrashing_files = []
        max_alternations = 0

        for file_path, modifications in self.file_modifications.items():
            if len(modifications) >= self.config.thrash_threshold:
                thrashing_files.append(file_path)
                max_alternations = max(max_alternations, len(modifications))

        if thrashing_files:
            return ThrashingDetection(
                detected=True,
                pattern=f"Files modified repeatedly: {', '.join(thrashing_files[:3])}",
                affected_files=thrashing_files,
                alternation_count=max_alternations,
            )
        return ThrashingDetection(detected=False)

    def _detect_state_thrashing(self) -> ThrashingDetection:
        """Check for state alternation patterns (A-B-A-B)."""
        recent_states = [
            obs for obs in list(self.observations)[-10:]
            if obs.type == ObservationType.STATE_CHANGE
        ]

        if len(recent_states) < self.config.thrash_threshold:
            return ThrashingDetection(detected=False)

        state_sequence = [obs.data.get("new_state", "") for obs in recent_states]
        alternation_count = self._count_alternations(state_sequence)

        if alternation_count >= 1:
            return ThrashingDetection(
                detected=True,
                pattern="State alternation detected",
                affected_files=[],
                alternation_count=alternation_count + 1,
            )
        return ThrashingDetection(detected=False)

    def _count_alternations(self, state_sequence: list[str]) -> int:
        """Count A-B-A-B alternation patterns in state sequence."""
        count = 0
        for i in range(len(state_sequence) - 3):
            if (
                state_sequence[i] == state_sequence[i + 2]
                and state_sequence[i + 1] == state_sequence[i + 3]
                and state_sequence[i] != state_sequence[i + 1]
            ):
                count += 1
        return count

    def get_context_pressure(self, tokens_used: int, token_budget: int) -> float:
        """Calculate context window pressure"""
        if token_budget <= 0:
            return 1.0
        return min(1.0, max(0.0, tokens_used / token_budget))

    def get_progress_score(self) -> float:
        """Calculate progress based on verifications"""
        recent_verifications = [obs for obs in list(self.observations)[-20:]
                              if obs.type == ObservationType.VERIFICATION]

        if not recent_verifications:
            return 0.5  # Neutral - no verifications yet to measure

        successes = sum(1 for obs in recent_verifications
                       if obs.data.get("passed", False))
        total = len(recent_verifications)

        if total == 0:
            return 0.5

        base_score = successes / total

        # Bonus for recent success trend
        if len(recent_verifications) >= 3:
            recent_three = recent_verifications[-3:]
            recent_successes = sum(1 for obs in recent_three
                                 if obs.data.get("passed", False))
            if recent_successes == 3:
                base_score = min(1.0, base_score + 0.1)

        return base_score

    def _check_critical_conditions(
        self,
        loop_detection: LoopDetection,
        thrashing_detection: ThrashingDetection,
        drift_score: float,
        context_pressure: float,
        progress_score: float,
    ) -> tuple[list[str], Recommendation | None]:
        """Check for critical health conditions. Returns (issues, recommendation)."""
        issues: list[str] = []
        recommendation: Recommendation | None = None

        if loop_detection.detected and loop_detection.count >= 5:
            recommendation = Recommendation.ABORT
            issues.append(f"Severe loop detected: {loop_detection.pattern}")

        if drift_score > 0.5:
            if recommendation is None:
                recommendation = Recommendation.ESCALATE
            issues.append(f"High drift from original task (score: {drift_score:.2f})")

        if thrashing_detection.detected and thrashing_detection.alternation_count >= 5:
            if recommendation is None:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Severe thrashing detected: {thrashing_detection.pattern}")

        if context_pressure > 0.95:
            if recommendation is None:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Critical context pressure: {context_pressure:.2f}")

        if progress_score < 0.1:
            if recommendation is None:
                recommendation = Recommendation.ESCALATE
            issues.append(f"Very low progress score: {progress_score:.2f}")

        return issues, recommendation

    def _check_degraded_conditions(
        self,
        loop_detection: LoopDetection,
        thrashing_detection: ThrashingDetection,
        drift_score: float,
        context_pressure: float,
        progress_score: float,
    ) -> list[str]:
        """Check for degraded health conditions. Returns list of issues."""
        issues: list[str] = []

        if loop_detection.detected and loop_detection.count < 5:
            issues.append(f"Loop detected: {loop_detection.pattern}")

        if 0.3 <= drift_score <= 0.5:
            issues.append(f"Moderate drift detected (score: {drift_score:.2f})")

        if thrashing_detection.detected and thrashing_detection.alternation_count < 5:
            issues.append(f"Thrashing detected: {thrashing_detection.pattern}")

        if 0.8 <= context_pressure <= 0.95:
            issues.append(f"High context pressure: {context_pressure:.2f}")

        if 0.1 <= progress_score <= 0.3:
            issues.append(f"Low progress score: {progress_score:.2f}")

        return issues

    def get_health(
        self,
        original_task: str | None = None,
        tokens_used: int = 0,
        token_budget: int = 100000
    ) -> AgentHealth:
        """Complete health assessment."""
        # Run all detections
        loop_detection = self.detect_loop()
        thrashing_detection = self.detect_thrashing()
        drift_score = self.detect_drift(original_task) if original_task else 0.0
        context_pressure = self.get_context_pressure(tokens_used, token_budget)
        progress_score = self.get_progress_score()

        # Check critical conditions first
        critical_issues, critical_rec = self._check_critical_conditions(
            loop_detection, thrashing_detection, drift_score, context_pressure, progress_score
        )

        if critical_issues:
            return AgentHealth(
                status=HealthStatus.CRITICAL,
                issues=critical_issues,
                recommendation=critical_rec or Recommendation.ESCALATE,
                loop_detection=loop_detection if loop_detection.detected else None,
                thrashing_detection=thrashing_detection if thrashing_detection.detected else None,
                drift_score=drift_score,
                context_pressure=context_pressure,
                progress_score=progress_score
            )

        # Check degraded conditions
        degraded_issues = self._check_degraded_conditions(
            loop_detection, thrashing_detection, drift_score, context_pressure, progress_score
        )

        if degraded_issues:
            return AgentHealth(
                status=HealthStatus.DEGRADED,
                issues=degraded_issues,
                recommendation=Recommendation.CHECKPOINT,
                loop_detection=loop_detection if loop_detection.detected else None,
                thrashing_detection=thrashing_detection if thrashing_detection.detected else None,
                drift_score=drift_score,
                context_pressure=context_pressure,
                progress_score=progress_score
            )

        # Healthy
        return AgentHealth(
            status=HealthStatus.HEALTHY,
            issues=[],
            recommendation=Recommendation.CONTINUE,
            loop_detection=None,
            thrashing_detection=None,
            drift_score=drift_score,
            context_pressure=context_pressure,
            progress_score=progress_score
        )

    def clear_history(self):
        """Clear observation history"""
        self.observations.clear()
        self.file_modifications.clear()

    def get_recent_observations(
        self,
        count: int = 10,
        type_filter: ObservationType | None = None
    ) -> list[Observation]:
        """Get recent observations (most recent first)"""
        observations = list(self.observations)

        if type_filter:
            observations = [obs for obs in observations if obs.type == type_filter]

        # Return most recent first
        recent = observations[-count:] if observations else []
        return list(reversed(recent))
