# Operation Contract: Code Generation
# Governs patterns and practices for AI-generated code.
#
# These rules ensure generated code is:
# - Consistent with human-written code patterns
# - Maintainable and readable
# - Following established design principles
# - Properly integrated with existing codebase

id: operation.code-generation.v1
version: "1.0"
description: |
  Rules for AI-generated code to ensure quality, consistency,
  and maintainability. These patterns apply across all languages
  with language-specific adaptations where noted.

rules:
  # ============================================================
  # SOLID Principles
  # ============================================================

  - id: single-responsibility
    description: Each class/module should have one reason to change
    check_type: design_principle
    details:
      principle: single_responsibility
      indicators:
        - class_has_multiple_unrelated_methods
        - module_mixes_concerns
        - name_contains_and_or
      max_responsibilities: 1
      exceptions:
        - utility_classes
        - facade_patterns
    severity: warning
    rationale: |
      Classes with multiple responsibilities are harder to test,
      understand, and modify. When one responsibility changes,
      unrelated code might break.

  - id: open-closed
    description: Open for extension, closed for modification
    check_type: design_principle
    details:
      principle: open_closed
      prefer:
        - interfaces_over_concrete
        - composition_over_modification
        - strategy_pattern
        - template_method
      avoid:
        - modifying_existing_switch_statements
        - adding_conditionals_for_new_types
    severity: warning
    rationale: |
      New features should be addable without modifying existing
      code. Use interfaces and polymorphism instead of conditionals.

  - id: liskov-substitution
    description: Subtypes must be substitutable for base types
    check_type: design_principle
    details:
      principle: liskov_substitution
      violations:
        - override_throws_unexpected_exception
        - override_returns_narrower_type
        - override_accepts_broader_preconditions
        - empty_override_implementation
    severity: error
    rationale: |
      If code works with a base type, it must work with any
      subtype without knowing the difference.

  - id: interface-segregation
    description: Clients should not depend on unused interfaces
    check_type: design_principle
    details:
      principle: interface_segregation
      max_interface_methods: 5
      indicators:
        - interface_has_many_unrelated_methods
        - implementer_has_empty_methods
        - not_implemented_exceptions
    severity: warning
    rationale: |
      Large interfaces force clients to depend on methods they
      don't use. Prefer many small, focused interfaces.

  - id: dependency-inversion
    description: Depend on abstractions, not concretions
    check_type: design_principle
    details:
      principle: dependency_inversion
      require:
        - constructor_injection
        - interface_dependencies
      avoid:
        - new_keyword_for_services
        - static_service_calls
        - service_locator_pattern
    severity: warning
    rationale: |
      High-level modules should not depend on low-level modules.
      Both should depend on abstractions (interfaces).

  # ============================================================
  # Code Structure Rules
  # ============================================================

  - id: function-size-limit
    description: Functions should be small and focused
    check_type: code_metric
    details:
      metric: function_lines
      max_lines: 30
      recommended_lines: 15
      exclude:
        - switch_statements
        - builders
        - test_setup
    severity: warning
    rationale: |
      Small functions are easier to understand, test, and reuse.
      If a function is too long, it's likely doing too much.

  - id: parameter-count-limit
    description: Limit function parameter count
    check_type: code_metric
    details:
      metric: parameter_count
      max_parameters: 5
      recommended_max: 3
      solutions:
        - introduce_parameter_object
        - use_builder_pattern
        - split_function
    severity: warning
    rationale: |
      Too many parameters indicate the function is doing too much
      or needs better abstraction. Consider grouping related params.

  - id: nesting-depth-limit
    description: Limit nesting depth for readability
    check_type: code_metric
    details:
      metric: nesting_depth
      max_depth: 4
      recommended_max: 3
      solutions:
        - extract_method
        - early_return
        - guard_clauses
    severity: warning
    rationale: |
      Deep nesting makes code hard to follow. Use early returns
      and extract nested logic into separate functions.

  - id: cyclomatic-complexity-limit
    description: Limit branch complexity
    check_type: code_metric
    details:
      metric: cyclomatic_complexity
      max_complexity: 10
      recommended_max: 7
      count:
        - if_statements
        - loops
        - case_branches
        - catch_blocks
        - logical_operators
    severity: warning
    rationale: |
      High complexity means more paths to test and more potential
      for bugs. Simplify or extract complex logic.

  - id: class-size-limit
    description: Classes should be focused and manageable
    check_type: code_metric
    details:
      metric: class_lines
      max_lines: 300
      recommended_lines: 200
      max_methods: 15
      max_fields: 10
    severity: warning
    rationale: |
      Large classes often violate SRP. Consider splitting into
      smaller, focused classes with clear responsibilities.

  # ============================================================
  # Naming Conventions
  # ============================================================

  - id: descriptive-naming
    description: Names should reveal intent
    check_type: naming_convention
    details:
      rules:
        - names_reveal_intent
        - avoid_abbreviations
        - avoid_single_letters
        - avoid_noise_words
      allowed_single_letters:
        - i, j, k for loop indices
        - x, y, z for coordinates
        - e for exceptions
        - _ for unused variables
      noise_words_to_avoid:
        - data
        - info
        - manager
        - processor
        - handler  # unless actually handling events
    severity: warning
    rationale: |
      Good names make code self-documenting. If you need a comment
      to explain what something is, the name could be better.

  - id: boolean-naming
    description: Boolean variables/methods should be questions
    check_type: naming_convention
    details:
      prefixes:
        - is
        - has
        - can
        - should
        - will
        - did
      examples:
        good:
          - is_valid
          - has_permission
          - can_execute
          - should_retry
        bad:
          - valid  # unclear if boolean
          - permission  # unclear type
          - check  # verb, not question
    severity: warning
    rationale: |
      Boolean names as questions make conditionals read naturally:
      `if is_valid` reads better than `if valid`.

  - id: function-naming
    description: Functions should be verbs describing action
    check_type: naming_convention
    details:
      patterns:
        - verb_noun: ["get", "set", "create", "delete", "update"]
        - verb_adjective: ["is", "has", "can", "should"]
        - verb_preposition: ["convert_to", "format_as", "map_to"]
      avoid:
        - noun_only: ["user", "data", "result"]
        - generic_verbs: ["do", "handle", "process", "manage"]
    severity: warning
    rationale: |
      Functions perform actions - their names should say what
      action they perform, not just what they relate to.

  # ============================================================
  # Code Quality Patterns
  # ============================================================

  - id: prefer-composition
    description: Favor composition over inheritance
    check_type: design_pattern
    details:
      prefer:
        - interface_implementation
        - delegate_pattern
        - strategy_injection
      limit:
        - inheritance_depth: 3
        - abstract_classes: when_sharing_code
      avoid:
        - deep_inheritance_hierarchies
        - inheritance_for_code_reuse_only
    severity: warning
    rationale: |
      Composition is more flexible than inheritance. Changes to
      base classes don't ripple through the hierarchy.

  - id: immutability-preference
    description: Prefer immutable data structures
    check_type: design_pattern
    details:
      prefer:
        - readonly_fields
        - init_only_properties
        - record_types
        - frozen_dataclasses
      require_for:
        - value_objects
        - configuration
        - messages
        - events
      exceptions:
        - entities_with_identity
        - builders
        - accumulators
    severity: warning
    rationale: |
      Immutable objects are thread-safe, easier to reason about,
      and prevent accidental state modification bugs.

  - id: null-safety
    description: Handle null/None explicitly
    check_type: safety_pattern
    details:
      prefer:
        - optional_types
        - null_object_pattern
        - early_validation
        - default_values
      avoid:
        - returning_null_from_collections
        - null_checks_deep_in_code
        - null_as_error_indicator
      languages:
        python: "Use Optional[T] or | None"
        typescript: "Enable strictNullChecks"
        csharp: "Enable nullable reference types"
    severity: warning
    rationale: |
      Null reference errors are common bugs. Make nullability
      explicit in types and handle it at boundaries.

  - id: magic-values
    description: No magic numbers or strings
    check_type: code_smell
    details:
      require:
        - named_constants
        - enums_for_options
        - configuration_for_tunables
      allowed_magic_values:
        - 0, 1, -1 for common operations
        - empty string for initialization
        - true, false
      examples:
        bad: "if status == 2"
        good: "if status == OrderStatus.SHIPPED"
    severity: warning
    rationale: |
      Magic values hide meaning and scatter knowledge. Named
      constants document intent and enable safe refactoring.

  - id: dry-principle
    description: Don't Repeat Yourself
    check_type: code_smell
    details:
      threshold:
        duplicate_lines: 6
        similar_structures: 3
      solutions:
        - extract_function
        - extract_base_class
        - use_template_method
        - create_utility
      exceptions:
        - test_setup_code
        - generated_code
    severity: warning
    rationale: |
      Duplication means multiple places to update when logic
      changes. Extract common code into reusable units.

  # ============================================================
  # Integration Rules
  # ============================================================

  - id: match-existing-patterns
    description: Follow patterns already established in codebase
    check_type: consistency
    details:
      analyze:
        - existing_file_structure
        - naming_patterns
        - error_handling_style
        - logging_approach
        - test_organization
      priority:
        1: match_immediate_context
        2: match_module_patterns
        3: match_project_patterns
        4: use_industry_standard
    severity: warning
    rationale: |
      Consistency within a codebase is more important than
      following external standards. Match what's already there.

  - id: minimal-change-principle
    description: Make smallest possible change to achieve goal
    check_type: change_scope
    details:
      avoid:
        - reformatting_unrelated_code
        - renaming_unrelated_variables
        - refactoring_during_feature_work
        - adding_unused_features
      require:
        - change_justification
        - scope_limitation
        - review_before_expansion
    severity: warning
    rationale: |
      Minimal changes are easier to review, less likely to
      introduce bugs, and easier to revert if needed.

  - id: backward-compatibility
    description: Preserve backward compatibility when possible
    check_type: api_stability
    details:
      for_public_apis:
        - add_dont_remove
        - deprecate_before_remove
        - version_breaking_changes
      breaking_changes_require:
        - explicit_approval
        - migration_guide
        - version_bump
    severity: warning
    rationale: |
      Breaking changes affect all callers. Prefer additive
      changes and deprecation over removal.

escalation_triggers:
  - trigger_id: solid-violation-detected
    condition: Multiple SOLID principle violations in generated code
    severity: advisory
    prompt: |
      Generated code may violate design principles:
      - Review class responsibilities
      - Check for proper abstraction
      - Consider refactoring before proceeding
    rationale: |
      SOLID violations compound over time. Better to address
      early than let technical debt accumulate.

  - trigger_id: complexity-threshold-exceeded
    condition: Code complexity exceeds thresholds
    severity: advisory
    prompt: |
      Generated code is complex. Consider:
      - Breaking into smaller functions
      - Extracting helper classes
      - Simplifying conditional logic
    rationale: |
      Complex code is hard to test and maintain. Simpler
      is almost always better.

  - trigger_id: pattern-mismatch
    condition: Generated code doesn't match existing patterns
    severity: blocking
    prompt: |
      Generated code uses different patterns than existing code.
      Options:
      - Adapt to match existing patterns
      - Propose migration of existing code
      - Get approval for mixed patterns
    rationale: |
      Consistency reduces cognitive load. Deviations should
      be intentional and justified.

quality_gates:
  - gate_id: code-generation-review
    checks:
      - SOLID principles followed
      - Complexity within limits
      - Naming conventions followed
      - No magic values
      - Matches existing patterns
    failure_action: advisory

  - gate_id: integration-check
    checks:
      - Minimal change scope
      - Backward compatible
      - Tests added/updated
      - Documentation updated
    failure_action: escalate
