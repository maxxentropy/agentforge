# Operation Contract: Design Patterns
# Governs the appropriate use of software design patterns.
#
# These rules ensure patterns are:
# - Applied in appropriate contexts
# - Implemented correctly
# - Not over-engineered
# - Consistent across the codebase

id: operation.design-patterns.v1
version: "1.0"
description: |
  Comprehensive guide to software design patterns including GoF patterns,
  architectural patterns, and modern patterns. Emphasizes when to use
  each pattern and common implementation pitfalls.

rules:
  # ============================================================
  # Creational Patterns
  # ============================================================

  - id: factory-method
    description: Define interface for creating objects, let subclasses decide which class
    check_type: design_pattern
    details:
      intent: |
        Defer instantiation to subclasses. Useful when a class can't
        anticipate the class of objects it must create.
      use_when:
        - class_doesnt_know_object_types_ahead
        - subclasses_should_specify_objects
        - want_to_localize_creation_logic
      structure:
        creator: "Declares factory method returning Product"
        concrete_creator: "Overrides factory method to return ConcreteProduct"
        product: "Interface for objects factory method creates"
        concrete_product: "Implements Product interface"
      examples:
        python: |
          class DocumentFactory(ABC):
              @abstractmethod
              def create_document(self) -> Document:
                  pass

          class PDFFactory(DocumentFactory):
              def create_document(self) -> Document:
                  return PDFDocument()
        typescript: |
          interface DocumentFactory {
            createDocument(): Document;
          }

          class PDFFactory implements DocumentFactory {
            createDocument(): Document {
              return new PDFDocument();
            }
          }
      anti_patterns:
        - factory_returning_concrete_types
        - factory_with_type_switches
        - factory_in_tight_loop
      prefer_over:
        - direct_constructor_calls_when_type_varies
    severity: info
    rationale: |
      Factory method decouples client code from specific classes.
      Changes to product creation don't require client changes.

  - id: abstract-factory
    description: Create families of related objects without specifying concrete classes
    check_type: design_pattern
    details:
      intent: |
        Provide interface for creating families of related or dependent
        objects without specifying their concrete classes.
      use_when:
        - system_should_be_independent_of_product_creation
        - system_uses_multiple_product_families
        - products_in_family_used_together
        - want_to_provide_library_of_products
      structure:
        abstract_factory: "Declares creation methods for each product"
        concrete_factory: "Implements creation for specific family"
        abstract_product: "Interface for a type of product"
        concrete_product: "Implements product for specific family"
      examples:
        python: |
          class UIFactory(ABC):
              @abstractmethod
              def create_button(self) -> Button: pass
              @abstractmethod
              def create_checkbox(self) -> Checkbox: pass

          class DarkThemeFactory(UIFactory):
              def create_button(self) -> Button:
                  return DarkButton()
              def create_checkbox(self) -> Checkbox:
                  return DarkCheckbox()
      anti_patterns:
        - adding_products_requires_interface_change
        - factories_with_unrelated_products
      when_not_to_use:
        - single_product_type
        - products_not_actually_related
    severity: info
    rationale: |
      Abstract factory ensures products from same family work together.
      Switching families requires only changing factory instance.

  - id: builder-pattern
    description: Construct complex objects step by step
    check_type: design_pattern
    details:
      intent: |
        Separate the construction of a complex object from its
        representation so the same construction process can create
        different representations.
      use_when:
        - object_has_many_constructor_parameters
        - want_immutable_object_with_optional_fields
        - construction_steps_should_be_reusable
        - object_has_complex_initialization
      structure:
        builder: "Specifies abstract interface for creating parts"
        concrete_builder: "Constructs and assembles parts"
        director: "Constructs using Builder interface (optional)"
        product: "The complex object being built"
      examples:
        python: |
          @dataclass
          class EmailBuilder:
              _to: str = ""
              _subject: str = ""
              _body: str = ""
              _attachments: list[str] = field(default_factory=list)

              def to(self, recipient: str) -> "EmailBuilder":
                  self._to = recipient
                  return self

              def subject(self, subject: str) -> "EmailBuilder":
                  self._subject = subject
                  return self

              def build(self) -> Email:
                  return Email(self._to, self._subject, self._body, self._attachments)

          # Usage
          email = EmailBuilder().to("user@example.com").subject("Hello").build()
        typescript: |
          class QueryBuilder {
            private query: Partial<Query> = {};

            select(...fields: string[]): this {
              this.query.fields = fields;
              return this;
            }

            where(condition: Condition): this {
              this.query.conditions = [...(this.query.conditions ?? []), condition];
              return this;
            }

            build(): Query {
              return this.query as Query;
            }
          }
      threshold:
        use_when_parameters_exceed: 4
      anti_patterns:
        - builder_for_simple_objects
        - mutable_product_after_build
        - builder_without_validation
    severity: info
    rationale: |
      Builders make complex object construction readable and prevent
      telescoping constructors. Enable fluent, self-documenting APIs.

  - id: singleton-pattern
    description: Ensure class has only one instance with global access point
    check_type: design_pattern
    details:
      intent: |
        Ensure a class has only one instance and provide a global
        point of access to it.
      use_when:
        - exactly_one_instance_needed
        - instance_should_be_extensible
        - clients_shouldnt_change_instance
      legitimate_uses:
        - logging_configuration
        - thread_pools
        - connection_pools
        - configuration_objects
        - hardware_interface_access
      avoid_because:
        - makes_testing_difficult
        - hides_dependencies
        - violates_single_responsibility
        - creates_global_state
      prefer_instead:
        - dependency_injection
        - module_level_instance
        - factory_with_caching
      examples:
        python: |
          # Prefer module-level singleton in Python
          # _config.py
          _instance: Config | None = None

          def get_config() -> Config:
              global _instance
              if _instance is None:
                  _instance = Config.from_environment()
              return _instance

          # Better: Use dependency injection
          class Service:
              def __init__(self, config: Config):
                  self.config = config
      anti_patterns:
        - singleton_with_mutable_state
        - singleton_for_testable_services
        - lazy_singleton_without_thread_safety
    severity: warning
    rationale: |
      Singletons are often overused. Prefer dependency injection which
      makes dependencies explicit and testing easier.

  - id: prototype-pattern
    description: Create objects by cloning existing instances
    check_type: design_pattern
    details:
      intent: |
        Specify kinds of objects to create using a prototypical instance,
        and create new objects by copying this prototype.
      use_when:
        - classes_instantiated_at_runtime
        - avoid_factory_hierarchy_paralleling_products
        - instances_have_few_state_combinations
        - cloning_cheaper_than_creation
      structure:
        prototype: "Declares interface for cloning itself"
        concrete_prototype: "Implements cloning operation"
        client: "Creates new objects by asking prototype to clone"
      examples:
        python: |
          import copy

          @dataclass
          class GameUnit:
              health: int
              attack: int
              defense: int
              position: tuple[int, int]

              def clone(self) -> "GameUnit":
                  return copy.deepcopy(self)

          # Usage: Create variations from prototype
          base_soldier = GameUnit(100, 10, 5, (0, 0))
          soldier1 = base_soldier.clone()
          soldier1.position = (10, 20)
      considerations:
        - deep_vs_shallow_copy
        - circular_references
        - private_fields
    severity: info
    rationale: |
      Prototype avoids the cost of creating objects from scratch when
      similar objects already exist. Useful for configuration objects.

  # ============================================================
  # Structural Patterns
  # ============================================================

  - id: adapter-pattern
    description: Convert interface of a class into another interface clients expect
    check_type: design_pattern
    details:
      intent: |
        Convert the interface of a class into another interface clients
        expect. Adapter lets classes work together that couldn't otherwise
        because of incompatible interfaces.
      use_when:
        - want_to_use_existing_class_with_incompatible_interface
        - want_to_create_reusable_class_for_unrelated_classes
        - need_to_use_several_existing_subclasses
      types:
        object_adapter: "Uses composition (preferred)"
        class_adapter: "Uses multiple inheritance"
      examples:
        python: |
          # Adapt third-party logger to our interface
          class Logger(Protocol):
              def log(self, level: str, message: str) -> None: ...

          class ThirdPartyLoggerAdapter:
              def __init__(self, third_party: ThirdPartyLogger):
                  self._logger = third_party

              def log(self, level: str, message: str) -> None:
                  # Adapt to third-party's different method signature
                  self._logger.write_log(level.upper(), message, timestamp=True)
        typescript: |
          interface PaymentProcessor {
            process(amount: number): Promise<void>;
          }

          class StripeAdapter implements PaymentProcessor {
            constructor(private stripe: StripeClient) {}

            async process(amount: number): Promise<void> {
              // Adapt to Stripe's API
              await this.stripe.charges.create({
                amount: amount * 100, // Stripe uses cents
                currency: 'usd',
              });
            }
          }
      anti_patterns:
        - adapter_with_business_logic
        - bidirectional_adapters
    severity: info
    rationale: |
      Adapters enable integration with external libraries and legacy
      code without modifying source. Essential for clean boundaries.

  - id: decorator-pattern
    description: Attach additional responsibilities to object dynamically
    check_type: design_pattern
    details:
      intent: |
        Attach additional responsibilities to an object dynamically.
        Decorators provide a flexible alternative to subclassing.
      use_when:
        - add_responsibilities_dynamically
        - responsibilities_can_be_withdrawn
        - extension_by_subclassing_impractical
        - want_to_combine_behaviors
      structure:
        component: "Interface for objects that can have responsibilities"
        concrete_component: "The object being decorated"
        decorator: "Maintains reference to component, conforms to interface"
        concrete_decorator: "Adds responsibilities to component"
      examples:
        python: |
          class DataSource(Protocol):
              def read(self) -> str: ...
              def write(self, data: str) -> None: ...

          class EncryptionDecorator:
              def __init__(self, source: DataSource, cipher: Cipher):
                  self._source = source
                  self._cipher = cipher

              def read(self) -> str:
                  return self._cipher.decrypt(self._source.read())

              def write(self, data: str) -> None:
                  self._source.write(self._cipher.encrypt(data))

          # Stack decorators
          source = CompressionDecorator(
              EncryptionDecorator(
                  FileDataSource("data.txt"),
                  cipher
              )
          )
        typescript: |
          // Function decorator pattern
          function withLogging<T extends (...args: any[]) => any>(fn: T): T {
            return ((...args) => {
              console.log(`Calling ${fn.name} with`, args);
              const result = fn(...args);
              console.log(`Result:`, result);
              return result;
            }) as T;
          }
      vs_inheritance:
        decorator: "Responsibilities added at runtime, can be combined"
        inheritance: "Responsibilities fixed at compile time"
      anti_patterns:
        - too_many_small_decorators
        - decorator_order_dependencies_unclear
    severity: info
    rationale: |
      Decorators allow behavior composition without class explosion.
      Each decorator has single responsibility, easily testable.

  - id: facade-pattern
    description: Provide unified interface to set of interfaces in subsystem
    check_type: design_pattern
    details:
      intent: |
        Provide a unified interface to a set of interfaces in a
        subsystem. Facade defines a higher-level interface that
        makes the subsystem easier to use.
      use_when:
        - want_simple_interface_to_complex_subsystem
        - many_dependencies_between_clients_and_implementation
        - want_to_layer_subsystems
      structure:
        facade: "Knows which subsystem classes handle requests"
        subsystem_classes: "Implement subsystem functionality"
      examples:
        python: |
          class VideoConverter:
              """Facade for complex video conversion subsystem."""

              def convert(self, filename: str, format: str) -> str:
                  # Hide complexity of subsystem
                  file = VideoFile(filename)
                  codec = CodecFactory.extract(file)
                  if format == "mp4":
                      return MPEG4Compression().compress(codec, file)
                  elif format == "webm":
                      return WebMCompression().compress(codec, file)

          # Client uses simple interface
          converter = VideoConverter()
          converter.convert("video.avi", "mp4")
      benefits:
        - isolates_clients_from_subsystem
        - promotes_weak_coupling
        - doesnt_prevent_using_subsystem_directly
      anti_patterns:
        - facade_becoming_god_object
        - facade_exposing_subsystem_types
    severity: info
    rationale: |
      Facades simplify complex subsystems for common use cases while
      still allowing direct subsystem access when needed.

  - id: proxy-pattern
    description: Provide surrogate or placeholder for another object
    check_type: design_pattern
    details:
      intent: |
        Provide a surrogate or placeholder for another object to control
        access to it.
      use_when:
        - lazy_initialization_needed
        - access_control_required
        - local_execution_of_remote_service
        - logging_needed_for_object_access
        - caching_results_of_expensive_operations
      types:
        virtual_proxy: "Lazy initialization"
        protection_proxy: "Access control"
        remote_proxy: "Local representation of remote object"
        logging_proxy: "Logging access to subject"
        caching_proxy: "Cache results"
      examples:
        python: |
          class Image(Protocol):
              def display(self) -> None: ...

          class LazyImageProxy:
              """Virtual proxy - loads image only when needed."""

              def __init__(self, filename: str):
                  self._filename = filename
                  self._image: RealImage | None = None

              def display(self) -> None:
                  if self._image is None:
                      self._image = RealImage(self._filename)  # Expensive load
                  self._image.display()

          class AccessControlProxy:
              """Protection proxy - checks permissions."""

              def __init__(self, document: Document, user: User):
                  self._document = document
                  self._user = user

              def read(self) -> str:
                  if not self._user.can_read(self._document):
                      raise PermissionError("Access denied")
                  return self._document.read()
      anti_patterns:
        - proxy_with_different_interface
        - heavyweight_proxy_creation
    severity: info
    rationale: |
      Proxies control object access transparently. Essential for lazy
      loading, access control, and remote service integration.

  - id: composite-pattern
    description: Compose objects into tree structures representing part-whole hierarchies
    check_type: design_pattern
    details:
      intent: |
        Compose objects into tree structures to represent part-whole
        hierarchies. Composite lets clients treat individual objects
        and compositions uniformly.
      use_when:
        - want_to_represent_part_whole_hierarchies
        - clients_should_ignore_composite_vs_individual
        - structure_can_have_any_level_of_complexity
      structure:
        component: "Declares interface for objects in composition"
        leaf: "Represents leaf objects with no children"
        composite: "Stores child components, implements child-related operations"
      examples:
        python: |
          class FileSystemItem(ABC):
              @abstractmethod
              def get_size(self) -> int: pass

          class File(FileSystemItem):
              def __init__(self, name: str, size: int):
                  self.name = name
                  self.size = size

              def get_size(self) -> int:
                  return self.size

          class Directory(FileSystemItem):
              def __init__(self, name: str):
                  self.name = name
                  self.children: list[FileSystemItem] = []

              def add(self, item: FileSystemItem) -> None:
                  self.children.append(item)

              def get_size(self) -> int:
                  return sum(child.get_size() for child in self.children)

          # Client code treats files and directories uniformly
          def print_size(item: FileSystemItem) -> None:
              print(f"Size: {item.get_size()}")
      use_cases:
        - file_systems
        - ui_component_hierarchies
        - organization_structures
        - expression_trees
      anti_patterns:
        - composite_with_type_checks
        - leaf_operations_on_composite_interface
    severity: info
    rationale: |
      Composite enables uniform treatment of individual objects and
      compositions, simplifying client code for hierarchical structures.

  - id: bridge-pattern
    description: Decouple abstraction from implementation so both can vary independently
    check_type: design_pattern
    details:
      intent: |
        Decouple an abstraction from its implementation so that the
        two can vary independently.
      use_when:
        - want_runtime_binding_of_implementation
        - both_abstractions_and_implementations_should_be_extensible
        - changes_in_implementation_shouldnt_impact_clients
        - want_to_share_implementation_among_objects
      structure:
        abstraction: "Defines abstraction's interface, maintains implementor ref"
        refined_abstraction: "Extends interface defined by Abstraction"
        implementor: "Defines interface for implementation classes"
        concrete_implementor: "Implements Implementor interface"
      examples:
        python: |
          # Abstraction
          class RemoteControl:
              def __init__(self, device: Device):
                  self._device = device

              def toggle_power(self) -> None:
                  if self._device.is_enabled():
                      self._device.disable()
                  else:
                      self._device.enable()

          # Refined abstraction
          class AdvancedRemoteControl(RemoteControl):
              def mute(self) -> None:
                  self._device.set_volume(0)

          # Implementor
          class Device(Protocol):
              def is_enabled(self) -> bool: ...
              def enable(self) -> None: ...
              def disable(self) -> None: ...
              def set_volume(self, volume: int) -> None: ...

          # Concrete implementors
          class TV:
              # TV-specific implementation

          class Radio:
              # Radio-specific implementation

          # Can combine any abstraction with any implementor
          remote = AdvancedRemoteControl(TV())
      vs_adapter:
        bridge: "Designed up-front, both hierarchies evolve"
        adapter: "Applied after-the-fact to existing classes"
    severity: info
    rationale: |
      Bridge prevents class explosion when extending abstractions and
      implementations independently. Platform abstraction is a common use.

  - id: flyweight-pattern
    description: Use sharing to support large numbers of fine-grained objects efficiently
    check_type: design_pattern
    details:
      intent: |
        Use sharing to support large numbers of fine-grained objects
        efficiently.
      use_when:
        - application_uses_large_number_of_objects
        - storage_costs_high_due_to_object_quantity
        - most_object_state_can_be_extrinsic
        - many_objects_can_be_replaced_by_few_shared
        - application_doesnt_depend_on_object_identity
      structure:
        flyweight: "Interface through which flyweights receive extrinsic state"
        concrete_flyweight: "Stores intrinsic state, must be shareable"
        flyweight_factory: "Creates and manages flyweight objects"
        client: "Maintains reference to flyweights, computes extrinsic state"
      terminology:
        intrinsic_state: "Stored in flyweight, shared, context-independent"
        extrinsic_state: "Passed to flyweight methods, context-dependent"
      examples:
        python: |
          class TreeType:
              """Flyweight: stores intrinsic state (type data)."""
              def __init__(self, name: str, color: str, texture: bytes):
                  self.name = name
                  self.color = color
                  self.texture = texture  # Large, but shared

              def draw(self, x: int, y: int, canvas: Canvas) -> None:
                  # x, y are extrinsic state
                  canvas.draw_bitmap(self.texture, x, y, self.color)

          class TreeFactory:
              _cache: dict[str, TreeType] = {}

              @classmethod
              def get_tree_type(cls, name: str, color: str, texture: bytes) -> TreeType:
                  key = f"{name}_{color}"
                  if key not in cls._cache:
                      cls._cache[key] = TreeType(name, color, texture)
                  return cls._cache[key]

          class Tree:
              """Uses flyweight with extrinsic state."""
              def __init__(self, x: int, y: int, tree_type: TreeType):
                  self.x = x
                  self.y = y
                  self.type = tree_type

              def draw(self, canvas: Canvas) -> None:
                  self.type.draw(self.x, self.y, canvas)
      use_cases:
        - text_editors_character_objects
        - game_particles
        - ui_icon_rendering
        - caching_immutable_objects
      anti_patterns:
        - flyweight_with_mutable_intrinsic_state
        - storing_extrinsic_state_in_flyweight
    severity: info
    rationale: |
      Flyweight dramatically reduces memory when many similar objects exist.
      The key is separating shared (intrinsic) from unique (extrinsic) state.

  # ============================================================
  # Behavioral Patterns
  # ============================================================

  - id: strategy-pattern
    description: Define family of algorithms, encapsulate each, make them interchangeable
    check_type: design_pattern
    details:
      intent: |
        Define a family of algorithms, encapsulate each one, and make
        them interchangeable. Strategy lets the algorithm vary
        independently from clients that use it.
      use_when:
        - many_related_classes_differ_only_in_behavior
        - need_different_variants_of_algorithm
        - algorithm_uses_data_clients_shouldnt_know
        - class_defines_many_behaviors_via_conditionals
      structure:
        strategy: "Declares interface common to all algorithms"
        concrete_strategy: "Implements algorithm using Strategy interface"
        context: "Configured with ConcreteStrategy, maintains reference"
      examples:
        python: |
          class CompressionStrategy(Protocol):
              def compress(self, data: bytes) -> bytes: ...

          class ZipCompression:
              def compress(self, data: bytes) -> bytes:
                  return zlib.compress(data)

          class GzipCompression:
              def compress(self, data: bytes) -> bytes:
                  return gzip.compress(data)

          class FileCompressor:
              def __init__(self, strategy: CompressionStrategy):
                  self._strategy = strategy

              def compress_file(self, path: Path) -> bytes:
                  data = path.read_bytes()
                  return self._strategy.compress(data)

          # Usage: swap strategies at runtime
          compressor = FileCompressor(ZipCompression())
          compressor = FileCompressor(GzipCompression())
        typescript: |
          type SortStrategy<T> = (items: T[]) => T[];

          const quickSort: SortStrategy<number> = (items) => { /* ... */ };
          const mergeSort: SortStrategy<number> = (items) => { /* ... */ };

          class Sorter<T> {
            constructor(private strategy: SortStrategy<T>) {}

            sort(items: T[]): T[] {
              return this.strategy(items);
            }
          }
      replaces: "Switch statements on type"
      anti_patterns:
        - strategy_with_shared_state
        - too_granular_strategies
    severity: info
    rationale: |
      Strategy eliminates conditional statements for selecting algorithms.
      New strategies can be added without modifying existing code.

  - id: observer-pattern
    description: Define one-to-many dependency so dependents are notified of state changes
    check_type: design_pattern
    details:
      intent: |
        Define a one-to-many dependency between objects so that when
        one object changes state, all its dependents are notified
        and updated automatically.
      use_when:
        - abstraction_has_two_aspects_one_dependent_on_other
        - change_to_one_object_requires_changing_others
        - object_should_notify_others_without_assumptions
      structure:
        subject: "Knows its observers, provides attach/detach interface"
        observer: "Defines update interface for notification"
        concrete_subject: "Stores state, sends notification on change"
        concrete_observer: "Maintains reference to subject, implements update"
      variants:
        push_model: "Subject sends detailed change info"
        pull_model: "Subject sends minimal notification, observer queries"
      examples:
        python: |
          from typing import Callable

          class EventEmitter:
              def __init__(self):
                  self._listeners: dict[str, list[Callable]] = {}

              def on(self, event: str, callback: Callable) -> None:
                  if event not in self._listeners:
                      self._listeners[event] = []
                  self._listeners[event].append(callback)

              def emit(self, event: str, *args, **kwargs) -> None:
                  for callback in self._listeners.get(event, []):
                      callback(*args, **kwargs)

          # Usage
          class StockTicker(EventEmitter):
              def update_price(self, symbol: str, price: float) -> None:
                  self._prices[symbol] = price
                  self.emit("price_change", symbol, price)

          ticker = StockTicker()
          ticker.on("price_change", lambda s, p: print(f"{s}: ${p}"))
      considerations:
        - memory_leaks_from_unremoved_observers
        - notification_order_not_guaranteed
        - cascading_updates
    severity: info
    rationale: |
      Observer decouples subjects from their observers. Subjects broadcast
      without knowing who's listening, enabling loose coupling.

  - id: command-pattern
    description: Encapsulate request as object to parameterize clients
    check_type: design_pattern
    details:
      intent: |
        Encapsulate a request as an object, thereby letting you
        parameterize clients with different requests, queue requests,
        and support undoable operations.
      use_when:
        - parameterize_objects_with_action_to_perform
        - specify_queue_and_execute_requests_at_different_times
        - support_undo
        - support_logging_changes_for_recovery
        - structure_system_around_high_level_operations
      structure:
        command: "Declares interface for executing operation"
        concrete_command: "Binds receiver to action, implements execute"
        client: "Creates ConcreteCommand and sets its receiver"
        invoker: "Asks command to carry out request"
        receiver: "Knows how to perform operation"
      examples:
        python: |
          class Command(Protocol):
              def execute(self) -> None: ...
              def undo(self) -> None: ...

          @dataclass
          class InsertTextCommand:
              document: Document
              position: int
              text: str

              def execute(self) -> None:
                  self.document.insert(self.position, self.text)

              def undo(self) -> None:
                  self.document.delete(self.position, len(self.text))

          class CommandHistory:
              def __init__(self):
                  self._history: list[Command] = []

              def execute(self, command: Command) -> None:
                  command.execute()
                  self._history.append(command)

              def undo(self) -> None:
                  if self._history:
                      command = self._history.pop()
                      command.undo()
      use_cases:
        - undo_redo_functionality
        - transaction_systems
        - macro_recording
        - task_queues
        - wizard_dialogs
    severity: info
    rationale: |
      Command decouples invoker from receiver. Enables undo/redo,
      transactional behavior, and operation queuing.

  - id: template-method-pattern
    description: Define skeleton of algorithm, defer steps to subclasses
    check_type: design_pattern
    details:
      intent: |
        Define the skeleton of an algorithm in an operation, deferring
        some steps to subclasses. Template Method lets subclasses redefine
        certain steps without changing algorithm's structure.
      use_when:
        - implement_invariant_parts_of_algorithm_once
        - common_behavior_should_be_localized
        - control_subclass_extensions
      structure:
        abstract_class: "Defines template method and abstract primitives"
        concrete_class: "Implements primitive operations"
      examples:
        python: |
          class DataMiner(ABC):
              def mine(self, path: str) -> dict:
                  """Template method - defines algorithm skeleton."""
                  file = self.open_file(path)
                  raw_data = self.extract_data(file)
                  data = self.parse_data(raw_data)
                  analysis = self.analyze_data(data)
                  self.send_report(analysis)
                  return analysis

              @abstractmethod
              def open_file(self, path: str) -> File: pass

              @abstractmethod
              def extract_data(self, file: File) -> str: pass

              @abstractmethod
              def parse_data(self, raw_data: str) -> dict: pass

              def analyze_data(self, data: dict) -> dict:
                  # Default implementation, can be overridden
                  return {"summary": data}

              def send_report(self, analysis: dict) -> None:
                  # Hook - optional override
                  pass

          class PDFMiner(DataMiner):
              def open_file(self, path: str) -> File:
                  return PDFFile(path)
              # ... other implementations
      hooks:
        description: "Optional methods with default (often empty) implementation"
        purpose: "Allow subclasses to hook into algorithm at specific points"
      anti_patterns:
        - too_many_abstract_methods
        - calling_abstract_methods_from_constructor
    severity: info
    rationale: |
      Template method implements invariant algorithm structure while allowing
      variation in specific steps. "Don't call us, we'll call you."

  - id: state-pattern
    description: Allow object to alter behavior when internal state changes
    check_type: design_pattern
    details:
      intent: |
        Allow an object to alter its behavior when its internal state
        changes. The object will appear to change its class.
      use_when:
        - behavior_depends_on_state
        - operations_have_large_multipart_conditionals_on_state
      structure:
        context: "Defines interface, maintains current state"
        state: "Defines interface for encapsulating state behavior"
        concrete_states: "Implement behavior associated with state"
      examples:
        python: |
          class OrderState(Protocol):
              def confirm(self, order: "Order") -> None: ...
              def ship(self, order: "Order") -> None: ...
              def cancel(self, order: "Order") -> None: ...

          class PendingState:
              def confirm(self, order: "Order") -> None:
                  order.state = ConfirmedState()

              def ship(self, order: "Order") -> None:
                  raise InvalidOperationError("Cannot ship pending order")

              def cancel(self, order: "Order") -> None:
                  order.state = CancelledState()

          class ConfirmedState:
              def confirm(self, order: "Order") -> None:
                  raise InvalidOperationError("Already confirmed")

              def ship(self, order: "Order") -> None:
                  order.state = ShippedState()

              def cancel(self, order: "Order") -> None:
                  order.state = CancelledState()

          class Order:
              def __init__(self):
                  self.state: OrderState = PendingState()

              def confirm(self) -> None:
                  self.state.confirm(self)

              def ship(self) -> None:
                  self.state.ship(self)
      replaces: "Large if/switch statements on state enum"
      vs_strategy:
        state: "States know about each other and trigger transitions"
        strategy: "Strategies are independent, client chooses"
    severity: info
    rationale: |
      State pattern localizes state-specific behavior. New states can be
      added without modifying existing state classes or context.

  - id: chain-of-responsibility
    description: Pass request along chain of handlers until one handles it
    check_type: design_pattern
    details:
      intent: |
        Avoid coupling sender to receiver by giving more than one object
        a chance to handle request. Chain the receiving objects and pass
        the request along the chain until an object handles it.
      use_when:
        - more_than_one_object_may_handle_request
        - handler_not_known_a_priori
        - want_to_issue_request_without_specifying_receiver
        - handlers_should_be_dynamic
      structure:
        handler: "Defines interface for handling requests, optional successor link"
        concrete_handler: "Handles requests it's responsible for"
        client: "Initiates request to handler on chain"
      examples:
        python: |
          class Handler(ABC):
              def __init__(self, next_handler: "Handler | None" = None):
                  self._next = next_handler

              def handle(self, request: Request) -> Response | None:
                  result = self._handle(request)
                  if result is not None:
                      return result
                  if self._next:
                      return self._next.handle(request)
                  return None

              @abstractmethod
              def _handle(self, request: Request) -> Response | None: pass

          class AuthenticationHandler(Handler):
              def _handle(self, request: Request) -> Response | None:
                  if not request.is_authenticated():
                      return Response(401, "Unauthorized")
                  return None  # Pass to next handler

          class ValidationHandler(Handler):
              def _handle(self, request: Request) -> Response | None:
                  if not request.is_valid():
                      return Response(400, "Bad Request")
                  return None

          # Build chain
          chain = AuthenticationHandler(
              ValidationHandler(
                  BusinessLogicHandler()
              )
          )
      use_cases:
        - middleware_pipelines
        - event_handling
        - logging_levels
        - approval_workflows
    severity: info
    rationale: |
      Chain of responsibility decouples sender from receivers. Handlers
      can be added, removed, or reordered without affecting client.

  - id: mediator-pattern
    description: Define object that encapsulates how objects interact
    check_type: design_pattern
    details:
      intent: |
        Define an object that encapsulates how a set of objects interact.
        Mediator promotes loose coupling by keeping objects from referring
        to each other explicitly.
      use_when:
        - objects_communicate_in_complex_ways
        - reusing_object_is_difficult_due_to_dependencies
        - behavior_distributed_between_classes_should_be_customizable
      structure:
        mediator: "Defines interface for colleague communication"
        concrete_mediator: "Implements coordination, knows colleagues"
        colleague: "Knows its mediator, communicates through it"
      examples:
        python: |
          class ChatMediator:
              def __init__(self):
                  self._users: dict[str, User] = {}

              def register(self, user: "User") -> None:
                  self._users[user.name] = user

              def send(self, message: str, sender: "User", recipient: str) -> None:
                  if recipient in self._users:
                      self._users[recipient].receive(message, sender.name)

          class User:
              def __init__(self, name: str, mediator: ChatMediator):
                  self.name = name
                  self._mediator = mediator
                  mediator.register(self)

              def send(self, message: str, to: str) -> None:
                  self._mediator.send(message, self, to)

              def receive(self, message: str, from_user: str) -> None:
                  print(f"{self.name} received from {from_user}: {message}")
      use_cases:
        - ui_dialogs
        - chat_systems
        - air_traffic_control
        - event_orchestration
      vs_observer:
        mediator: "Centralizes communication logic"
        observer: "Distributes communication"
    severity: info
    rationale: |
      Mediator centralizes complex communication logic. Objects only know
      the mediator, not each other, reducing dependencies.

  - id: iterator-pattern
    description: Access elements of aggregate sequentially without exposing representation
    check_type: design_pattern
    details:
      intent: |
        Provide a way to access elements of an aggregate object sequentially
        without exposing its underlying representation.
      use_when:
        - access_aggregate_contents_without_exposing_internals
        - support_multiple_traversals_of_aggregates
        - provide_uniform_interface_for_traversing_different_structures
      structure:
        iterator: "Defines interface for accessing and traversing"
        concrete_iterator: "Implements Iterator, tracks traversal position"
        aggregate: "Defines interface for creating Iterator"
        concrete_aggregate: "Returns instance of ConcreteIterator"
      examples:
        python: |
          from typing import Iterator, Iterable

          class TreeNode:
              def __init__(self, value: int):
                  self.value = value
                  self.left: TreeNode | None = None
                  self.right: TreeNode | None = None

              def __iter__(self) -> Iterator[int]:
                  """In-order traversal iterator."""
                  if self.left:
                      yield from self.left
                  yield self.value
                  if self.right:
                      yield from self.right

          # Different traversal strategies
          def preorder(node: TreeNode | None) -> Iterator[int]:
              if node:
                  yield node.value
                  yield from preorder(node.left)
                  yield from preorder(node.right)

          def bfs(root: TreeNode) -> Iterator[int]:
              queue = [root]
              while queue:
                  node = queue.pop(0)
                  yield node.value
                  if node.left: queue.append(node.left)
                  if node.right: queue.append(node.right)
      note: |
        Most languages have built-in iterator support (Python's __iter__,
        Java's Iterator, C#'s IEnumerable). Use language features first.
    severity: info
    rationale: |
      Iterator simplifies aggregate interface and supports multiple
      simultaneous traversals. Language support often makes explicit
      implementation unnecessary.

  - id: visitor-pattern
    description: Define new operation without changing classes of elements it operates on
    check_type: design_pattern
    details:
      intent: |
        Represent an operation to be performed on elements of an object
        structure. Visitor lets you define a new operation without
        changing the classes of the elements on which it operates.
      use_when:
        - object_structure_contains_many_classes_with_differing_interfaces
        - many_distinct_operations_needed_on_structure
        - classes_of_structure_rarely_change_but_operations_often_change
      structure:
        visitor: "Declares visit operation for each ConcreteElement class"
        concrete_visitor: "Implements operations for each element type"
        element: "Defines accept operation taking visitor"
        concrete_element: "Implements accept to call visitor's corresponding method"
      examples:
        python: |
          class ASTVisitor(Protocol):
              def visit_literal(self, node: "Literal") -> Any: ...
              def visit_binary(self, node: "Binary") -> Any: ...
              def visit_unary(self, node: "Unary") -> Any: ...

          class ASTNode(ABC):
              @abstractmethod
              def accept(self, visitor: ASTVisitor) -> Any: pass

          class Literal(ASTNode):
              def __init__(self, value: Any):
                  self.value = value

              def accept(self, visitor: ASTVisitor) -> Any:
                  return visitor.visit_literal(self)

          class Binary(ASTNode):
              def __init__(self, left: ASTNode, op: str, right: ASTNode):
                  self.left, self.op, self.right = left, op, right

              def accept(self, visitor: ASTVisitor) -> Any:
                  return visitor.visit_binary(self)

          # Different operations as visitors
          class Evaluator:
              def visit_literal(self, node: Literal) -> int:
                  return node.value

              def visit_binary(self, node: Binary) -> int:
                  left = node.left.accept(self)
                  right = node.right.accept(self)
                  if node.op == "+": return left + right
                  if node.op == "*": return left * right

          class PrettyPrinter:
              def visit_literal(self, node: Literal) -> str:
                  return str(node.value)

              def visit_binary(self, node: Binary) -> str:
                  return f"({node.left.accept(self)} {node.op} {node.right.accept(self)})"
      use_cases:
        - compiler_ast_operations
        - document_export_formats
        - report_generation
        - validation_rules
      anti_patterns:
        - visitor_for_frequently_changing_element_types
    severity: info
    rationale: |
      Visitor gathers related operations together. Adding new operations
      is easy - just add new visitor. But adding new element types requires
      changing all visitors.

  - id: memento-pattern
    description: Capture and restore object's internal state
    check_type: design_pattern
    details:
      intent: |
        Without violating encapsulation, capture and externalize an object's
        internal state so that the object can be restored to this state later.
      use_when:
        - need_to_save_and_restore_state
        - direct_state_access_violates_encapsulation
        - implementing_undo_functionality
      structure:
        memento: "Stores internal state of Originator"
        originator: "Creates memento containing snapshot of current state"
        caretaker: "Responsible for memento's safekeeping"
      examples:
        python: |
          @dataclass(frozen=True)
          class EditorMemento:
              """Immutable snapshot of editor state."""
              text: str
              cursor_position: int

          class TextEditor:
              def __init__(self):
                  self._text = ""
                  self._cursor = 0

              def type(self, text: str) -> None:
                  self._text = self._text[:self._cursor] + text + self._text[self._cursor:]
                  self._cursor += len(text)

              def save(self) -> EditorMemento:
                  return EditorMemento(self._text, self._cursor)

              def restore(self, memento: EditorMemento) -> None:
                  self._text = memento.text
                  self._cursor = memento.cursor_position

          class History:
              def __init__(self, editor: TextEditor):
                  self._editor = editor
                  self._history: list[EditorMemento] = []

              def backup(self) -> None:
                  self._history.append(self._editor.save())

              def undo(self) -> None:
                  if self._history:
                      self._editor.restore(self._history.pop())
      vs_command:
        memento: "Stores complete state snapshot"
        command: "Stores operation that can be reversed"
    severity: info
    rationale: |
      Memento preserves encapsulation boundaries. Only the originator
      can store and retrieve state from memento.

  # ============================================================
  # Architectural Patterns
  # ============================================================

  - id: repository-pattern
    description: Mediate between domain and data mapping layers
    check_type: architectural_pattern
    details:
      intent: |
        Mediates between the domain and data mapping layers using a
        collection-like interface for accessing domain objects.
      use_when:
        - want_to_abstract_data_access
        - need_testable_data_layer
        - domain_should_be_persistence_ignorant
      structure:
        repository_interface: "Defines collection-like operations"
        concrete_repository: "Implements using specific data store"
        domain_entity: "Objects being stored and retrieved"
      examples:
        python: |
          class UserRepository(Protocol):
              def get(self, user_id: str) -> User | None: ...
              def get_by_email(self, email: str) -> User | None: ...
              def save(self, user: User) -> None: ...
              def delete(self, user_id: str) -> None: ...
              def find_active(self) -> list[User]: ...

          class PostgresUserRepository:
              def __init__(self, session: Session):
                  self._session = session

              def get(self, user_id: str) -> User | None:
                  return self._session.query(User).get(user_id)

              def save(self, user: User) -> None:
                  self._session.add(user)

          class InMemoryUserRepository:
              """For testing."""
              def __init__(self):
                  self._users: dict[str, User] = {}

              def get(self, user_id: str) -> User | None:
                  return self._users.get(user_id)
      guidelines:
        - one_repository_per_aggregate_root
        - return_domain_objects_not_dtos
        - encapsulate_query_logic
      anti_patterns:
        - generic_repository_for_everything
        - repository_with_business_logic
        - exposing_query_builder
    severity: info
    rationale: |
      Repository abstracts data access, making domain layer testable
      and persistence-ignorant. Centralizes query logic.

  - id: unit-of-work-pattern
    description: Maintain list of objects affected by business transaction
    check_type: architectural_pattern
    details:
      intent: |
        Maintain a list of objects affected by a business transaction
        and coordinate the writing out of changes and resolution of
        concurrency problems.
      use_when:
        - multiple_objects_change_in_one_transaction
        - need_to_track_changes_for_persistence
        - want_to_batch_database_operations
      structure:
        unit_of_work: "Tracks changes, commits as single transaction"
        repositories: "Access objects within unit of work scope"
      examples:
        python: |
          class UnitOfWork:
              def __init__(self, session_factory: Callable[[], Session]):
                  self._session_factory = session_factory
                  self._session: Session | None = None

              def __enter__(self) -> "UnitOfWork":
                  self._session = self._session_factory()
                  self.users = UserRepository(self._session)
                  self.orders = OrderRepository(self._session)
                  return self

              def __exit__(self, exc_type, exc_val, exc_tb) -> None:
                  if exc_type is None:
                      self.commit()
                  else:
                      self.rollback()
                  self._session.close()

              def commit(self) -> None:
                  self._session.commit()

              def rollback(self) -> None:
                  self._session.rollback()

          # Usage
          with UnitOfWork(session_factory) as uow:
              user = uow.users.get(user_id)
              user.deactivate()
              order = uow.orders.get(order_id)
              order.cancel()
              # Changes committed together or rolled back
      benefits:
        - atomic_operations
        - change_tracking
        - batched_writes
    severity: info
    rationale: |
      Unit of work ensures data integrity by treating multiple operations
      as single atomic transaction. Common with Repository pattern.

  - id: cqrs-pattern
    description: Separate read and write models
    check_type: architectural_pattern
    details:
      intent: |
        Command Query Responsibility Segregation - separate models for
        reading and writing data.
      use_when:
        - read_and_write_workloads_differ_significantly
        - complex_domain_model_for_writes
        - need_optimized_read_models
        - different_scaling_requirements_for_reads_vs_writes
      structure:
        command_model: "Handles writes, domain logic, validation"
        query_model: "Optimized for reads, potentially denormalized"
        commands: "Represent intent to change state"
        queries: "Represent intent to read state"
      examples:
        python: |
          # Command side
          @dataclass
          class CreateOrderCommand:
              customer_id: str
              items: list[OrderItem]

          class CreateOrderHandler:
              def __init__(self, uow: UnitOfWork):
                  self._uow = uow

              def handle(self, cmd: CreateOrderCommand) -> str:
                  with self._uow:
                      order = Order.create(cmd.customer_id, cmd.items)
                      self._uow.orders.save(order)
                      return order.id

          # Query side
          @dataclass
          class OrderSummary:
              id: str
              customer_name: str
              total: Decimal
              status: str

          class OrderQueryService:
              def __init__(self, read_db: ReadDatabase):
                  self._db = read_db

              def get_order_summary(self, order_id: str) -> OrderSummary:
                  # Direct query against read-optimized store
                  return self._db.query("""
                      SELECT o.id, c.name, o.total, o.status
                      FROM orders_view o
                      JOIN customers c ON o.customer_id = c.id
                      WHERE o.id = ?
                  """, order_id)
      complexity_warning: |
        CQRS adds significant complexity. Only use when benefits
        clearly outweigh costs. Most applications don't need it.
    severity: info
    rationale: |
      CQRS enables optimized read and write paths. Especially useful
      with Event Sourcing. But adds complexity - use judiciously.

  - id: event-sourcing-pattern
    description: Store state as sequence of events
    check_type: architectural_pattern
    details:
      intent: |
        Store the state of an entity as a sequence of state-changing events.
        Reconstruct state by replaying events.
      use_when:
        - need_complete_audit_trail
        - business_requires_temporal_queries
        - need_to_understand_how_state_changed
        - domain_events_are_first_class_concept
      structure:
        event: "Immutable record of something that happened"
        event_store: "Append-only store of events"
        aggregate: "Applies events to change state"
        projection: "Read model built from events"
      examples:
        python: |
          @dataclass(frozen=True)
          class AccountCreated:
              account_id: str
              owner: str
              timestamp: datetime

          @dataclass(frozen=True)
          class MoneyDeposited:
              account_id: str
              amount: Decimal
              timestamp: datetime

          @dataclass(frozen=True)
          class MoneyWithdrawn:
              account_id: str
              amount: Decimal
              timestamp: datetime

          class BankAccount:
              def __init__(self, account_id: str):
                  self.id = account_id
                  self.balance = Decimal(0)
                  self._events: list[Event] = []

              def apply(self, event: Event) -> None:
                  match event:
                      case AccountCreated():
                          pass  # Account initialized
                      case MoneyDeposited(amount=amount):
                          self.balance += amount
                      case MoneyWithdrawn(amount=amount):
                          self.balance -= amount
                  self._events.append(event)

              def deposit(self, amount: Decimal) -> None:
                  if amount <= 0:
                      raise ValueError("Amount must be positive")
                  self.apply(MoneyDeposited(self.id, amount, datetime.now()))

              @classmethod
              def from_events(cls, account_id: str, events: list[Event]) -> "BankAccount":
                  account = cls(account_id)
                  for event in events:
                      account.apply(event)
                  return account
      complexity_warning: |
        Event Sourcing is complex. Requires careful event schema design,
        event versioning, and snapshot strategies. Use only when audit
        trail or temporal queries are critical requirements.
    severity: info
    rationale: |
      Event sourcing provides complete history and enables temporal queries.
      Natural fit for domains where "what happened" is as important as
      "what is the current state."

  # ============================================================
  # Modern Patterns
  # ============================================================

  - id: dependency-injection-container
    description: Centralized dependency management and lifetime control
    check_type: architectural_pattern
    details:
      intent: |
        Centralize object creation and dependency resolution.
        Manage object lifetimes (singleton, scoped, transient).
      use_when:
        - complex_dependency_graphs
        - need_different_lifetimes_for_different_services
        - want_configuration_based_wiring
      lifetimes:
        singleton: "One instance for application lifetime"
        scoped: "One instance per scope (e.g., HTTP request)"
        transient: "New instance every time"
      examples:
        python: |
          from dependency_injector import containers, providers

          class Container(containers.DeclarativeContainer):
              config = providers.Configuration()

              db_session = providers.Singleton(
                  create_session,
                  connection_string=config.db_url
              )

              user_repository = providers.Factory(
                  UserRepository,
                  session=db_session
              )

              user_service = providers.Factory(
                  UserService,
                  repo=user_repository
              )

          # Usage
          container = Container()
          container.config.from_yaml("config.yaml")
          service = container.user_service()
      anti_patterns:
        - service_locator_instead_of_injection
        - injecting_container_itself
        - over_using_singletons
    severity: info
    rationale: |
      DI containers manage complex object graphs and lifetimes.
      Make dependencies explicit while reducing boilerplate.

  - id: circuit-breaker-pattern
    description: Prevent cascading failures by failing fast
    check_type: resilience_pattern
    details:
      intent: |
        Prevent an application from repeatedly trying to execute an
        operation that's likely to fail, allowing it to continue without
        waiting for the fault to be fixed.
      states:
        closed: "Normal operation, requests pass through"
        open: "Failures exceeded threshold, requests fail immediately"
        half_open: "Testing if service recovered"
      use_when:
        - calling_external_services
        - preventing_cascade_failures
        - giving_failed_services_time_to_recover
      examples:
        python: |
          class CircuitBreaker:
              def __init__(
                  self,
                  failure_threshold: int = 5,
                  recovery_timeout: float = 30.0
              ):
                  self._failure_count = 0
                  self._failure_threshold = failure_threshold
                  self._recovery_timeout = recovery_timeout
                  self._state = "closed"
                  self._last_failure_time: float | None = None

              async def call(self, func: Callable[[], T]) -> T:
                  if self._state == "open":
                      if self._should_attempt_reset():
                          self._state = "half_open"
                      else:
                          raise CircuitOpenError()

                  try:
                      result = await func()
                      self._on_success()
                      return result
                  except Exception as e:
                      self._on_failure()
                      raise

              def _on_success(self) -> None:
                  self._failure_count = 0
                  self._state = "closed"

              def _on_failure(self) -> None:
                  self._failure_count += 1
                  self._last_failure_time = time.time()
                  if self._failure_count >= self._failure_threshold:
                      self._state = "open"
      related_patterns:
        - retry_pattern
        - bulkhead_pattern
        - timeout_pattern
    severity: info
    rationale: |
      Circuit breaker prevents wasting resources on likely-to-fail calls
      and gives failed services time to recover.

  - id: saga-pattern
    description: Manage distributed transactions through compensating actions
    check_type: architectural_pattern
    details:
      intent: |
        Manage data consistency across microservices in distributed
        transactions using a sequence of local transactions with
        compensating transactions for rollback.
      types:
        choreography: "Services publish events, others react"
        orchestration: "Central coordinator directs participants"
      use_when:
        - distributed_transactions_across_services
        - eventual_consistency_acceptable
        - need_to_maintain_data_consistency
      structure:
        saga_step: "Local transaction with compensating action"
        compensating_action: "Undo action if saga fails"
      examples:
        python: |
          @dataclass
          class SagaStep:
              action: Callable[[], Awaitable[None]]
              compensation: Callable[[], Awaitable[None]]

          class CreateOrderSaga:
              def __init__(
                  self,
                  order_service: OrderService,
                  payment_service: PaymentService,
                  inventory_service: InventoryService
              ):
                  self._order = order_service
                  self._payment = payment_service
                  self._inventory = inventory_service

              async def execute(self, order: OrderRequest) -> str:
                  steps: list[SagaStep] = []
                  try:
                      # Step 1: Reserve inventory
                      await self._inventory.reserve(order.items)
                      steps.append(SagaStep(
                          action=lambda: None,  # Already done
                          compensation=lambda: self._inventory.release(order.items)
                      ))

                      # Step 2: Process payment
                      payment_id = await self._payment.charge(order.total)
                      steps.append(SagaStep(
                          action=lambda: None,
                          compensation=lambda: self._payment.refund(payment_id)
                      ))

                      # Step 3: Create order
                      order_id = await self._order.create(order)
                      return order_id

                  except Exception:
                      # Compensate in reverse order
                      for step in reversed(steps):
                          await step.compensation()
                      raise
      complexity_warning: |
        Sagas are complex. Consider if you really need distributed
        transactions or if you can redesign to avoid them.
    severity: info
    rationale: |
      Sagas maintain consistency in distributed systems without
      distributed transactions. Essential for microservices.

  - id: specification-pattern
    description: Encapsulate business rules as combinable, reusable objects
    check_type: design_pattern
    details:
      intent: |
        Encapsulate a business rule in a reusable, combinable object.
        Specifications can be combined with AND, OR, NOT operations.
      use_when:
        - business_rules_need_to_be_reusable
        - rules_need_to_be_combined
        - selection_criteria_is_complex
        - same_rule_used_for_validation_and_querying
      structure:
        specification: "Defines is_satisfied_by method"
        composite_specification: "Combines specifications"
      examples:
        python: |
          class Specification(ABC, Generic[T]):
              @abstractmethod
              def is_satisfied_by(self, candidate: T) -> bool: pass

              def and_(self, other: "Specification[T]") -> "Specification[T]":
                  return AndSpecification(self, other)

              def or_(self, other: "Specification[T]") -> "Specification[T]":
                  return OrSpecification(self, other)

              def not_(self) -> "Specification[T]":
                  return NotSpecification(self)

          class AndSpecification(Specification[T]):
              def __init__(self, left: Specification[T], right: Specification[T]):
                  self._left = left
                  self._right = right

              def is_satisfied_by(self, candidate: T) -> bool:
                  return (
                      self._left.is_satisfied_by(candidate) and
                      self._right.is_satisfied_by(candidate)
                  )

          # Business rules as specifications
          class IsAdult(Specification[User]):
              def is_satisfied_by(self, user: User) -> bool:
                  return user.age >= 18

          class HasValidEmail(Specification[User]):
              def is_satisfied_by(self, user: User) -> bool:
                  return "@" in user.email

          # Combine specifications
          can_register = IsAdult().and_(HasValidEmail())

          # Use for validation
          if can_register.is_satisfied_by(user):
              register(user)

          # Use for querying
          eligible_users = [u for u in users if can_register.is_satisfied_by(u)]
      benefits:
        - reusable_business_rules
        - composable
        - testable_in_isolation
    severity: info
    rationale: |
      Specification pattern makes business rules explicit, reusable,
      and composable. Same specification works for validation and filtering.

escalation_triggers:
  - trigger_id: pattern-overuse
    condition: Multiple design patterns applied where simpler solution exists
    severity: advisory
    prompt: |
      Multiple design patterns detected. Consider:
      - Is the complexity justified?
      - Could a simpler solution work?
      - Are you solving actual vs. anticipated problems?
    rationale: |
      Patterns add complexity. Only use when benefits outweigh costs.
      "The simplest thing that could possibly work."

  - trigger_id: pattern-misapplication
    condition: Pattern applied in inappropriate context
    severity: advisory
    prompt: |
      Pattern may not fit this context:
      - Review pattern's intended use cases
      - Consider if problem matches pattern's problem
      - Evaluate alternative approaches
    rationale: |
      Patterns solve specific problems. Misapplication adds
      complexity without benefits.

  - trigger_id: missing-pattern
    condition: Code smell that could be addressed with known pattern
    severity: info
    prompt: |
      Code structure suggests a pattern might help:
      - Consider if a design pattern applies
      - Evaluate if refactoring would improve design
      - Balance improvement vs. change scope
    rationale: |
      Patterns encode proven solutions. Recognizing when they
      apply improves design.

quality_gates:
  - gate_id: pattern-review
    checks:
      - Patterns applied appropriately
      - Pattern implementation is correct
      - Not over-engineered
      - Consistent with codebase patterns
    failure_action: advisory

  - gate_id: architectural-pattern-review
    checks:
      - Architectural patterns justified
      - Complexity warranted by requirements
      - Team familiar with chosen patterns
      - Patterns documented
    failure_action: escalate
