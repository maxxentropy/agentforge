# @spec_file: .agentforge/specs/core-harness-v1.yaml
# @spec_id: core-harness-v1
# @component_id: tools-harness-recovery_executor
# @impl_path: tools/harness/recovery_executor.py

# Generated by AgentForge
# Spec: recovery_strategies
# Phase: red
# Date: 2025-12-31 06:47:12 UTC

"""
Tests for RecoveryExecutor component.
These tests verify the recovery strategy execution logic including policy matching,
action execution, and various recovery operations like checkpoint, rollback, summarize, etc.
"""

from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import Mock, patch

from agentforge.core.harness.checkpoint_manager import CheckpointManager
from agentforge.core.harness.recovery_domain import (
    Checkpoint,
    RecoveryAction,
    RecoveryAttempt,
    RecoveryPolicy,
    RecoveryResult,
)
from agentforge.core.harness.recovery_executor import RecoveryExecutor


class TestRecoveryExecutorInit:
    """Test RecoveryExecutor initialization."""

    def test_init_with_checkpoint_manager_and_policies(self):
        """Test initialization with checkpoint manager and policies."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policies = [
            RecoveryPolicy(
                name="test_policy",
                triggers=["loop"],
                actions=[RecoveryAction.CHECKPOINT, RecoveryAction.ROLLBACK],
                max_attempts=3,
                cooldown_seconds=60
            )
        ]

        executor = RecoveryExecutor(checkpoint_manager, policies)

        assert executor.checkpoint_manager == checkpoint_manager
        assert len(executor.policies) == 1
        assert executor.policies[0].name == "test_policy"

    def test_init_with_default_policies_when_none_provided(self):
        """Test initialization loads default policies when none provided."""
        checkpoint_manager = Mock(spec=CheckpointManager)

        executor = RecoveryExecutor(checkpoint_manager)

        # Should have default policies loaded
        assert len(executor.policies) > 0
        policy_names = [p.name for p in executor.policies]
        assert "loop_recovery" in policy_names
        assert "drift_recovery" in policy_names
        assert "thrashing_recovery" in policy_names


class TestExecuteRecovery:
    """Test main recovery execution logic."""

    def test_execute_recovery_matches_health_issues_to_policies(self):
        """Test that recovery execution matches health issues to appropriate policies."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="loop_policy",
            triggers=["loop", "Loop detected"],
            actions=[RecoveryAction.CHECKPOINT],
            max_attempts=3,
            cooldown_seconds=30
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        # Mock health with loop issue
        health = Mock()
        health.issues = ["Loop detected in workflow"]

        with patch.object(executor, 'execute_action') as mock_execute:
            mock_execute.return_value = RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger="Loop detected in workflow",
                result=RecoveryResult.SUCCESS
            )

            result = executor.execute_recovery(health, "session123", {"state": "data"})

            assert result.action == RecoveryAction.CHECKPOINT
            assert result.trigger == "Loop detected in workflow"
            mock_execute.assert_called_once()

    def test_execute_recovery_respects_cooldown_periods(self):
        """Test that recovery execution respects cooldown periods between attempts."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="test_policy",
            triggers=["loop"],
            actions=[RecoveryAction.CHECKPOINT],
            max_attempts=3,
            cooldown_seconds=60
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        # Set last recovery time for this policy within cooldown
        executor.last_recovery_times["test_policy"] = datetime.now() - timedelta(seconds=30)

        health = Mock()
        health.issues = ["loop detected"]

        result = executor.execute_recovery(health, "session123", {"state": "data"})

        # Should skip because cooldown hasn't passed, resulting in no matching policy
        assert result.result == RecoveryResult.SKIPPED

    def test_execute_recovery_tries_actions_in_order_until_success(self):
        """Test that recovery tries actions in order until one succeeds."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="test_policy",
            triggers=["error"],
            actions=[RecoveryAction.CHECKPOINT, RecoveryAction.ROLLBACK, RecoveryAction.RESET],
            max_attempts=3,
            cooldown_seconds=0
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        health = Mock()
        health.issues = ["error occurred"]

        # Mock first action fails, second succeeds
        with patch.object(executor, 'execute_action') as mock_execute:
            mock_execute.side_effect = [
                RecoveryAttempt(action=RecoveryAction.CHECKPOINT, timestamp=datetime.now(),
                              trigger="error", result=RecoveryResult.FAILED),
                RecoveryAttempt(action=RecoveryAction.ROLLBACK, timestamp=datetime.now(),
                              trigger="error", result=RecoveryResult.SUCCESS)
            ]

            result = executor.execute_recovery(health, "session123", {"state": "data"})

            assert result.action == RecoveryAction.ROLLBACK
            assert result.result == RecoveryResult.SUCCESS
            assert mock_execute.call_count == 2

    def test_execute_recovery_records_attempt_result(self):
        """Test that recovery execution records the attempt result."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        health = Mock()
        health.issues = ["unknown issue"]

        result = executor.execute_recovery(health, "session123", {"state": "data"})

        assert isinstance(result, RecoveryAttempt)
        assert result.timestamp is not None
        # Note: SKIPPED results from no matching policy aren't recorded
        # Only actual recovery attempts are recorded in recovery_history


class TestExecuteAction:
    """Test individual recovery action execution."""

    def test_execute_action_checkpoint_calls_checkpoint_method(self):
        """Test that CHECKPOINT action calls the checkpoint method."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        context = {
            "session_id": "session123",
            "state": {"key": "value", "phase": "analysis"},
        }

        with patch.object(executor, 'checkpoint') as mock_checkpoint:
            mock_checkpoint.return_value = RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger="test",
                result=RecoveryResult.SUCCESS
            )

            result = executor.execute_action(RecoveryAction.CHECKPOINT, context)

            # Implementation calls with keyword args and uses state.get("phase")
            mock_checkpoint.assert_called_once()
            assert result.action == RecoveryAction.CHECKPOINT

    def test_execute_action_rollback_calls_rollback_method(self):
        """Test that ROLLBACK action calls the rollback method."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        context = {"session_id": "session123"}

        with patch.object(executor, 'rollback') as mock_rollback:
            mock_rollback.return_value = RecoveryAttempt(
                action=RecoveryAction.ROLLBACK,
                timestamp=datetime.now(),
                trigger="test",
                result=RecoveryResult.SUCCESS
            )

            result = executor.execute_action(RecoveryAction.ROLLBACK, context)

            mock_rollback.assert_called_once_with("session123")
            assert result.action == RecoveryAction.ROLLBACK

    def test_execute_action_unknown_action_returns_failed_attempt(self):
        """Test that unknown action returns a failed attempt."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        # Use a mock action that doesn't exist
        unknown_action = "UNKNOWN_ACTION"
        context = {"session_id": "session123"}

        result = executor.execute_action(unknown_action, context)

        assert result.result == RecoveryResult.FAILED
        assert "unknown action" in result.error.lower()


class TestCheckpointMethod:
    """Test checkpoint creation method."""

    def test_checkpoint_creates_checkpoint_successfully(self):
        """Test successful checkpoint creation."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        checkpoint = Checkpoint(
            id="checkpoint123",
            timestamp=datetime.now(),
            session_id="session123",
            phase="analysis",
            state={"key": "value"},
            file_backups=["/backup/test.py"]
        )
        checkpoint_manager.create_checkpoint.return_value = checkpoint

        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.checkpoint(
            "session123", "analysis", {"key": "value"}, [Path("/tmp/test.py")]
        )

        # Implementation uses keyword args with description
        checkpoint_manager.create_checkpoint.assert_called_once()
        call_kwargs = checkpoint_manager.create_checkpoint.call_args
        assert call_kwargs.kwargs.get("session_id") == "session123"
        assert call_kwargs.kwargs.get("phase") == "analysis"
        assert result.action == RecoveryAction.CHECKPOINT
        assert result.result == RecoveryResult.SUCCESS
        assert result.details["checkpoint_id"] == "checkpoint123"

    def test_checkpoint_handles_creation_failure(self):
        """Test checkpoint creation failure handling."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        checkpoint_manager.create_checkpoint.side_effect = Exception("Disk full")

        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.checkpoint("session123", "analysis", {"key": "value"})

        assert result.action == RecoveryAction.CHECKPOINT
        assert result.result == RecoveryResult.FAILED
        assert "Disk full" in result.error


class TestRollbackMethod:
    """Test rollback to checkpoint method."""

    def test_rollback_restores_last_checkpoint_successfully(self):
        """Test successful rollback to last checkpoint."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        checkpoint = Checkpoint(
            id="checkpoint123",
            timestamp=datetime.now(),
            session_id="session123",
            phase="analysis",
            state={"restored": "state"},
            file_backups=[]
        )
        checkpoint_manager.list_checkpoints.return_value = [checkpoint]
        checkpoint_manager.restore_checkpoint.return_value = True

        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.rollback("session123")

        checkpoint_manager.list_checkpoints.assert_called_once_with("session123")
        checkpoint_manager.restore_checkpoint.assert_called_once_with("checkpoint123")
        assert result.action == RecoveryAction.ROLLBACK
        assert result.result == RecoveryResult.SUCCESS

    def test_rollback_fails_when_no_checkpoints_available(self):
        """Test rollback failure when no checkpoints are available."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        checkpoint_manager.list_checkpoints.return_value = []

        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.rollback("session123")

        assert result.action == RecoveryAction.ROLLBACK
        assert result.result == RecoveryResult.FAILED
        assert "no checkpoints" in result.error.lower()

    def test_rollback_fails_when_restore_fails(self):
        """Test rollback failure when checkpoint restore fails."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        checkpoint = Checkpoint(
            id="checkpoint123",
            timestamp=datetime.now(),
            session_id="session123",
            phase="analysis",
            state={},
            file_backups=[]
        )
        checkpoint_manager.list_checkpoints.return_value = [checkpoint]
        checkpoint_manager.restore_checkpoint.return_value = False

        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.rollback("session123")

        assert result.action == RecoveryAction.ROLLBACK
        assert result.result == RecoveryResult.FAILED


class TestSummarizeContext:
    """Test context summarization method."""

    def test_summarize_context_compresses_long_context(self):
        """Test that long context gets compressed appropriately."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        # Create a long context that exceeds max_tokens
        long_context = "word " * 1000  # 1000 words
        max_tokens = 500

        result = executor.summarize_context(long_context, max_tokens)

        assert result.action == RecoveryAction.SUMMARIZE
        assert result.result == RecoveryResult.SUCCESS
        assert "original_length" in result.details
        assert "new_length" in result.details  # Implementation uses "new_length"
        assert result.details["new_length"] < result.details["original_length"]

    def test_summarize_context_preserves_first_and_last_tokens(self):
        """Test that summarization preserves first and last portions."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        context = "FIRST " + "middle " * 100 + "LAST"
        max_tokens = 50

        result = executor.summarize_context(context, max_tokens)

        summarized = result.details["summarized_context"]
        assert "FIRST" in summarized
        assert "LAST" in summarized
        assert result.result == RecoveryResult.SUCCESS

    def test_summarize_context_handles_short_context(self):
        """Test that short context is returned unchanged."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        short_context = "This is short"
        max_tokens = 100

        result = executor.summarize_context(short_context, max_tokens)

        assert result.action == RecoveryAction.SUMMARIZE
        assert result.result == RecoveryResult.SUCCESS
        assert result.details["summarized_context"] == short_context


class TestResetState:
    """Test state reset method."""

    def test_reset_state_clears_problematic_state(self):
        """Test that reset clears state while preserving specified keys."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        preserve_keys = ["important_data", "session_info"]

        result = executor.reset_state("session123", preserve_keys)

        assert result.action == RecoveryAction.RESET
        assert result.result == RecoveryResult.SUCCESS
        assert result.details["preserved_keys"] == preserve_keys
        assert result.details["reset_complete"] is True
        assert result.details["session_id"] == "session123"

    def test_reset_state_handles_empty_preserve_keys(self):
        """Test reset with no keys to preserve."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.reset_state("session123", [])

        assert result.action == RecoveryAction.RESET
        assert result.result == RecoveryResult.SUCCESS
        assert result.details["preserved_keys"] == []


class TestEscalate:
    """Test human escalation method."""

    def test_escalate_creates_escalation_record(self):
        """Test that escalation creates proper escalation record."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        reason = "Unrecoverable loop detected"
        context = {"session_id": "session123", "current_phase": "analysis"}

        result = executor.escalate(reason, context)

        assert result.action == RecoveryAction.ESCALATE
        assert result.result == RecoveryResult.SUCCESS  # Escalation always succeeds
        assert result.details["reason"] == reason
        assert result.details["session_id"] == "session123"
        assert "timestamp" in result.details
        assert "recommended_actions" in result.details

    def test_escalate_includes_state_and_health_info(self):
        """Test that escalation includes state snapshot and health status."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        health = Mock()
        health.status = "critical"

        result = executor.escalate(
            "Multiple failures",
            {"session_id": "session123", "state": {"key": "value"}, "health": health}
        )

        assert result.details["state_snapshot"] == {"key": "value"}
        assert "health_status" in result.details


class TestRecoveryHistory:
    """Test recovery history management."""

    def test_get_recovery_history_returns_recent_attempts(self):
        """Test getting recent recovery attempts."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        # Add some history using public attribute
        attempts = [
            RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger="test1",
                result=RecoveryResult.SUCCESS
            ),
            RecoveryAttempt(
                action=RecoveryAction.ROLLBACK,
                timestamp=datetime.now(),
                trigger="test2",
                result=RecoveryResult.FAILED
            )
        ]
        executor.recovery_history = attempts

        history = executor.get_recovery_history()

        assert len(history) == 2

    def test_get_recovery_history_filters_by_session(self):
        """Test getting recovery history filtered by session."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        # This test assumes session filtering is implemented
        # The actual implementation would need to track session_id in attempts
        history = executor.get_recovery_history("session123")

        assert isinstance(history, list)

    def test_get_recovery_history_respects_limit(self):
        """Test that history limit is respected."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        # Add more attempts than limit using public attribute
        attempts = [
            RecoveryAttempt(
                action=RecoveryAction.CHECKPOINT,
                timestamp=datetime.now(),
                trigger=f"test{i}",
                result=RecoveryResult.SUCCESS
            ) for i in range(20)
        ]
        executor.recovery_history = attempts

        history = executor.get_recovery_history(limit=5)

        assert len(history) <= 5


class TestPolicyManagement:
    """Test recovery policy management."""

    def test_register_policy_adds_new_policy(self):
        """Test registering a new recovery policy."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        policy = RecoveryPolicy(
            name="custom_policy",
            triggers=["custom_issue"],
            actions=[RecoveryAction.RESET],
            max_attempts=2,
            cooldown_seconds=30
        )

        executor.register_policy(policy)

        assert policy in executor.policies
        assert executor.get_policy_for_issue("custom_issue") == policy

    def test_get_policy_for_issue_finds_matching_policy(self):
        """Test finding policy that matches an issue."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="loop_policy",
            triggers=["loop", "Loop detected"],
            actions=[RecoveryAction.ROLLBACK],
            max_attempts=3,
            cooldown_seconds=60
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        found_policy = executor.get_policy_for_issue("Loop detected in workflow")

        assert found_policy == policy

    def test_get_policy_for_issue_returns_none_when_no_match(self):
        """Test that no policy is returned when no triggers match."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        found_policy = executor.get_policy_for_issue("unknown issue type")

        assert found_policy is None

    def test_get_policy_for_issue_matches_partial_triggers(self):
        """Test that policy matching works with partial trigger matches."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="drift_policy",
            triggers=["drift", "High drift"],
            actions=[RecoveryAction.SUMMARIZE],
            max_attempts=2,
            cooldown_seconds=60
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        # Should match "drift" trigger
        found_policy = executor.get_policy_for_issue("Context drift detected")

        assert found_policy == policy


class TestDefaultPolicies:
    """Test that default policies are properly configured."""

    def test_default_policies_include_all_expected_policies(self):
        """Test that all expected default policies are loaded."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager)

        policy_names = [p.name for p in executor.policies]
        expected_policies = [
            "loop_recovery",
            "drift_recovery",
            "thrashing_recovery",
            "context_pressure_recovery",
            "stall_recovery"
        ]

        for expected in expected_policies:
            assert expected in policy_names

    def test_loop_recovery_policy_configuration(self):
        """Test loop recovery policy has correct configuration."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager)

        policy = executor.get_policy_for_issue("Loop detected")

        assert policy is not None
        assert policy.name == "loop_recovery"
        assert RecoveryAction.CHECKPOINT in policy.actions
        assert RecoveryAction.ROLLBACK in policy.actions
        assert RecoveryAction.RESET in policy.actions
        assert policy.max_attempts == 3
        assert policy.cooldown_seconds == 30

    def test_context_pressure_recovery_policy_configuration(self):
        """Test context pressure recovery policy configuration."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager)

        policy = executor.get_policy_for_issue("Critical context pressure")

        assert policy is not None
        assert policy.name == "context_pressure_recovery"
        assert RecoveryAction.SUMMARIZE in policy.actions
        assert RecoveryAction.CHECKPOINT in policy.actions
        assert policy.max_attempts == 2
        assert policy.cooldown_seconds == 120


class TestConstraints:
    """Test that recovery executor respects specified constraints."""

    def test_cooldown_enforced_between_recovery_attempts(self):
        """Test that cooldown period is enforced between recovery attempts."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="test_policy",
            triggers=["test_issue"],
            actions=[RecoveryAction.RETRY],
            max_attempts=3,
            cooldown_seconds=60
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        # Set cooldown time within the cooldown period
        executor.last_recovery_times["test_policy"] = datetime.now()

        health = Mock()
        health.issues = ["test_issue detected"]

        result = executor.execute_recovery(health, "session123", {})

        # Should skip because cooldown hasn't expired
        assert result.result == RecoveryResult.SKIPPED

    def test_escalation_always_succeeds_as_fallback(self):
        """Test that escalation always succeeds and serves as fallback."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        executor = RecoveryExecutor(checkpoint_manager, [])

        result = executor.escalate("Test escalation", {"context": "data"})

        assert result.result == RecoveryResult.SUCCESS
        assert result.action == RecoveryAction.ESCALATE

    def test_recovery_attempts_are_logged_for_audit(self):
        """Test that recovery attempts during execute_recovery are logged."""
        checkpoint_manager = Mock(spec=CheckpointManager)
        policy = RecoveryPolicy(
            name="test_policy",
            triggers=["test"],
            actions=[RecoveryAction.ESCALATE],  # Will succeed
            max_attempts=3,
            cooldown_seconds=0
        )
        executor = RecoveryExecutor(checkpoint_manager, [policy])

        initial_history_length = len(executor.recovery_history)

        health = Mock()
        health.issues = ["test issue"]

        # Execute recovery which should log the attempt
        executor.execute_recovery(health, "session123", {})

        assert len(executor.recovery_history) == initial_history_length + 1

        # Verify the logged attempt has all required fields
        logged_attempt = executor.recovery_history[-1]
        assert logged_attempt.action is not None
        assert logged_attempt.timestamp is not None
        assert logged_attempt.result is not None
